---
title: Project Structure
description: Understanding the deco.chat project layout and file organization
icon: Folder
---

Understanding the project layout will help you locate where to write code for tools, workflows, and the UI. A typical deco.chat project (especially one created with the React+Tailwind template) is organized as follows:

```
my-deco-app/
├── package.json          # Root package (scripts for dev, gen, deploy)
├── server/               # Cloudflare Workers (MCP server) code
│   ├── main.ts           # Main server entry point (defines tools & workflows)
│   ├── deco.gen.ts       # Generated types for integrations (auto-updated)
│   ├── wrangler.toml     # Cloudflare Workers configuration (env, account, etc.)
│   └── package.json      # Server-specific dependencies (Cloudflare runtime, etc.)
└── view/                 # Frontend code (React + Tailwind via Vite)
    ├── src/
    │   ├── main.tsx      # Frontend entry (bootstraps React app and router)
    │   ├── lib/rpc.ts    # RPC client to call server tools/workflows
    │   ├── routes/       # React Router (TanStack) route components
    │   └── components/   # Reusable UI components
    ├── index.html        # HTML template for the app
    ├── package.json      # Frontend dependencies
    └── vite.config.ts    # Vite configuration (for building the view)
```

## Server Directory (`/server`)

This is the backend Cloudflare Worker that runs your agent logic.

### `main.ts`

The entry module for your Cloudflare Worker. Here you will import the deco platform runtime and register your Tools and Workflows. Think of this as the "brain" of your agent backend. For example, you might use `withRuntime` from `@deco/workers-runtime` to create a Worker that knows about your tools/workflows and also serves the frontend assets.

### `deco.gen.ts`

This file is auto-generated by the CLI (`deco gen` command or `npm run gen`). It contains TypeScript types for all the integrations (external APIs) you've connected in your deco workspace, as well as types for your own tools/workflows if you run `gen:self`. In short, it provides a strongly-typed interface to call any integration from your code. **Do not edit this file manually.** Regenerate it whenever you add new integrations or change your tools.

### `wrangler.toml`

Configuration for Cloudflare Workers deployment. This is where your script name, account ID, KV namespace bindings, durable object bindings, etc., are defined. For example, if your app needs environment secrets or uses the KV store for the Knowledge Base, those would be referenced here. The `wrangler.toml` in a deco project typically is preconfigured to serve the built frontend assets (via `[site]` or `[assets]` config) and use the proper compatibility flags.

### Other files

e.g., a `package.json` for server dependencies (like the deco runtime, Mastra, etc.), or utility modules you add.

## View Directory (`/view`)

This holds the web frontend (if your app has a custom UI). It's a standard React application scaffolded with Vite and Tailwind CSS.

### `src/main.tsx`

The React entry point. It sets up the client-side router (using TanStack Router in the template) and renders the App. It likely imports all route definitions and establishes the `<Router>` context.

### `src/lib/rpc.ts`

**Important** – this file creates an RPC client that allows your frontend to call backend Tools and Workflows easily. It uses the types from `deco.gen.ts` to ensure you call things with the right parameters. For example, you might see:

```ts
import { createClient } from "@deco/workers-runtime/client";
import type { Env } from "../../server/deco.gen.ts";
type SelfMCP = Env["SELF"];
export const client = createClient<SelfMCP>();
```

This sets up a client object where, if you have a tool `HELLO_TOOL` as defined earlier, you can do `await client.tools.HELLO_TOOL({ name: "Alice" })` from your React code, and it will call the Worker's tool and return the result. No need to write fetch calls or API endpoints – the deco runtime handles it via RPC calls to the Worker.

### `src/routes/` and `src/components/`

Your app's UI pages and building blocks. The template uses a file-based router approach – each file in `routes/` exports a route definition. For instance, you might have an `agents.tsx` route that shows a list of agents or a chat interface. The routing library (TanStack Router) lets you define child routes and layouts. UI styling is done with Tailwind CSS classes in JSX.

### Static assets

The `index.html` and any public assets are used by Vite to build your app. Ultimately, the built files will be served by the Cloudflare Worker (the Worker is configured to fall back to serving the view when no API route matches). The development server serves these separately, but in production it's unified.

## Unified Architecture

One powerful aspect: **the server serves both API endpoints and the frontend.** During dev, `npm run dev` runs the Worker on localhost:8787 which serves API (at `/mcp` path, etc.) and also proxies the Vite dev server for the UI. In production, after deploying, your Cloudflare Worker itself serves the static files. This is enabled by the deco runtime's `fallbackToView("/")` in `main.ts`, which catches requests for HTML files and static assets. Practically, this means your whole app (frontend + backend) is contained in a single Cloudflare Worker deployment – making it very easy to deploy and host.

**To summarize:** **Write your server logic in `server/main.ts` (define tools, workflows, integrate with external APIs), and build your UI in the view directory (React components calling those tools).** The CLI and runtime will wire them together and get everything running for you.
