---
title: Creating Tools
description: Learn how to create tools in deco.chat
icon: Wrench
---

import Callout from "../../../components/ui/Callout.astro";

Tools are discrete functions that agents can call to perform specific actions like API calls, database queries, or computations. Each tool is essentially a function with a defined input and output.

## Basic Tool Structure

Every tool needs:

- **`ID`**: Unique identifier
- **`Description`**: What the tool does (helps AI decide when to use it)
- **`inputSchema` and `outputSchema`**: Zod schemas to ensure that the data coming in and out is validated and typed
- **`execute`**: The actual logic. Can use `context` provides access to environment and step data, while `inputData` offers a simpler parsed input method.


## Example

This example shows a tool that sends an email via Gmail.

```typescript
 const createSendEmailTool = (env: Env) =>
  createTool({
    id: "SEND_EMAIL",
    description: "Send an email via Gmail",
    inputSchema: z.object({
      to: z.string().email(),
      subject: z.string(),
      body: z.string(),
    }),
    outputSchema: z.object({ success: z.boolean() }),
    execute: async ({ inputData }) => {
      const response = await env.GMAIL.sendEmail({
        to: inputData.to,
        subject: inputData.subject,
        body: inputData.body,
      });
      return { success: response.sent }; // assume the integration returns a 'sent' flag
    },
  }); 
```

## Tool Patterns

### External API Calls

```typescript
const createWeatherTool = (env: Env) =>
  createTool({
    id: "GET_WEATHER",
    description: "Get current weather for a city",
    inputSchema: z.object({
      city: z.string(),
    }),
    outputSchema: z.object({
      temperature: z.number(),
      condition: z.string(),
    }),
    execute: async ({ inputData }) => {
      const response = await fetch(
        `https://api.openweathermap.org/data/2.5/weather?q=${inputData.city}&appid=${env.API_KEY}`
      );
      const data = await response.json();
      return {
        temperature: data.main.temp,
        condition: data.weather[0].description,
      };
    },
  });
```

### Using Integrations

For external services, use the integrations available in your `env`:

```typescript
const createEmailTool = (env: Env) =>
  createTool({
    id: "SEND_EMAIL",
    description: "Send an email",
    inputSchema: z.object({
      to: z.string().email(),
      subject: z.string(),
      body: z.string(),
    }),
    outputSchema: z.object({ success: z.boolean() }),
    execute: async ({ inputData }) => {
      await env.gmail.sendEmail(inputData);
      return { success: true };
    },
  });
```

See the [Integrations guide](/guides/integrations) for details on adding external services.

## Database Operations

Every workspace includes a built-in SQLite database:

```typescript
const createCustomerInsertTool = (env: Env) =>
  createTool({
    id: "CUSTOMER_INSERT",
    description: "Save a new customer to the database",
    inputSchema: z.object({
      name: z.string(),
      cpf: z.string(),
      city: z.string(),
      state: z.string(),
    }),
    outputSchema: z.object({ id: z.number() }),
    execute: async ({ inputData, context }) => {
      const result = await context.runtime.workspace.db.run(
        "INSERT INTO customers (name, cpf, city, state) VALUES (?, ?, ?, ?) RETURNING id",
        [inputData.name, inputData.cpf, inputData.city, inputData.state]
      );
      return { id: result.meta.last_row_id };
    },
  });
```

<Callout type="info">
  Each workspace gets an isolated SQLite database. No need to manage database URLs or credentials.
</Callout>

## Register Your Tools

Add tools to your MCP server in `server/main.ts`:

```typescript
import { withRuntime } from "@deco/workers-runtime";

const { Workflow, ...runtime } = withRuntime<Env>({
  tools: [
    createCepSearchTool,
    createSendEmailTool,
    createCustomerInsertTool,
  ],
  workflows: [/* your workflows */],
  fetch: fallbackToView("/"),
});

export { Workflow };
export default runtime;
```

## Test Your Tools

1. Start your dev server: `npm run dev`
2. Copy the preview URL
3. Add as custom integration in deco.chat (URL + `/mcp`)
4. Test tools in the interface

<Callout type="success">
  Tools appear automatically when you add the integration. No manual registration needed!
</Callout>

## Best Practices

### Keep It Simple
Each tool should do one thing and do it well (one API call, one database query, one computation). This makes tools easy to reuse and test.

### Use Type Safety
The generated types in `deco.gen.ts` provide autocompletion for integrations. Utilize type definitions to catch potential API integration errors, ensuring compile-time validation of tool parameters.

## Testing
Testing tools individually is effective. Call `await createMyTool(env).execute({ inputData: {...}, context })` in a dev script to verify tool behavior, using a dummy environment if needed.

### Validate Everything
Validate inputs and outputs with Zod schemas to prevent runtime errors and provide clear error messages.
