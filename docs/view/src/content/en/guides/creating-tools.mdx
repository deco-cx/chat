---
title: Creating Tools
description: Learn how to create tools in Deco
icon: Wrench
---

import Callout from "../../../components/ui/Callout.astro";

Tools are discrete functions that agents can call to perform specific actions like API calls, database queries, or computations. Each tool is essentially a function with a defined input and output.

## Basic Tool Structure

Every tool needs:

- **`ID`**: Unique identifier
- **`Description`**: What the tool does (helps AI decide when to use it)
- **`inputSchema` and `outputSchema`**: Zod schemas to ensure that the data coming in and out is validated and typed
- **`execute`**: The actual logic. You can use `context` to access the parsed input properties.


## Example

This example shows a tool that sends an email via Gmail.

```typescript
 const createSendEmailTool = (env: Env) =>
  createTool({
    id: "SEND_EMAIL",
    description: "Send an email via Gmail",
    inputSchema: z.object({
      to: z.string().email(),
      subject: z.string(),
      body: z.string(),
    }),
    outputSchema: z.object({ success: z.boolean() }),
    execute: async ({ context }) => {
      const response = await env.GMAIL.sendEmail({
        to: context.to,
        subject: context.subject,
        body: context.body,
      });
      return { success: response.sent }; // assume the integration returns a 'sent' flag
    },
  }); 
```

## Tool Patterns

### External API Calls

```typescript
const createWeatherTool = (env: Env) =>
  createTool({
    id: "GET_WEATHER",
    description: "Get current weather for a city",
    inputSchema: z.object({
      city: z.string(),
    }),
    outputSchema: z.object({
      temperature: z.number(),
      condition: z.string(),
    }),
    execute: async ({ context }) => {
      const response = await fetch(
        `https://api.openweathermap.org/data/2.5/weather?q=${context.city}&appid=${env.API_KEY}`
      );
      const data = await response.json();
      return {
        temperature: data.main.temp,
        condition: data.weather[0].description,
      };
    },
  });
```

### Using Integrations

For external services, use the integrations available in your `env`:

```typescript
const createEmailTool = (env: Env) =>
  createTool({
    id: "SEND_EMAIL",
    description: "Send an email",
    inputSchema: z.object({
      to: z.string().email(),
      subject: z.string(),
      body: z.string(),
    }),
    outputSchema: z.object({ success: z.boolean() }),
    execute: async ({ context }) => {
      await env.GMAIL.SEND_EMAIL(context);
      return { success: true };
    },
  });
```

See the [Integrations guide](/guides/integrations) for details on adding external services.

## Database Operations

Every workspace includes a built-in SQLite database, with Drizzle ORM being configured by default:

```typescript
const createCustomerInsertTool = (env: Env) =>
  createTool({
    id: "CUSTOMER_INSERT",
    description: "Save a new customer to the database",
    inputSchema: z.object({
      name: z.string(),
      cpf: z.string(),
      city: z.string(),
      state: z.string(),
    }),
    outputSchema: z.object({ id: z.number() }),
    execute: async ({ context }) => {
      const db = await getDb(env);
      const result = await db
        .insert({
          name: customersTable.name,
          cpf: customersTable.cpf,
          city: customersTable.city,
          state: customersTable.state,
        })
        .into(customersTable)
        .returning({
          id: customersTable.id
        });

      return { id: result[0].id };
    },
  });
```

<Callout type="info">
  Each project gets an isolated SQLite database. No need to manage database URLs or credentials.
</Callout>

## Register Your Tools

Add tools to your MCP server in `server/main.ts`:

```typescript
import { withRuntime } from "@deco/workers-runtime";

const { Workflow, ...runtime } = withRuntime<Env>({
  tools: [
    createCepSearchTool,
    createSendEmailTool,
    createCustomerInsertTool,
  ],
  workflows: [/* your workflows */],
  fetch: fallbackToView("/"),
});

export { Workflow };
export default runtime;
```

## Test Your Tools

1. Start your dev server: `npm run dev`
2. Copy the preview URL
3. Add as custom integration in deco CMS (URL + `/mcp`)
4. Test tools in the interface

<Callout type="success">
  Tools appear automatically when you add the integration. No manual registration needed!
</Callout>

## Best Practices

### Keep It Simple
Each tool should do one thing and do it well (one API call, one database query, one computation). This makes tools easy to reuse and test.

### Use Type Safety
The generated types in `deco.gen.ts` provide autocompletion for integrations. Utilize type definitions to catch potential API integration errors, ensuring compile-time validation of tool parameters.

### Validate Everything
Validate inputs and outputs with Zod schemas to prevent runtime errors and provide clear error messages.