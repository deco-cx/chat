---
title: Criando Tools
description: Aprenda como criar tools no deco.chat
icon: Wrench
---

import Callout from "../../../components/ui/Callout.astro";

Tools são funções discretas que agentes podem chamar para realizar ações específicas como chamadas de API, consultas de banco de dados ou computações. Cada tool é essencialmente uma função com entrada e saída definidas.

## Estrutura Básica de Tool

Toda tool precisa de:

- **`ID`**: Identificador único
- **`Description`**: O que a tool faz (ajuda a IA decidir quando usá-la)
- **`inputSchema` e `outputSchema`**: Schemas Zod para garantir que os dados de entrada e saída sejam validados e tipados
- **`execute`**: A lógica real. Pode usar `context` que fornece acesso aos dados de ambiente e step, enquanto `inputData` oferece um método de entrada mais simples e parseado.


## Exemplo

Este exemplo mostra uma tool que envia um email via Gmail.

```typescript
 const createSendEmailTool = (env: Env) =>
  createTool({
    id: "SEND_EMAIL",
    description: "Send an email via Gmail",
    inputSchema: z.object({
      to: z.string().email(),
      subject: z.string(),
      body: z.string(),
    }),
    outputSchema: z.object({ success: z.boolean() }),
    execute: async ({ inputData }) => {
      const response = await env.GMAIL.sendEmail({
        to: inputData.to,
        subject: inputData.subject,
        body: inputData.body,
      });
      return { success: response.sent }; // assume the integration returns a 'sent' flag
    },
  }); 
```

## Padrões de Tools

### Chamadas de API Externa

```typescript
const createWeatherTool = (env: Env) =>
  createTool({
    id: "GET_WEATHER",
    description: "Get current weather for a city",
    inputSchema: z.object({
      city: z.string(),
    }),
    outputSchema: z.object({
      temperature: z.number(),
      condition: z.string(),
    }),
    execute: async ({ inputData }) => {
      const response = await fetch(
        `https://api.openweathermap.org/data/2.5/weather?q=${inputData.city}&appid=${env.API_KEY}`
      );
      const data = await response.json();
      return {
        temperature: data.main.temp,
        condition: data.weather[0].description,
      };
    },
  });
```

### Usando Integrações

Para serviços externos, use as integrações disponíveis no seu `env`:

```typescript
const createEmailTool = (env: Env) =>
  createTool({
    id: "SEND_EMAIL",
    description: "Send an email",
    inputSchema: z.object({
      to: z.string().email(),
      subject: z.string(),
      body: z.string(),
    }),
    outputSchema: z.object({ success: z.boolean() }),
    execute: async ({ inputData }) => {
      await env.gmail.sendEmail(inputData);
      return { success: true };
    },
  });
```

Veja o [guia de Integrações](/guides/integrations) para detalhes sobre como adicionar serviços externos.

## Operações de Banco de Dados

Todo workspace inclui um banco de dados SQLite integrado:

```typescript
const createCustomerInsertTool = (env: Env) =>
  createTool({
    id: "CUSTOMER_INSERT",
    description: "Save a new customer to the database",
    inputSchema: z.object({
      name: z.string(),
      cpf: z.string(),
      city: z.string(),
      state: z.string(),
    }),
    outputSchema: z.object({ id: z.number() }),
    execute: async ({ inputData, context }) => {
      const result = await context.runtime.workspace.db.run(
        "INSERT INTO customers (name, cpf, city, state) VALUES (?, ?, ?, ?) RETURNING id",
        [inputData.name, inputData.cpf, inputData.city, inputData.state]
      );
      return { id: result.meta.last_row_id };
    },
  });
```

<Callout type="info">
  Cada workspace recebe um banco de dados SQLite isolado. Não é necessário gerenciar URLs ou credenciais do banco.
</Callout>

## Registrar Suas Tools

Adicione tools ao seu servidor MCP em `server/main.ts`:

```typescript
import { withRuntime } from "@deco/workers-runtime";

const { Workflow, ...runtime } = withRuntime<Env>({
  tools: [
    createCepSearchTool,
    createSendEmailTool,
    createCustomerInsertTool,
  ],
  workflows: [/* your workflows */],
  fetch: fallbackToView("/"),
});

export { Workflow };
export default runtime;
```

## Testar Suas Tools

1. Inicie seu servidor de dev: `npm run dev`
2. Copie a URL de preview
3. Adicione como integração customizada no deco.chat (URL + `/mcp`)
4. Teste as tools na interface

<Callout type="success">
  Tools aparecem automaticamente quando você adiciona a integração. Não é necessário registro manual!
</Callout>

## Melhores Práticas

### Mantenha Simples
Cada tool deve fazer uma coisa e fazê-la bem (uma chamada de API, uma consulta de banco, uma computação). Isso torna as tools fáceis de reutilizar e testar.

### Use Segurança de Tipos
Os tipos gerados em `deco.gen.ts` fornecem autocompletar para integrações. Utilize definições de tipos para capturar erros potenciais de integração de API, garantindo validação em tempo de compilação dos parâmetros da tool.

## Testando
Testar tools individualmente é eficaz. Chame `await createMyTool(env).execute({ inputData: {...}, context })` em um script de dev para verificar o comportamento da tool, usando um ambiente fictício se necessário.

### Valide Tudo
Valide entradas e saídas com schemas Zod para prevenir erros de runtime e fornecer mensagens de erro claras.
