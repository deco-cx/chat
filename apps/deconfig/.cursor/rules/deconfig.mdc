---
description: 
globs: 
alwaysApply: true
---
This project is **DECONFIG**, a git-like, versioned configuration manager filesystem built on top of **Cloudflare Durable Objects**.

### System Overview

* A single DECONFIG project contains many **namespaces**.
* Namespace operations (`create`, `delete`, `clone`, `branch`, `merge`) are **O(1)**.
* Peers use namespaces as a **FileSystem-like API with steroids**.
* Peers can **WATCH files** for real-time changes via Server-Sent Events (SSE).
* **Path prefixing** enables multiple peers to work on different virtual directories within the same namespace.

### Core Components

1. **Blobs Durable Object** (Content Addressable Storage)

   * Each project owns a Blobs DO (`blobs:blob-1` addressing).
   * Functions as **content-addressable storage (CAS)** using SHA-256 hashing.
   * Stores blobs keyed by hash with **BlobInfo** metadata (hash + size).
   * Supports both **ReadableStream** and **ArrayBuffer** for efficient data transfer.
   * **Batch operations** with `putBatch()` for parallel processing.
   * Scales to virtually infinite storage using `DurableObjectStorage` SQLite.

2. **Namespace Durable Object** (Versioned File Trees)

   * Each Namespace DO maintains its state in **SQLite** with two tables:
     - `namespace_state`: Current tree state and metadata
     - `patches`: Historical changes (delta-based storage)
   * Stores **Tree** as `Record<FilePath, FileMetadata>`.
   * `FileMetadata` includes:
     - `address`: Blob address (`blobs:blob-1:$HASH`)
     - `metadata`: User-defined key/value data
     - `mtime`: Modification time (content changes)
     - `ctime`: Change time (content or metadata changes)
   * **Patch-based history**: Only stores deltas, not full trees (O(1) updates).
   * The Namespace DO caches the **current tree in memory** for O(1) lookups.
   * **RPC-based communication** with typed interfaces for tool integration.

3. **Namespace Creation & Branching**

   * **NamespaceConfig interface** for clean initialization:
     ```typescript
     interface NamespaceConfig {
       projectId: string;
       namespaceName?: string;
       initialTree?: Tree;
       origin?: string | null;
       pathPrefix?: string;
     }
     ```
   * Namespaces are branched by copying the **in-memory tree** as `initialTree`.
   * **O(1) branching** regardless of tree size.

4. **Merging** (Implemented)

   * **Composition pattern**: `merge(A) = diff(A) + transactionalWrite(A, diff)`
   * Configurable merge strategies:
     - `OVERRIDE`: Always use remote version
     - `LAST_WRITE_WINS`: mtime-based conflict resolution with conflict tracking
   * **Conflict detection**: Reports which files had conflicts and resolution chosen.
   * **Atomic operations**: Single patch application for entire merge.

### Advanced Features

1. **Transactional Writes**
   
   * **Batch blob uploads** followed by atomic condition checking.
   * **Force mode**: LAST_WRITE_WINS behavior without throwing errors.
   * **Internal method reuse**: `internalTransactionalWrite()` powers both standalone and merge operations.

2. **Real-time Watching**

   * **Server-Sent Events (SSE)** via ReadableStream.
   * **Historical replay**: `fromCtime` for catching up on missed changes.
   * **Path filtering**: Watch specific file patterns.
   * **Efficient notifications**: Only active watchers receive updates.

3. **Diff Operations**

   * **Cross-namespace diffing**: Compare trees between any two namespaces.
   * **Delta computation**: Returns only differences (add/modify/delete).
   * **Prefix-aware**: Works with path prefixes for scoped operations.

4. **Path Prefixing**

   * **Instance-specific prefixes**: Multiple `NamespaceRpc` instances can use different prefixes on the same namespace.
   * **Virtual directories**: `/src/`, `/docs/`, etc. for modular access.
   * **Automatic filtering**: All operations respect prefix boundaries.

### Architecture Patterns

1. **RPC Target Pattern**
   
   * `NamespaceRpc` carries context (projectId, pathPrefix) without polluting method signatures.
   * Clean API surface with automatic prefix handling.

2. **Modular Composition**

   * `merge()` reuses `diff()` + `transactionalWrite()`
   * `transactionalWrite()` has internal method for different scenarios
   * Code reuse and consistency across operations

3. **Type Safety**

   * Full TypeScript interfaces for all data structures
   * Generated RPC types for tool integration
   * Zod schema validation where needed

### API Surface

Peers interact with DECONFIG namespaces through the following operations:

**Namespace Management:**
* `new(config: NamespaceConfig)` → Initialize namespace with clean config object
* `branch(namespaceName)` → O(1) namespace duplication with lineage tracking
* `merge(sourceNamespace, strategy)` → Merge trees with conflict resolution

**File Operations:**
* `writeFile(path, content, userMetadata?)` → Write file to CAS and update tree
* `getFile(path)` → Get file content stream + metadata
* `getFileMetadata(path)` → Get only metadata without content
* `deleteFile(path)` → Remove file from tree
* `listFiles()` / `listFilesByPrefix(prefix)` → Directory-style listing

**Advanced Operations:**
* `transactionalWrite(input, force?)` → Atomic multi-file operations with conditions
* `diff(otherNamespaceId)` → Compare trees and get differences
* `watch(options?)` → Real-time SSE notifications with filtering

**Query Operations:**
* `hasFile(path)` → Check file existence
* `getProjectId()` / `getNamespaceName()` → Metadata access

### Implementation Details

**Storage Schema:**
```sql
-- Namespace state (single row)
CREATE TABLE namespace_state (
  id INTEGER PRIMARY KEY,
  state TEXT -- JSON: NamespaceState
);

-- Historical patches (append-only)
CREATE TABLE patches (
  id INTEGER PRIMARY KEY,
  timestamp INTEGER,
  patch TEXT -- JSON: TreePatch
);

-- Blobs storage  
CREATE TABLE blobs (
  hash TEXT PRIMARY KEY,
  content BLOB
);
```

**Data Structures:**
```typescript
interface FileMetadata {
  address: BlobAddress;     // "blobs:blob-1:$HASH"
  metadata: Record<string, any>;
  sizeInBytes: number;      // Size of file content in bytes
  mtime: number;           // Content modification time
  ctime: number;           // Change time (content + metadata)
}

interface TreePatch {
  id: number;
  timestamp: number;
  added: Record<FilePath, FileMetadata>;
  deleted: FilePath[];
  metadata?: Record<string, any>;
}
```

### Performance Characteristics

* **Namespace operations**: O(1) - branch, clone, initialization
* **File operations**: O(1) - read, write, delete (hash table lookups)
* **Tree updates**: O(1) - patch-based storage regardless of tree size
* **Merge operations**: O(n) where n = number of differing files
* **Watch notifications**: O(k) where k = number of active watchers
* **Storage growth**: O(changes) not O(tree_size × changes)

### Requirements Met

* ✅ TypeScript Durable Object classes: `Blobs`, `Namespace`
* ✅ SQLite schema for tree storage and patch history
* ✅ Efficient diffing and patch-based history compaction
* ✅ Scalable publish/subscribe mechanism with SSE
* ✅ RPC-based tool integration with type safety
* ✅ Path prefixing for multi-tenant namespace usage
* ✅ Atomic transactional operations with conflict resolution
* ✅ Real-time change notifications with historical replay
