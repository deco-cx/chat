<!-- Generated by SpecStory -->

# Create tool for current date display (2025-07-04 00:27Z)

_**User (2025-07-03 07:22Z)**_

create a new tool to return current date and call it on the agent list screen

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user wants me to create a
new tool to return the current date and call it on the agent list screen. Based
on the project structure, this appears to be a deco.chat Agent Builder
application with integrations and tools.

From the project structure, I can see:

- This is a monorepo with packages and apps
- There's an AI package in `/packages/ai/` that handles agent-related
  functionality
- There's a web app in `/apps/web/` with React components
- The agent list appears to be in `/apps/web/src/components/agents/list.tsx`

To create a tool, I need to:

1. First understand how tools are currently structured in this codebase
2. Create a new tool that returns the current date
3. Integrate it into the agent list screen

Let me start by exploring the current tool structure and the agent list
implementation.</details></think>

---

I'll help you create a new tool to return the current date and integrate it into
the agent list screen. Let me first explore the current codebase structure to
understand how tools are implemented and how the agent list works.

---

<details>
                <summary>Searched codebase "How are tools created and structured in the AI package?" • **25** results</summary>

| File                                   | Lines    |
| -------------------------------------- | -------- |
| `packages/ai/src/storage/tools.ts`     | L1-7     |
| `packages/ai/src/types.ts`             | L13-27   |
| `packages/ai/src/tools.ts`             | L854-865 |
| `packages/ai/src/tools.ts`             | L1-12    |
| `packages/ai/src/storage/tools.ts`     | L7-34    |
| `packages/ai/src/storage/constants.ts` | L1-5     |
| `packages/ai/src/agent.ts`             | L858-864 |
| `packages/ai/src/types.ts`             | L49-116  |
| `packages/ai/src/agent.ts`             | L891-921 |
| `packages/ai/src/agent.ts`             | L330-379 |
| `packages/ai/src/agent.ts`             | L295-330 |
| `packages/ai/src/agent.ts`             | L379-396 |
| `packages/ai/src/utils/create-tool.ts` | L1-22    |
| `packages/ai/src/agent.ts`             | L287-295 |
| `packages/ai/src/utils/create-tool.ts` | L22-31   |
| `packages/ai/src/agent.ts`             | L842-858 |
| `packages/ai/src/deco.ts`              | L183-218 |
| `packages/ai/src/agent.ts`             | L537-558 |
| `packages/ai/src/tools.ts`             | L552-565 |
| `packages/ai/src/deco.ts`              | L123-183 |
| `packages/ai/src/tools.ts`             | L489-520 |
| `packages/ai/src/agent.ts`             | L813-842 |
| `packages/ai/src/mcp.ts`               | L134-187 |
| `packages/ai/src/agents/handoff.ts`    | L1-11    |
| `packages/ai/src/tools.ts`             | L382-404 |

</details>

---

Read file: apps/web/src/components/agents/list.tsx

---

<details>
                <summary>Searched codebase "Where are tools defined and how are they registered?" • **25** results</summary>

| File                                       | Lines    |
| ------------------------------------------ | -------- |
| `packages/sdk/src/mcp/index.ts`            | L14-59   |
| `packages/ai/src/storage/tools.ts`         | L1-7     |
| `packages/sdk/src/hooks/tools.ts`          | L19-29   |
| `packages/sdk/src/mcp/index.ts`            | L229-263 |
| `packages/sdk/src/mcp/index.ts`            | L59-126  |
| `apps/api/src/api.ts`                      | L131-176 |
| `packages/ai/src/tools.ts`                 | L1-12    |
| `packages/sdk/src/hooks/tools.ts`          | L1-9     |
| `packages/ai/src/tools.ts`                 | L854-865 |
| `packages/ai/src/storage/tools.ts`         | L7-34    |
| `packages/sdk/src/mcp/integrations/api.ts` | L126-149 |
| `.cursor/rules/data-flow.mdc`              | L1-63    |
| `packages/ai/src/storage/constants.ts`     | L1-5     |
| `apps/api/src/api.ts`                      | L72-131  |
| `packages/ai/src/mcp.ts`                   | L134-187 |
| `apps/web/src/hooks/use-tools.ts`          | L1-11    |
| `packages/ai/src/deco.ts`                  | L123-183 |
| `packages/ai/src/deco.ts`                  | L183-218 |
| `packages/ai/src/agent.ts`                 | L330-379 |
| `packages/sdk/src/mcp/stub.ts`             | L24-31   |
| `packages/sdk/src/hooks/tools.ts`          | L29-37   |
| `packages/runtime/src/mastra.ts`           | L172-177 |
| `packages/ai/src/types.ts`                 | L13-27   |
| `packages/ai/src/mcp.ts`                   | L307-356 |
| `packages/runtime/src/mastra.ts`           | L189-247 |

</details>

---

<think><details><summary>Thought Process</summary>Great! Now I have a better
understanding of how this system works. Let me analyze what I found:

1. **Tool Structure**: Tools are created using `createInnateTool` from
   `packages/ai/src/utils/create-tool.ts`
2. **Tool Registration**: Tools are registered in
   `packages/ai/src/storage/constants.ts` in the `INNATE_TOOLS` object
3. **Existing Tools**: There are already several tools in
   `packages/ai/src/tools.ts` like `FETCH`, `WHO_AM_I`, `SPEAK`, etc.
4. **Agent List**: The agent list is in
   `apps/web/src/components/agents/list.tsx`

Let me first fetch the data-flow rule since it seems relevant to creating tools,
then look more closely at how tools are created and
integrated.</details></think>

---

### Rule: data-flow

**When working on anything related to dataflow, creating new tools, editing some
functionality that envolves backend and frontend. Mentions Tools, Authorization
and so on**

```markdown
# Data Flow Architecture

This document explains how data flows through the deco.chat system, covering the
API structure, client communication patterns, and authorization mechanisms.

## Overview

The system uses a **Model Context Protocol (MCP)** architecture where:

- **Backend**: Collection of MCP Servers exposing typed tools
- **Client**: Uses MCPClient to communicate with servers
- **Frontend**: Uses React Query for data fetching and caching
- **Security**: Role-based authorization controls tool access

## 1. MCP Server Architecture

### Server Structure

The API exposes multiple MCP servers at different endpoints:
```

/mcp → GLOBAL_TOOLS (teams, profiles, integrations) /:root/:slug/mcp →
WORKSPACE_TOOLS (agents, threads, models) /:root/:slug/agents/:id/mcp →
AGENT_TOOLS (agent-specific operations) /:root/:slug/email/mcp → EMAIL_TOOLS
(email operations)

````
### Tool Registration
MCP tools are registered with strict typing:

```typescript
// Tool Definition
interface Tool<TName, TInput, TReturn> {
  name: TName;
  description: string;
  inputSchema: z.ZodType<TInput>;      // Zod schema for input validation
  outputSchema?: z.ZodType<TReturn>;   // Zod schema for output validation
  handler: (props: TInput, context: AppContext) => Promise<TReturn>;
}

// Server Registration
server.registerTool(tool.name, {
  description: tool.description,
  inputSchema: tool.inputSchema.shape,
  outputSchema: tool.outputSchema?.shape,
}, tool.handler);
````

### Tool Collections

Tools are organized into typed collections:

```typescript
// Global tools (no workspace required)
export const GLOBAL_TOOLS = [
  teamsAPI.createTeam,
  profilesAPI.getProfile,
  integrationsAPI.listTools,
  // ...
] as const;

// Workspace tools (workspace-scoped)
export const WORKSPACE_TOOLS = [
  agentsAPI.createAgent,
  threadsAPI.getThread,
  modelsAPI.listModels,
  // ...
] as const;
```

## 2. Client Communication (MCPClient)

### MCPClient Structure

The client provides type-safe access to MCP tools:

```typescript
// Client factory methods
const MCPClient = {
  // Global tools
  PROFILES_GET: (params: GetProfileInput) => Promise<Profile>,
  TEAMS_CREATE: (params: CreateTeamInput) => Promise<Team>,

  // Workspace-scoped tools
  forWorkspace: (workspace: string) => ({
    AGENTS_CREATE: (params: CreateAgentInput) => Promise<Agent>,
    THREADS_LIST: (params: ListThreadsInput) => Promise<ThreadList>,
    // ...
  }),

  // Connection-specific tools
  forConnection: (connection: MCPConnection) => ({
    // Dynamic tools based on connection
  }),
};
```

### HTTP Communication

MCPClient translates tool calls to HTTP requests:

```typescript
// Tool call: MCPClient.AGENTS_CREATE(params)
// Becomes HTTP request:
POST /users/john/mcp/tools/call/AGENTS_CREATE
{
  "body": { /* params */ },
  "headers": {
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
  }
}
```

### Connection Types

The system supports multiple MCP connection types:

```typescript
type MCPConnection =
  | { type: "HTTP"; url: string; token?: string }
  | { type: "SSE"; url: string; token?: string }
  | { type: "Websocket"; url: string }
  | { type: "Deco"; tenant: string; token?: string }
  | { type: "INNATE"; name: string; workspace?: string };
```

## 3. React Query Integration

### Query Keys Structure

Consistent query key patterns for caching:

```typescript
export const KEYS = {
  AGENT: (
    workspace: Workspace,
    agentId?: string,
  ) => ["agent", workspace, agentId],
  THREADS: (
    workspace: Workspace,
    options?: ThreadFilterOptions,
  ) => ["threads", workspace, options?.agentId, options?.resourceId],
  INTEGRATION_TOOLS: (
    workspace: Workspace,
    integrationId: string,
  ) => ["integration-tools", workspace, integrationId],
  // ...
};
```

### Hook Patterns

Standardized hooks for each resource:

```typescript
// Query hooks
export const useAgent = (agentId: string) => {
  const { workspace } = useSDK();
  return useSuspenseQuery({
    queryKey: KEYS.AGENT(workspace, agentId),
    queryFn: () => loadAgent(workspace, agentId),
  });
};

// Mutation hooks
export const useCreateAgent = () => {
  const { workspace } = useSDK();
  const client = useQueryClient();

  return useMutation({
    mutationFn: (agent: Partial<Agent>) => createAgent(workspace, agent),
    onSuccess: (result) => {
      // Update cache
      client.setQueryData(KEYS.AGENT(workspace, result.id), result);
      client.setQueryData(
        KEYS.AGENT(workspace),
        (old) => old ? [result, ...old] : [result],
      );
    },
  });
};
```

### Cache Management

React Query handles caching with optimistic updates:

```typescript
// Optimistic update pattern
const updateMutation = useMutation({
  mutationFn: updateAgent,
  onMutate: async (newAgent) => {
    // Cancel outgoing refetches
    await client.cancelQueries(KEYS.AGENT(workspace, newAgent.id));

    // Snapshot previous value
    const previousAgent = client.getQueryData(
      KEYS.AGENT(workspace, newAgent.id),
    );

    // Optimistically update
    client.setQueryData(KEYS.AGENT(workspace, newAgent.id), newAgent);

    return { previousAgent };
  },
  onError: (err, newAgent, context) => {
    // Rollback on error
    client.setQueryData(
      KEYS.AGENT(workspace, newAgent.id),
      context.previousAgent,
    );
  },
});
```

## 4. Authorization System

### Resource Access Control

Every MCP tool must explicitly grant access:

```typescript
// Tool handler pattern
handler: (async (props: TInput, context: AppContext) => {
  // 1. Perform authorization checks
  await assertWorkspaceResourceAccess(context.tool.name, context);

  // 2. Explicitly grant access (required!)
  context.resourceAccess.grant();

  // 3. Execute business logic
  const result = await businessLogic(props);

  return result;
});
```

### Authorization Hierarchy

The system checks authorization in order:

1. **Local Development**: Automatic access if `context.isLocal`
2. **API Keys**: Check policies attached to API key
3. **User Workspace**: Personal workspace access (`users/:userId`)
4. **Shared Workspace**: Team-based access with policies (`shared/:teamSlug`)

### Policy-Based Access

Authorization uses policy statements:

```typescript
interface Policy {
  statements: Array<{
    effect: "allow" | "deny";
    resource: string; // e.g., "AGENTS_CREATE", "THREADS_LIST"
  }>;
}

// Policy evaluation: deny overrides allow
const canAccess = await authorizationClient.canAccess(
  userId,
  workspace,
  "AGENTS_CREATE",
);
```

### API Key Authorization

API keys include embedded policies:

```typescript
// API key creation
const apiKey = await createApiKey({
  name: "My API Key",
  policies: [
    { effect: "allow", resource: "AGENTS_CREATE" },
    { effect: "allow", resource: "THREADS_LIST" },
    { effect: "deny", resource: "TEAMS_DELETE" },
  ],
});

// JWT token includes workspace and policies
const token = jwt.sign({
  sub: `api-key:${apiKey.id}`,
  aud: workspace,
  policies: apiKey.policies,
});
```

## 5. Integration Flow

### Complete Data Flow Example

Here's how a typical operation flows through the system:

```typescript
// 1. Frontend hook call
const createAgent = useCreateAgent();
await createAgent.mutateAsync({
  name: "My Agent",
  instructions: "You are a helpful assistant"
});

// 2. React Query mutation
mutationFn: (agent) => createAgent(workspace, agent)

// 3. MCPClient call
MCPClient.forWorkspace(workspace).AGENTS_CREATE(agent)

// 4. HTTP request
POST /users/john/mcp/tools/call/AGENTS_CREATE
Authorization: Bearer <jwt-token>

// 5. MCP server routing
app.all("/:root/:slug/mcp", createMCPHandlerFor(WORKSPACE_TOOLS))

// 6. Tool execution
const tool = WORKSPACE_TOOLS.find(t => t.name === "AGENTS_CREATE");
await tool.handler(agent, context);

// 7. Authorization check
await assertWorkspaceResourceAccess("AGENTS_CREATE", context);
context.resourceAccess.grant();

// 8. Database operation
const result = await db.from("agents").insert(agent);

// 9. Response & cache update
React Query updates cache and triggers re-renders
```

## 6. Best Practices

### Tool Development

- Always use Zod schemas for input/output validation
- Call `context.resourceAccess.grant()` after authorization checks
- Use descriptive tool names following the pattern `{RESOURCE}_{ACTION}`
- Group related tools by functionality

### Frontend Integration

- Use consistent query keys from `KEYS` object
- Implement optimistic updates for better UX
- Handle loading and error states appropriately
- Use `useSuspenseQuery` for critical data

### Authorization

- Always check workspace/team access before operations
- Use least-privilege principle for API keys
- Implement proper error handling for forbidden operations
- Log authorization failures for debugging

### Performance

- Cache frequently accessed data with appropriate TTL
- Use React Query's built-in deduplication
- Implement proper pagination for large datasets
- Use parallel queries where appropriate

This architecture ensures type safety, proper authorization, and efficient data
management throughout the application.

```
---

Read file: packages/ai/src/tools.ts

---

Read file: packages/ai/src/utils/create-tool.ts

---
```
