<!-- Generated by SpecStory -->

# Fill output schema for integration tools (2025-06-27 15:08Z)

_**User (2025-06-27 15:08Z)**_

Pleas, fill the output schema in these tools using the current method based on
this reference

12:12 Certainly! Focusing specifically on the tools available within this agent
related to integrations, here are the main query tools along with their output
schemas and descriptions:

1. integration_list Purpose: Lists all currently installed integrations in the
   agent. Output Schema:

content_copy [ { "id": "string", "name": "string", "description": "string",
"icon": "string (URL)", "connection": { "type": "string", "url": "string
(optional)", "name": "string (optional)" }, "access": "object or null" } ]
Notes: Returns an array of integration objects with connection details and
optional access credentials. 2. integration_get Purpose: Retrieves detailed
information about a specific integration by its ID. Input: Integration ID
(string) Output Schema:

content_copy { "id": "string", "name": "string", "description": "string",
"icon": "string (URL)", "connection": { "type": "string", "url": "string
(optional)", "name": "string (optional)" }, "access": "object or null" } Notes:
Returns a single integration object with full details. 3. integration_search
Purpose: Searches the integration marketplace for available integrations
matching a query. Input: Search query string Output Schema:

content_copy { "integrations": [ { "id": "string", "name": "string", "group":
"string", "description": "string", "icon": "string (URL)", "provider": "string"
} ] }

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user is asking me to add
output schemas to the integration tools based on the reference they provided.
Looking at the attached file, I can see several integration tools that don't
currently have `outputSchema` defined:

1. `listIntegrations` (INTEGRATIONS_LIST)
2. `getIntegration` (INTEGRATIONS_GET)
3. `DECO_INTEGRATIONS_SEARCH`

And some tools that already have output schemas:

- `DECO_INTEGRATION_INSTALL` already has outputSchema
- `DECO_INTEGRATION_OAUTH_START` doesn't have outputSchema but could use one

Let me look at the reference the user provided:

1. `integration_list` should return an array of integration objects
2. `integration_get` should return a single integration object
3. `integration_search` should return an object with `integrations` array

Looking at the current code:

1. `listIntegrations` returns an array of integrations directly
2. `getIntegration` returns a single integration object
3. `DECO_INTEGRATIONS_SEARCH` already has an outputSchema defined that matches
   the reference

I need to add outputSchemas to the tools that are missing them, using the
reference format the user provided.</details></think>

---

I'll add the output schemas to the integration tools based on your reference.
Let me update the file:

---

<details><summary>Edit file: packages/sdk/src/mcp/integrations/api.ts</summary>

undefined

**Chunk 1** Lines added: 12, lines removed: undefined

```diff
@@ -235,4 +235,16 @@
      binder: BindingsSchema.optional(),
    }),
+   outputSchema: z.array(z.object({
+     id: z.string(),
+     name: z.string(),
+     description: z.string(),
+     icon: z.string().describe("URL"),
+     connection: z.object({
+       type: z.string(),
+       url: z.string().optional(),
+       name: z.string().optional(),
+     }),
+     access: z.union([z.object({}), z.null()]).optional(),
+   })),
    handler: async ({ binder }, c) => {
      assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>The linter error is telling me
that the output schema I defined doesn't match what the handler function
actually returns. Let me look at what's returned and adjust the schema
accordingly.

Looking at the handler, it returns an array of objects that have been parsed
through `IntegrationSchema.safeParse`. The issue is that some fields like
`description` and `icon` can be `undefined`, but I'm requiring them in the
output schema.

I need to make the schema match what's actually being returned. Let me adjust it
to make optional fields optional.</details></think>

---

I need to fix the output schema to match what the handler actually returns. Let
me adjust it:

---

<details><summary>Edit file: packages/sdk/src/mcp/integrations/api.ts</summary>

undefined

**Chunk 1** Lines added: 12, lines removed: 8

```diff
@@ -238,12 +238,16 @@
      id: z.string(),
      name: z.string(),
-     description: z.string(),
-     icon: z.string().describe("URL"),
-     connection: z.object({
-       type: z.string(),
-       url: z.string().optional(),
-       name: z.string().optional(),
-     }),
-     access: z.union([z.object({}), z.null()]).optional(),
+     description: z.string().optional(),
+     icon: z.string().describe("URL").optional(),
+     connection: z.union([
+       z.object({ type: z.literal("HTTP"), url: z.string(), token: z.string().optional() }),
+       z.object({ type: z.literal("SSE"), url: z.string(), token: z.string().optional(), headers: z.record(z.string()).optional() }),
+       z.object({ type: z.literal("WebSocket"), url: z.string() }),
+       z.object({ type: z.literal("Stdio"), command: z.string(), args: z.array(z.string()).optional() }),
+       z.object({ type: z.string() }),
+     ]),
+     access: z.string().optional(),
+     workspace: z.string().optional(),
+     created_at: z.string().optional(),
    })),
    handler: async ({ binder }, c) => {
```

</details>

---

<think><details><summary>Thought Process</summary>The linter error is still
showing that the return type doesn't match the expected schema. It seems like
the tool creation function has some strict typing expectations that don't align
with what I'm trying to define.

Looking at the error more carefully, it seems like the
`createIntegrationManagementTool` function expects the handler to return
something that matches the outputSchema, but there's a mismatch in the expected
return type from the function signature.

Let me look at other tools in the file to see how they handle outputSchema. I
see that `DECO_INTEGRATIONS_SEARCH` already has an outputSchema defined. Let me
see if I can use that as a pattern.

Actually, let me try a simpler approach. Instead of trying to create a complex
schema that matches exactly what the handler returns, let me use the
`IntegrationSchema` directly since that's what's being
returned.</details></think>

---

Let me use the existing `IntegrationSchema` directly to avoid the type mismatch:

---

<details><summary>Edit file: packages/sdk/src/mcp/integrations/api.ts</summary>

undefined

**Chunk 1** Lines added: 1, lines removed: 16

```diff
@@ -235,20 +235,5 @@
      binder: BindingsSchema.optional(),
    }),
-   outputSchema: z.array(z.object({
-     id: z.string(),
-     name: z.string(),
-     description: z.string().optional(),
-     icon: z.string().describe("URL").optional(),
-     connection: z.union([
-       z.object({ type: z.literal("HTTP"), url: z.string(), token: z.string().optional() }),
-       z.object({ type: z.literal("SSE"), url: z.string(), token: z.string().optional(), headers: z.record(z.string()).optional() }),
-       z.object({ type: z.literal("WebSocket"), url: z.string() }),
-       z.object({ type: z.literal("Stdio"), command: z.string(), args: z.array(z.string()).optional() }),
-       z.object({ type: z.string() }),
-     ]),
-     access: z.string().optional(),
-     workspace: z.string().optional(),
-     created_at: z.string().optional(),
-   })),
+   outputSchema: z.array(IntegrationSchema),
    handler: async ({ binder }, c) => {
      assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>Good, that fixed the linter
error. Now let me add the output schema to the `getIntegration` tool as
well.</details></think>

---

Now let me add the output schema to the `getIntegration` tool:

---

<details><summary>Edit file: packages/sdk/src/mcp/integrations/api.ts</summary>

undefined

**Chunk 1** Lines added: 1, lines removed: undefined

```diff
@@ -341,4 +341,5 @@
      id: z.string(),
    }),
+   outputSchema: IntegrationSchema,
    handler: async ({ id }, c) => {
      // preserve the logic of the old canAccess
```

</details>

---

<think><details><summary>Thought Process</summary>Great! Now let me add output
schemas to a few more tools that don't have them. Let me check which other tools
could benefit from output schemas:

1. `DECO_INTEGRATION_OAUTH_START` - this returns a redirect URL
2. `COMPOSIO_INTEGRATION_OAUTH_START` - this also returns a redirect URL
3. `createIntegration` - this returns an Integration
4. `updateIntegration` - this returns an Integration
5. `deleteIntegration` - this returns a success object

Let me add these one by one.</details></think>

---

Let me add output schemas to the remaining tools. First, let's add one for
`DECO_INTEGRATION_OAUTH_START`:

---

<details><summary>Edit file: packages/sdk/src/mcp/integrations/api.ts</summary>

undefined

**Chunk 1** Lines added: 3, lines removed: undefined

```diff
@@ -611,4 +611,7 @@
      ),
    }),
+   outputSchema: z.object({
+     redirectUrl: z.string().describe("The URL to redirect the user to for OAuth authentication"),
+   }),
    handler: async ({ appName, returnUrl, installId }, c) => {
      assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>Now let me add output schema
for `COMPOSIO_INTEGRATION_OAUTH_START`:</details></think>

---

Now let's add the output schema for `COMPOSIO_INTEGRATION_OAUTH_START`:

---

<details><summary>Edit file: packages/sdk/src/mcp/integrations/api.ts</summary>

undefined

**Chunk 1** Lines added: 3, lines removed: undefined

```diff
@@ -667,4 +667,7 @@
        url: z.string().describe("The url of the Composio MCP server"),
      }),
+     outputSchema: z.object({
+       redirectUrl: z.string().nullable().describe("The URL to redirect the user to for OAuth authentication, or null if auto-connection is not possible"),
+     }),
      handler: async ({ url }, c) => {
        assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>Now let me add output schemas
for the CRUD operations:</details></think>

---

Now let's add output schemas for the CRUD operations. First,
`createIntegration`:

---

<details><summary>Edit file: packages/sdk/src/mcp/integrations/api.ts</summary>

undefined

**Chunk 1** Lines added: 1, lines removed: undefined

```diff
@@ -418,4 +418,5 @@
    description: "Create a new integration",
    inputSchema: IntegrationSchema.partial(),
+   outputSchema: IntegrationSchema,
    handler: async (integration, c) => {
      assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>Now let me add the output
schema for `updateIntegration`:</details></think>

---

Now let's add the output schema for `updateIntegration`:

---

<details><summary>Edit file: packages/sdk/src/mcp/integrations/api.ts</summary>

undefined

**Chunk 1** Lines added: 1, lines removed: undefined

```diff
@@ -451,4 +451,5 @@
      integration: IntegrationSchema,
    }),
+   outputSchema: IntegrationSchema,
    handler: async ({ id, integration }, c) => {
      assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>Finally, let me add the output
schema for `deleteIntegration`:</details></think>

---

Finally, let's add the output schema for `deleteIntegration`:

---

<details><summary>Edit file: packages/sdk/src/mcp/integrations/api.ts</summary>

undefined

**Chunk 1** Lines added: 3, lines removed: undefined

```diff
@@ -490,4 +490,7 @@
      id: z.string(),
    }),
+   outputSchema: z.object({
+     success: z.boolean().describe("Whether the deletion was successful"),
+   }),
    handler: async ({ id }, c) => {
      assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>Let me also add output schemas
for the `callTool` and `listTools` functions:</details></think>

---

Let me also add output schemas for the `callTool` and `listTools` functions:

---

<details><summary>Edit file: packages/sdk/src/mcp/integrations/api.ts</summary>

undefined

**Chunk 1** Lines added: 1, lines removed: undefined

```diff
@@ -80,4 +80,5 @@
      connection: true,
    }).merge(CallToolRequestSchema.pick({ params: true })),
+   outputSchema: CallToolResultSchema,
    handler: async ({ connection: reqConnection, params: toolCall }, c) => {
      c.resourceAccess.grant();
```

</details>

---

<think><details><summary>Thought Process</summary>Now let me add the output
schema for `listTools`:</details></think>

---

Now let's add the output schema for `listTools`:

---

<details><summary>Edit file: packages/sdk/src/mcp/integrations/api.ts</summary>

undefined

**Chunk 1** Lines added: 8, lines removed: undefined

```diff
@@ -133,4 +133,12 @@
      connection: true,
    }),
+   outputSchema: z.object({
+     tools: z.array(z.object({
+       name: z.string(),
+       description: z.string().optional(),
+       inputSchema: z.record(z.any()).optional(),
+     })).optional(),
+     error: z.string().optional(),
+   }),
    handler: async ({ connection }, c) => {
      c.resourceAccess.grant();
```

</details>

---

<think><details><summary>Thought Process</summary>Perfect! I've successfully
added output schemas to all the integration management tools in the file based
on the reference provided by the user. Here's a summary of what I've added:

1. `listIntegrations` (INTEGRATIONS_LIST) - returns an array of
   IntegrationSchema objects
2. `getIntegration` (INTEGRATIONS_GET) - returns a single IntegrationSchema
   object
3. `DECO_INTEGRATIONS_SEARCH` - already had an output schema that matches the
   reference
4. `callTool` (INTEGRATIONS_CALL_TOOL) - returns a CallToolResultSchema
5. `listTools` (INTEGRATIONS_LIST_TOOLS) - returns an object with tools array
   and optional error
6. `createIntegration` (INTEGRATIONS_CREATE) - returns an IntegrationSchema
   object
7. `updateIntegration` (INTEGRATIONS_UPDATE) - returns an IntegrationSchema
   object
8. `deleteIntegration` (INTEGRATIONS_DELETE) - returns a success object
9. `DECO_INTEGRATION_OAUTH_START` - returns an object with redirectUrl
10. `COMPOSIO_INTEGRATION_OAUTH_START` - returns an object with nullable
    redirectUrl
11. `DECO_INTEGRATION_INSTALL` - already had an output schema

All the tools now have proper output schemas that match the reference format
provided by the user, making the API more predictable and easier to
use.</details></think>

---

Perfect! I've successfully added output schemas to all the integration
management tools based on your reference. Here's a summary of what I've added:

## Tools with Output Schemas Added:

1. **`INTEGRATIONS_LIST`** - Returns an array of integration objects using
   `IntegrationSchema`
2. **`INTEGRATIONS_GET`** - Returns a single integration object using
   `IntegrationSchema`
3. **`INTEGRATIONS_CALL_TOOL`** - Returns tool call results using
   `CallToolResultSchema`
4. **`INTEGRATIONS_LIST_TOOLS`** - Returns an object with tools array and
   optional error field
5. **`INTEGRATIONS_CREATE`** - Returns the created integration using
   `IntegrationSchema`
6. **`INTEGRATIONS_UPDATE`** - Returns the updated integration using
   `IntegrationSchema`
7. **`INTEGRATIONS_DELETE`** - Returns a success boolean
8. **`DECO_INTEGRATION_OAUTH_START`** - Returns an object with redirectUrl
9. **`COMPOSIO_INTEGRATION_OAUTH_START`** - Returns an object with nullable
   redirectUrl

## Already Had Output Schemas:

- **`DECO_INTEGRATIONS_SEARCH`** - Already had the proper output schema matching
  your reference
- **`DECO_INTEGRATION_INSTALL`** - Already had an output schema with
  installationId

All tools now have proper output schemas that follow the pattern from your
reference, making the API more predictable and easier to consume. The schemas
use the existing `IntegrationSchema` where appropriate to maintain consistency
with the rest of the codebase.

---

_**User (2025-06-27 15:08Z)**_

Similar to this, now to the output schema for the agents API at @api.ts

1. AGENTS_LIST Output Schema:

content_copy { "type": "array", "items": { "type": "object", "properties": {
"id": {"type": "string"}, "name": {"type": "string"}, "avatar": {"type":
"string"}, "instructions": {"type": "string"}, "description": {"type":
"string"}, "tools_set": {"type": "object"}, "max_steps": {"type": "number"},
"max_tokens": {"type": "number"}, "model": {"type": "string"}, "memory": {
"type": "object", "properties": { "last_messages": {"type": "number"},
"semantic_recall": {"type": "boolean"}, "working_memory": { "type": "object",
"properties": { "enabled": {"type": "boolean"} } } } }, "views": {"type":
"array"}, "visibility": {"type": "string"}, "access": {"type": ["object",
"null"]} } } } 2. AGENTS_GET Output Schema:

content_copy { "type": "object", "properties": { "id": {"type": "string"},
"name": {"type": "string"}, "avatar": {"type": "string"}, "instructions":
{"type": "string"}, "description": {"type": "string"}, "tools_set": {"type":
"object"}, "max_steps": {"type": "number"}, "max_tokens": {"type": "number"},
"model": {"type": "string"}, "memory": { "type": "object", "properties": {
"last_messages": {"type": "number"}, "semantic_recall": {"type": "boolean"},
"working_memory": { "type": "object", "properties": { "enabled": {"type":
"boolean"} } } } }, "views": {"type": "array"}, "visibility": {"type":
"string"}, "access": {"type": ["object", "null"]} } } 3. AGENTS_CREATE Output
Schema:

content_copy { "type": "object", "properties": { "id": {"type": "string"},
"name": {"type": "string"}, "avatar": {"type": "string"}, "instructions":
{"type": "string"}, "description": {"type": "string"}, "tools_set": {"type":
"object"}, "max_steps": {"type": "number"}, "max_tokens": {"type": "number"},
"model": {"type": "string"}, "memory": { "type": "object", "properties": {
"last_messages": {"type": "number"}, "semantic_recall": {"type": "boolean"},
"working_memory": { "type": "object", "properties": { "enabled": {"type":
"boolean"} } } } }, "views": {"type": "array"}, "visibility": {"type":
"string"}, "access": {"type": ["object", "null"]} } } 4. AGENTS_DELETE Output
Schema:

content_copy { "type": "object", "properties": { "deleted": {"type": "boolean"}
} } Summary I successfully executed all the requested operations:

AGENTS_LIST: Retrieved a list of 4 existing agents AGENTS_GET: Retrieved
detailed information for a specific agent (WhatsApp Bro) AGENTS_CREATE: Created
a new test agent with ID a6564151-918c-4dff-8210-f6dc44149a03 AGENTS_DELETE:
Successfully deleted the test agent (returned {"deleted": true})

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user wants me to add
output schemas to the agents API tools, similar to what I just did for the
integrations API. They've provided the JSON schema format for each tool, but I
need to convert these to Zod schemas and add them to the appropriate tools.

Let me look at the tools in the agents API:

1. `listAgents` - AGENTS_LIST
2. `getAgent` - AGENTS_GET
3. `createAgent` - AGENTS_CREATE
4. `updateAgent` - AGENTS_UPDATE (not mentioned in the user's list but I should
   add it)
5. `deleteAgent` - AGENTS_DELETE

I can see that all of these tools should use the `AgentSchema` for their output,
except for `deleteAgent` which returns `{ deleted: true }`. For `listAgents`, it
should be an array of `AgentSchema`.

Let me add the output schemas one by one.</details></think>

---

I'll add the output schemas to the agents API tools based on your reference. Let
me update each tool:

---

<details><summary>Edit file: packages/sdk/src/mcp/agents/api.ts</summary>

undefined

**Chunk 1** Lines added: 1, lines removed: undefined

```diff
@@ -80,4 +80,5 @@
    description: "List all agents",
    inputSchema: z.object({}),
+   outputSchema: z.array(AgentSchema),
    handler: async (_, c: WithTool<AppContext>) => {
      assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>Good, that worked. Now let me
add the output schema for `getAgent`.</details></think>

---

<details><summary>Edit file: packages/sdk/src/mcp/agents/api.ts</summary>

undefined

**Chunk 1** Lines added: 1, lines removed: undefined

```diff
@@ -116,4 +116,5 @@
    description: "Get an agent by id",
    inputSchema: z.object({ id: z.string() }),
+   outputSchema: AgentSchema,
    handler: async ({ id }, c) => {
      assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>Great, now let me add the
output schema for `createAgent`.</details></think>

---

<details><summary>Edit file: packages/sdk/src/mcp/agents/api.ts</summary>

undefined

**Chunk 1** Lines added: 1, lines removed: undefined

```diff
@@ -159,4 +159,5 @@
    description: "Create a new agent",
    inputSchema: AgentSchema.partial(),
+   outputSchema: AgentSchema,
    handler: async (agent, c) => {
      assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>Now let me add the output
schema for `updateAgent`. This wasn't in the user's list, but it should also
return an `AgentSchema`.</details></think>

---

<details><summary>Edit file: packages/sdk/src/mcp/agents/api.ts</summary>

undefined

**Chunk 1** Lines added: 1, lines removed: undefined

```diff
@@ -201,4 +201,5 @@
      agent: AgentSchema.partial(),
    }),
+   outputSchema: AgentSchema,
    handler: async ({ id, agent }, c) => {
      assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>Finally, let me add the output
schema for `deleteAgent`. This returns `{ deleted: true }` according to the
user's reference.</details></think>

---

<details><summary>Edit file: packages/sdk/src/mcp/agents/api.ts</summary>

undefined

**Chunk 1** Lines added: 3, lines removed: undefined

```diff
@@ -230,4 +230,7 @@
    description: "Delete an agent by id",
    inputSchema: z.object({ id: z.string() }),
+   outputSchema: z.object({
+     deleted: z.boolean().describe("Whether the agent was successfully deleted"),
+   }),
    handler: async ({ id }, c) => {
      assertHasWorkspace(c);
```

</details>

---

<think><details><summary>Thought Process</summary>Perfect! I've successfully
added output schemas to all the agent management tools. Let me summarize what
I've done:

1. **AGENTS_LIST** - Added `z.array(AgentSchema)` to return an array of agents
2. **AGENTS_GET** - Added `AgentSchema` to return a single agent object
3. **AGENTS_CREATE** - Added `AgentSchema` to return the created agent
4. **AGENTS_UPDATE** - Added `AgentSchema` to return the updated agent
5. **AGENTS_DELETE** - Added a custom schema with `deleted: boolean` to match
   the handler's return value

All schemas properly use the existing `AgentSchema` where appropriate,
maintaining consistency with the codebase structure. The schemas match the JSON
schema format provided by the user but are properly implemented as Zod
schemas.</details></think>

---

Perfect! I've successfully added output schemas to all the agent management
tools based on your reference. Here's a summary of what I've added:

## Tools with Output Schemas Added:

1. **`AGENTS_LIST`** - Returns an array of agent objects using
   `z.array(AgentSchema)`
2. **`AGENTS_GET`** - Returns a single agent object using `AgentSchema`
3. **`AGENTS_CREATE`** - Returns the created agent using `AgentSchema`
4. **`AGENTS_UPDATE`** - Returns the updated agent using `AgentSchema`
5. **`AGENTS_DELETE`** - Returns an object with `deleted: boolean` field

## Schema Details:

- **List, Get, Create, Update** operations all use the existing `AgentSchema`
  which includes all the properties you specified:
  - `id`, `name`, `avatar`, `instructions`, `description`
  - `tools_set`, `max_steps`, `max_tokens`, `model`
  - `memory` object with `last_messages`, `semantic_recall`, and
    `working_memory`
  - `views`, `visibility`, `access`

- **Delete** operation uses a custom schema that returns `{ deleted: boolean }`
  to match the handler's actual return value

All the output schemas now properly reflect what each tool returns, making the
API more predictable and easier to consume. The schemas leverage the existing
`AgentSchema` to maintain consistency across the codebase while providing clear
documentation of what each endpoint returns.

---
