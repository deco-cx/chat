<!-- Generated by SpecStory -->

# Replicating MCP tool behavior in deco app (2025-08-06 00:26Z)

_**User (2025-08-06 00:25Z)**_

I want you to deeply reflect about the feature that @connection-detail.tsx is
part of. The debugging of the MCPs, specially:

The tool calls to

- How to get all the integrations
- How to get instances/accounts
- How to get the integration tools (input, output schema)
- How to run the tool

I want to replicate this behavior into a deco app, that has access to all tool
calls we have here

i want to produce a prompts/mcp-inspector.md with all the information necessary,
got from this project, to unlock that construction there (an AI will do it)

---

_**Assistant**_

I'll analyze the connection detail feature to understand the MCP debugging
functionality and create a comprehensive prompt for replicating it in a deco
app.

---

<details>
                <summary>Searched codebase "How to get all integrations and grouped apps from the API" • **15** results</summary>

| File                                           | Lines         |
| ---------------------------------------------- | ------------- |
| `apps/web/src/components/integrations/apps.ts` | L184-259      |
| `apps/web/src/components/integrations/apps.ts` | L187-316      |
| `apps/web/src/components/integrations/apps.ts` | Lundefined-38 |
| `packages/sdk/src/mcp/integrations/api.ts`     | L178-345      |
| `packages/sdk/src/mcp/integrations/api.ts`     | L153-259      |
| `packages/sdk/src/mcp/integrations/api.ts`     | Lundefined-70 |
| `apps/web/src/components/integrations/apps.ts` | L87-178       |
| `packages/sdk/src/hooks/mcp.ts`                | L137-281      |
| `packages/sdk/src/mcp/integrations/api.ts`     | L259-354      |
| `apps/web/src/components/integrations/apps.ts` | L185-316      |
| `packages/sdk/src/mcp/integrations/api.ts`     | L176-345      |
| `packages/sdk/src/mcp/index.ts`                | L38-169       |
| `packages/sdk/src/mcp/integrations/api.ts`     | L589-722      |
| `packages/sdk/src/mcp/integrations/api.ts`     | L42-77        |
| `apps/web/src/components/apps/auth.tsx`        | L32-71        |

</details>

---

<details>
                <summary>Searched codebase "How to get integration instances and connection details" • **15** results</summary>

| File                                                         | Lines         |
| ------------------------------------------------------------ | ------------- |
| `apps/web/src/components/integrations/apps.ts`               | L187-316      |
| `apps/web/src/components/integrations/connection-detail.tsx` | L1240-1343    |
| `apps/web/src/components/integrations/connection-detail.tsx` | L478-671      |
| `packages/sdk/src/mcp/integrations/api.ts`                   | L347-451      |
| `packages/sdk/src/mcp/integrations/api.ts`                   | L178-345      |
| `apps/web/src/components/integrations/connection-detail.tsx` | L476-595      |
| `packages/sdk/src/hooks/mcp.ts`                              | L137-281      |
| `packages/runtime/src/connection.ts`                         | L31-51        |
| `apps/web/src/components/integrations/apps.ts`               | L184-259      |
| `apps/web/src/components/integrations/connection-detail.tsx` | L173-572      |
| `apps/web/src/components/integrations/apps.ts`               | Lundefined-38 |
| `packages/cli/src/lib/prompt-integrations.ts`                | L37-116       |
| `packages/cli/src/commands/gen/gen.ts`                       | L161-380      |
| `apps/web/src/components/integrations/connection-detail.tsx` | L732-1012     |
| `apps/web/src/components/integrations/connection-detail.tsx` | L1262-1343    |

</details>

---

<details>
                <summary>Searched codebase "How to get tools from MCP connection and their schemas" • **15** results</summary>

| File                                   | Lines         |
| -------------------------------------- | ------------- |
| `packages/ai/src/mcp.ts`               | L58-143       |
| `packages/ai/src/mcp.ts`               | L309-382      |
| `packages/runtime/src/mcp.ts`          | L32-113       |
| `packages/runtime/src/proxy.ts`        | L96-228       |
| `packages/ai/src/mcp.ts`               | L136-227      |
| `packages/ai/src/mcp.ts`               | L145-249      |
| `apps/api/src/api.ts`                  | L66-142       |
| `packages/sdk/src/hooks/tools.ts`      | Lundefined-13 |
| `packages/sdk/src/mcp/registry/api.ts` | Lundefined-83 |
| `packages/ai/src/mcp.ts`               | L251-325      |
| `packages/runtime/src/mastra.ts`       | L379-513      |
| `packages/ai/src/deco.ts`              | L28-194       |
| `packages/sdk/src/models/agent.ts`     | L32-143       |
| `packages/sdk/src/mcp/threads/api.ts`  | L272-374      |
| `.cursor/rules/data-flow.mdc`          | Lundefined-64 |

</details>

---

<details>
                <summary>Searched codebase "How to execute tool calls on MCP connections" • **13** results</summary>

| File                                                         | Lines     |
| ------------------------------------------------------------ | --------- |
| `packages/ai/src/mcp.ts`                                     | L58-143   |
| `packages/ai/src/triggers/trigger.ts`                        | L119-463  |
| `packages/runtime/src/mastra.ts`                             | L381-513  |
| `packages/runtime/src/proxy.ts`                              | L35-228   |
| `packages/ai/src/agent.ts`                                   | L205-1262 |
| `packages/sdk/src/mcp/integrations/api.ts`                   | L81-176   |
| `packages/sdk/src/hooks/tools.ts`                            | L32-68    |
| `packages/runtime/src/mcp.ts`                                | L32-113   |
| `apps/web/src/components/integrations/connection-detail.tsx` | L725-869  |
| `apps/api/src/api.ts`                                        | L79-184   |
| `packages/ai/src/mcp.ts`                                     | L145-249  |
| `packages/runtime/src/proxy.ts`                              | L96-228   |
| `apps/api/src/api.ts`                                        | L66-142   |

</details>

---

Now let me search for more specific information about tool call execution and
the UI components involved:

---

Read file: apps/web/src/components/integrations/tool-call-form.tsx

---

<details>
                <summary>Searched codebase "How to execute tool calls with useToolCall hook" • **14** results</summary>

| File                                                         | Lines         |
| ------------------------------------------------------------ | ------------- |
| `apps/web/src/components/integrations/connection-detail.tsx` | L725-869      |
| `packages/sdk/src/hooks/tools.ts`                            | L48-74        |
| `packages/sdk/src/hooks/tools.ts`                            | L32-68        |
| `packages/ai/src/agent.ts`                                   | L205-1262     |
| `apps/web/src/components/chat/context.tsx`                   | L65-239       |
| `packages/sdk/src/mcp/integrations/api.ts`                   | L81-176       |
| `packages/ai/src/triggers/trigger.ts`                        | L119-463      |
| `apps/web/src/components/integrations/tool-call-form.tsx`    | L60-202       |
| `packages/ai/src/mcp.ts`                                     | L58-143       |
| `apps/web/src/components/integrations/connection-detail.tsx` | L730-1012     |
| `packages/runtime/src/mastra.ts`                             | L381-513      |
| `apps/web/src/components/integrations/tool-call-form.tsx`    | L41-202       |
| `apps/api/src/api.ts`                                        | L79-184       |
| `apps/web/src/components/integrations/tool-call-form.tsx`    | Lundefined-39 |

</details>

---

<details>
                <summary>Searched codebase "MCP connection types HTTP SSE Websocket Deco implementation" • **14** results</summary>

| File                                                         | Lines         |
| ------------------------------------------------------------ | ------------- |
| `packages/ai/src/mcp.ts`                                     | Lundefined-50 |
| `packages/sdk/src/mcp/utils.ts`                              | Lundefined-76 |
| `apps/web/src/components/integrations/connection-detail.tsx` | L171-476      |
| `packages/ai/src/mcp.ts`                                     | L229-308      |
| `packages/sdk/src/models/mcp.ts`                             | L75-84        |
| `packages/runtime/src/connection.ts`                         | L19-51        |
| `packages/ai/src/mcp.ts`                                     | L309-382      |
| `.cursor/rules/data-flow.mdc`                                | L58-133       |
| `packages/sdk/src/models/agent.ts`                           | L32-143       |
| `packages/ai/src/mcp.ts`                                     | L145-249      |
| `packages/ai/src/mcp.ts`                                     | L136-227      |
| `apps/api/src/api.ts`                                        | L66-142       |
| `packages/sdk/src/models/mcp.ts`                             | L34-70        |
| `packages/sdk/src/models/mcp.ts`                             | L3-20         |

</details>

---

Now let me get the data flow rules to understand the patterns better:

---

### Rule: data-flow

**When working on anything related to dataflow, creating new tools, editing some
functionality that envolves backend and frontend. Mentions Tools, Authorization
and so on**

```markdown
# Data Flow Architecture

This document explains how data flows through the deco.chat system, covering the
API structure, client communication patterns, and authorization mechanisms.

## Overview

The system uses a **Model Context Protocol (MCP)** architecture where:

- **Backend**: Collection of MCP Servers exposing typed tools
- **Client**: Uses MCPClient to communicate with servers
- **Frontend**: Uses React Query for data fetching and caching
- **Security**: Role-based authorization controls tool access

## 1. MCP Server Architecture

### Server Structure

The API exposes multiple MCP servers at different endpoints:
```

/mcp → GLOBAL_TOOLS (teams, profiles, integrations) /:root/:slug/mcp →
WORKSPACE_TOOLS (agents, threads, models) /:root/:slug/agents/:id/mcp →
AGENT_TOOLS (agent-specific operations) /:root/:slug/email/mcp → EMAIL_TOOLS
(email operations)

````
### Tool Registration
MCP tools are registered with strict typing:

```typescript
// Tool Definition
interface Tool<TName, TInput, TReturn> {
  name: TName;
  description: string;
  inputSchema: z.ZodType<TInput>;      // Zod schema for input validation
  outputSchema?: z.ZodType<TReturn>;   // Zod schema for output validation
  handler: (props: TInput, context: AppContext) => Promise<TReturn>;
}

// Server Registration
server.registerTool(tool.name, {
  description: tool.description,
  inputSchema: tool.inputSchema.shape,
  outputSchema: tool.outputSchema?.shape,
}, tool.handler);
````

### Tool Collections

Tools are organized into typed collections:

```typescript
// Global tools (no workspace required)
export const GLOBAL_TOOLS = [
  teamsAPI.createTeam,
  profilesAPI.getProfile,
  integrationsAPI.listTools,
  // ...
] as const;

// Workspace tools (workspace-scoped)
export const WORKSPACE_TOOLS = [
  agentsAPI.createAgent,
  threadsAPI.getThread,
  modelsAPI.listModels,
  // ...
] as const;
```

## 2. Client Communication (MCPClient)

### MCPClient Structure

The client provides type-safe access to MCP tools:

```typescript
// Client factory methods
const MCPClient = {
  // Global tools
  PROFILES_GET: (params: GetProfileInput) => Promise<Profile>,
  TEAMS_CREATE: (params: CreateTeamInput) => Promise<Team>,

  // Workspace-scoped tools
  forWorkspace: (workspace: string) => ({
    AGENTS_CREATE: (params: CreateAgentInput) => Promise<Agent>,
    THREADS_LIST: (params: ListThreadsInput) => Promise<ThreadList>,
    // ...
  }),

  // Connection-specific tools
  forConnection: (connection: MCPConnection) => ({
    // Dynamic tools based on connection
  }),
};
```

### HTTP Communication

MCPClient translates tool calls to HTTP requests:

```typescript
// Tool call: MCPClient.AGENTS_CREATE(params)
// Becomes HTTP request:
POST /users/john/mcp/tools/call/AGENTS_CREATE
{
  "body": { /* params */ },
  "headers": {
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
  }
}
```

### Connection Types

The system supports multiple MCP connection types:

```typescript
type MCPConnection =
  | { type: "HTTP"; url: string; token?: string }
  | { type: "SSE"; url: string; token?: string }
  | { type: "Websocket"; url: string }
  | { type: "Deco"; tenant: string; token?: string }
  | { type: "INNATE"; name: string; workspace?: string };
```

## 3. React Query Integration

### Query Keys Structure

Consistent query key patterns for caching:

```typescript
export const KEYS = {
  AGENT: (
    workspace: Workspace,
    agentId?: string,
  ) => ["agent", workspace, agentId],
  THREADS: (
    workspace: Workspace,
    options?: ThreadFilterOptions,
  ) => ["threads", workspace, options?.agentId, options?.resourceId],
  INTEGRATION_TOOLS: (
    workspace: Workspace,
    integrationId: string,
  ) => ["integration-tools", workspace, integrationId],
  // ...
};
```

### Hook Patterns

Standardized hooks for each resource:

```typescript
// Query hooks
export const useAgent = (agentId: string) => {
  const { workspace } = useSDK();
  return useSuspenseQuery({
    queryKey: KEYS.AGENT(workspace, agentId),
    queryFn: () => loadAgent(workspace, agentId),
  });
};

// Mutation hooks
export const useCreateAgent = () => {
  const { workspace } = useSDK();
  const client = useQueryClient();

  return useMutation({
    mutationFn: (agent: Partial<Agent>) => createAgent(workspace, agent),
    onSuccess: (result) => {
      // Update cache
      client.setQueryData(KEYS.AGENT(workspace, result.id), result);
      client.setQueryData(
        KEYS.AGENT(workspace),
        (old) => old ? [result, ...old] : [result],
      );
    },
  });
};
```

### Cache Management

React Query handles caching with optimistic updates:

```typescript
// Optimistic update pattern
const updateMutation = useMutation({
  mutationFn: updateAgent,
  onMutate: async (newAgent) => {
    // Cancel outgoing refetches
    await client.cancelQueries(KEYS.AGENT(workspace, newAgent.id));

    // Snapshot previous value
    const previousAgent = client.getQueryData(
      KEYS.AGENT(workspace, newAgent.id),
    );

    // Optimistically update
    client.setQueryData(KEYS.AGENT(workspace, newAgent.id), newAgent);

    return { previousAgent };
  },
  onError: (err, newAgent, context) => {
    // Rollback on error
    client.setQueryData(
      KEYS.AGENT(workspace, newAgent.id),
      context.previousAgent,
    );
  },
});
```

## 4. Authorization System

### Resource Access Control

Every MCP tool must explicitly grant access:

```typescript
// Tool handler pattern
handler: (async (props: TInput, context: AppContext) => {
  // 1. Perform authorization checks
  await assertWorkspaceResourceAccess(context.tool.name, context);

  // 2. Explicitly grant access (required!)
  context.resourceAccess.grant();

  // 3. Execute business logic
  const result = await businessLogic(props);

  return result;
});
```

### Authorization Hierarchy

The system checks authorization in order:

1. **Local Development**: Automatic access if `context.isLocal`
2. **API Keys**: Check policies attached to API key
3. **User Workspace**: Personal workspace access (`users/:userId`)
4. **Shared Workspace**: Team-based access with policies (`shared/:teamSlug`)

### Policy-Based Access

Authorization uses policy statements:

```typescript
interface Policy {
  statements: Array<{
    effect: "allow" | "deny";
    resource: string; // e.g., "AGENTS_CREATE", "THREADS_LIST"
  }>;
}

// Policy evaluation: deny overrides allow
const canAccess = await authorizationClient.canAccess(
  userId,
  workspace,
  "AGENTS_CREATE",
);
```

### API Key Authorization

API keys include embedded policies:

```typescript
// API key creation
const apiKey = await createApiKey({
  name: "My API Key",
  policies: [
    { effect: "allow", resource: "AGENTS_CREATE" },
    { effect: "allow", resource: "THREADS_LIST" },
    { effect: "deny", resource: "TEAMS_DELETE" },
  ],
});

// JWT token includes workspace and policies
const token = jwt.sign({
  sub: `api-key:${apiKey.id}`,
  aud: workspace,
  policies: apiKey.policies,
});
```

## 5. Integration Flow

### Complete Data Flow Example

Here's how a typical operation flows through the system:

```typescript
// 1. Frontend hook call
const createAgent = useCreateAgent();
await createAgent.mutateAsync({
  name: "My Agent",
  instructions: "You are a helpful assistant"
});

// 2. React Query mutation
mutationFn: (agent) => createAgent(workspace, agent)

// 3. MCPClient call
MCPClient.forWorkspace(workspace).AGENTS_CREATE(agent)

// 4. HTTP request
POST /users/john/mcp/tools/call/AGENTS_CREATE
Authorization: Bearer <jwt-token>

// 5. MCP server routing
app.all("/:root/:slug/mcp", createMCPHandlerFor(WORKSPACE_TOOLS))

// 6. Tool execution
const tool = WORKSPACE_TOOLS.find(t => t.name === "AGENTS_CREATE");
await tool.handler(agent, context);

// 7. Authorization check
await assertWorkspaceResourceAccess("AGENTS_CREATE", context);
context.resourceAccess.grant();

// 8. Database operation
const result = await db.from("agents").insert(agent);

// 9. Response & cache update
React Query updates cache and triggers re-renders
```

## 6. Best Practices

### Tool Development

- Always use Zod schemas for input/output validation
- Call `context.resourceAccess.grant()` after authorization checks
- Use descriptive tool names following the pattern `{RESOURCE}_{ACTION}`
- Group related tools by functionality

### Frontend Integration

- Use consistent query keys from `KEYS` object
- Implement optimistic updates for better UX
- Handle loading and error states appropriately
- Use `useSuspenseQuery` for critical data

### Authorization

- Always check workspace/team access before operations
- Use least-privilege principle for API keys
- Implement proper error handling for forbidden operations
- Log authorization failures for debugging

### Performance

- Cache frequently accessed data with appropriate TTL
- Use React Query's built-in deduplication
- Implement proper pagination for large datasets
- Use parallel queries where appropriate

This architecture ensures type safety, proper authorization, and efficient data
management throughout the application.

````
---

Now I have a comprehensive understanding of the MCP debugging feature in the connection detail component. Let me create the comprehensive prompt for replicating this in a deco app.

---



---

I've created a comprehensive prompt document at `prompts/mcp-inspector.md` that contains all the necessary information to replicate the MCP debugging functionality from deco.chat's connection detail feature. 

## Summary

The document provides a complete implementation guide covering:

### **Core Features Analyzed:**
1. **Integration Management** - How to list, group, and configure MCP integrations
2. **Tool Discovery** - Fetching and displaying available tools from connections  
3. **Tool Testing Interface** - Form-based and raw JSON testing capabilities
4. **Connection Types** - Support for HTTP, SSE, WebSocket, and Deco connections

### **Key Technical Details Extracted:**
- **Data Flow Architecture** - Based on the MCP pattern with typed tools and client communication
- **API Structure** - Complete endpoint patterns and request/response formats
- **Component Architecture** - Detailed implementation of all UI components
- **Error Handling** - Comprehensive error states and recovery mechanisms
- **Transport Layer** - Connection creation for different MCP types

### **Implementation Roadmap:**
The document includes a 5-phase implementation plan from core infrastructure to advanced features and polish.

### **Real Code Examples:**
All examples are based on actual patterns from the deco.chat codebase, including:
- Integration grouping logic from `apps.ts`
- Tool execution patterns from `connection-detail.tsx`
- MCP client usage from the SDK
- Form generation from JSON schemas
- Connection configuration handling

The prompt provides everything needed for an AI to build a complete MCP Inspector tool that matches the debugging capabilities of the original deco.chat feature, with proper type safety, error handling, and user experience considerations.

---

_**User (2025-08-06 00:25Z)**_

Onde que esse inspector inicializa o mcp client?

---

_**Assistant**_

Ótima pergunta! Analisando o documento que criei, vejo que preciso esclarecer melhor onde e como o MCP Client é inicializado. Vou atualizar o documento para incluir essa informação crucial.

---

<details><summary>Edit file: prompts/mcp-inspector.md</summary>

undefined

**Chunk 1**
Lines added: 77, lines removed: 1

```diff
@@ -499,7 +499,83 @@
````

- ### 7. Connection Transport Implementation

* ### 7. MCP Client Initialization & Transport

  ```typescript
  ```
* // IMPORTANT: MCP Client initialization happens at different levels:
*
* // 1. GLOBAL MCP CLIENT (for listing integrations and global tools)
* // This is typically initialized at app startup or when user authenticates
* const initializeGlobalMCPClient = () => {
* // The global client doesn't need a specific connection
* // It uses the default API endpoint
* return MCPClient; // This is the singleton from @deco/sdk
* };
*
* // 2. WORKSPACE-SCOPED CLIENT (for workspace-specific operations)
* const initializeWorkspaceMCPClient = (workspace: string, token?: string) => {
* return MCPClient.forWorkspace(workspace, token);
* };
*
* // 3. CONNECTION-SPECIFIC CLIENT (for testing individual integrations)
* // This is created on-demand when testing tools
* const initializeConnectionMCPClient = async (connection: MCPConnection) => {
* // For simplified API calls (using the proxy pattern)
* const proxyClient = MCPClient.forConnection(connection);
*
* // For direct MCP protocol communication (if needed)
* const directClient = await createDirectMCPClient(connection);
*
* return { proxyClient, directClient };
* };
*
* // Hook-based initialization pattern (React)
* function useMCPClient(connection?: MCPConnection) {
* const [client, setClient] = useState(null);
* const [isInitializing, setIsInitializing] = useState(false);
*
* useEffect(() => {
* if (!connection) {
* // Use global client if no specific connection
* setClient(MCPClient);
* return;
* }
*
* setIsInitializing(true);
*
* // Initialize connection-specific client
* initializeConnectionMCPClient(connection)
* .then(({ proxyClient }) => {
* setClient(proxyClient);
* })
* .catch(console.error)
* .finally(() => setIsInitializing(false));
*
* return () => {
* // Cleanup if needed
* client?.close?.();
* };
* }, [connection]);
*
* return { client, isInitializing };
* }
*
* // Direct MCP Client creation (for low-level protocol communication)
* async function createDirectMCPClient(connection: MCPConnection) {
* const transport = createMCPTransport(connection);
* const client = new Client({
* name: "mcp-inspector",
* version: "1.0.0"
* }, {
* capabilities: {
* tools: {},
* prompts: {},
* resources: {},
* },
* });
*
* await client.connect(transport);
* return client;
* }
* // MCP connection transport creation function createMCPTransport(connection:
  MCPConnection, signal?: AbortSignal) {

````
**Chunk 2**
Lines added: undefined, lines removed: 11

```diff
@@ -548,15 +624,4 @@
    }
  }
- 
- // MCP Client creation
- async function createMCPClient(connection: MCPConnection) {
-   const transport = createMCPTransport(connection);
-   const client = new Client({ name: "mcp-inspector", version: "1.0.0" }, {
-     capabilities: {},
-   });
-   
-   await client.connect(transport);
-   return client;
- }
````

````
</details>

---

Agora vou adicionar mais exemplos práticos de onde e como o MCP Client é usado no contexto do inspector:

---

<details><summary>Edit file: prompts/mcp-inspector.md</summary>

undefined

**Chunk 1**
Lines added: 17, lines removed: 2

```diff
@@ -240,10 +240,25 @@
    const [search, setSearch] = useState("");
    const [selectedIntegration, setSelectedIntegration] = useState(integrations[0]);
+   
+   // MCP CLIENT INITIALIZATION HERE!
+   // Option 1: Using the proxy pattern (recommended for simplicity)
+   const listTools = (connection: MCPConnection) => {
+     return MCPClient.INTEGRATIONS_LIST_TOOLS({ connection });
+   };
+   
+   // Option 2: Using a custom hook for client management
+   const { client, isInitializing } = useMCPClient(selectedIntegration?.connection);
    
    // Fetch tools for selected integration
    const { data: tools, isLoading, error } = useQuery({
      queryKey: ["tools", selectedIntegration?.id],
-     queryFn: () => listTools(selectedIntegration.connection),
-     enabled: !!selectedIntegration,
+     queryFn: async () => {
+       // Using the MCPClient directly (proxy pattern)
+       const result = await MCPClient.INTEGRATIONS_LIST_TOOLS({ 
+         connection: selectedIntegration.connection 
+       });
+       return result.tools;
+     },
+     enabled: !!selectedIntegration && !isInitializing,
    });
````

</details>

---

Agora vou adicionar uma seção específica sobre quando e onde o MCP Client é
inicializado no início do documento:

---

<details><summary>Edit file: prompts/mcp-inspector.md</summary>

undefined

**Chunk 1** Lines added: 62, lines removed: undefined

````diff
@@ -137,4 +137,66 @@
    ]
  }
+ ```
+ 
+ ## MCP Client Initialization Strategy
+ 
+ ### Where and When to Initialize
+ 
+ The MCP Client is initialized at different points depending on the use case:
+ 
+ #### 1. **Application Bootstrap (Global Client)**
+ ```typescript
+ // App.tsx or main entry point
+ import { MCPClient } from "@deco/sdk";
+ 
+ function App() {
+   // Global MCP Client is available immediately as a singleton
+   // No initialization needed - it's ready to use
+   
+   useEffect(() => {
+     // Example: List all integrations on app load
+     MCPClient.INTEGRATIONS_LIST().then(integrations => {
+       console.log("Available integrations:", integrations);
+     });
+   }, []);
+   
+   return <MCPInspector />;
+ }
+ ```
+ 
+ #### 2. **Component-Level (Connection-Specific)**
+ ```typescript
+ // When testing a specific integration's tools
+ function ToolTester({ integration }) {
+   // Initialize client when component mounts or integration changes
+   const toolCall = useToolCall(integration.connection);
+   
+   // The useToolCall hook internally does:
+   // return useMutation({
+   //   mutationFn: (toolCall) => 
+   //     MCPClient.INTEGRATIONS_CALL_TOOL({
+   //       connection: integration.connection,
+   //       params: toolCall
+   //     })
+   // });
+ }
+ ```
+ 
+ #### 3. **On-Demand (Lazy Initialization)**
+ ```typescript
+ // Initialize only when user starts testing
+ function LazyToolTester() {
+   const [client, setClient] = useState(null);
+   
+   const handleStartTesting = async (connection: MCPConnection) => {
+     // Initialize client only when needed
+     const mcpClient = MCPClient.forConnection(connection);
+     setClient(mcpClient);
+     
+     // Now ready to call tools
+     const tools = await mcpClient.listTools();
+     // ...
+   };
+ }
````

````
</details>

---

Perfeito! Atualizei o documento para esclarecer exatamente **onde e quando o MCP Client é inicializado**. 

## Resumo das mudanças:

### 1. **Nova seção dedicada**: "MCP Client Initialization Strategy"
Explica os 3 níveis de inicialização:
- **Global Client** - Singleton disponível imediatamente no bootstrap da aplicação
- **Connection-Specific** - Inicializado quando um componente precisa testar uma integração específica
- **Lazy Initialization** - Criado sob demanda quando o usuário inicia o teste

### 2. **Seção expandida**: "MCP Client Initialization & Transport"
Detalha como criar clientes em diferentes contextos:
- `MCPClient` global (singleton do SDK)
- `MCPClient.forWorkspace()` para operações de workspace
- `MCPClient.forConnection()` para testar integrações específicas
- Hook `useMCPClient()` para gerenciar o ciclo de vida do cliente no React

### 3. **Exemplos práticos atualizados**
No componente `ToolsInspector`, mostro exatamente onde o cliente é usado:
```typescript
// Opção 1: Usar diretamente o MCPClient (padrão proxy)
const result = await MCPClient.INTEGRATIONS_LIST_TOOLS({ 
  connection: selectedIntegration.connection 
});

// Opção 2: Usar um hook customizado
const { client, isInitializing } = useMCPClient(selectedIntegration?.connection);
````

O ponto chave é que o **MCP Client do SDK (`@deco/sdk`) já vem como um singleton
pronto para uso**, não precisando de inicialização explícita para operações
globais. Para conexões específicas, você cria instâncias sob demanda usando os
métodos factory (`forWorkspace`, `forConnection`).

---
