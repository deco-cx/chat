<!-- Generated by SpecStory -->

# Generate a name for the chat (2025-09-16 17:42Z)

_**User (2025-09-16 15:51Z)**_

Com base em 

Skip to content
Navigation Menu
deco-cx
chat

Type / to search
Code
Issues
177
Pull requests
49
Discussions
Actions
Projects
1
Wiki
Security
Insights
Settings
chore: Add minimal working version of the Workflow API#1241
Preview
Switch back
·
Feedback
Open
tlgimenes
wants to merge 14 commits into
main
from
chore/workflows
+4.566
-734
Lines changed: 4566 additions & 734 deletions
Conversation48 (48)
Commits14 (14)
Checks1 (1)
Files changed53 (53)
Pull Request Toolbar
Open
chore: Add minimal working version of the Workflow API
#1241
tlgimenes
wants to merge 14 commits into
main
from
chore/workflows
0 / 53 viewed
Filter files…
File tree
apps
api
src
middlewares
actors-stub.ts
actors.ts
oauth
code.ts
utils
context.ts
workflows
index.ts
api.ts
main.ts
wrangler.toml
web
src
components/workflow-builder
dialogs
mapper-config-dialog.tsx
tool-config-dialog.tsx
2
nodes
mapper-node.tsx
tool-node.tsx
select-tool-dialog.tsx
workflow-canvas.tsx
workflow-execution-panel.tsx
workflow-input-form.tsx
workflow-palette.tsx
workflow-toolbar.tsx
pages/workflow-builder
workflow-builder-page.tsx
workflow-error-state.tsx
workflow-loading-skeleton.tsx
workflow-not-found-state.tsx
main.tsx
package.json
vite.config.ts
packages
ai/src
triggers
trigger.ts
agent.ts
sdk/src
actors
index.ts
1
auth
jwt.ts
crud
sandbox-workflows.ts
1
hooks
index.ts
sandbox-workflows.ts
workflow-builder.ts
workflows.ts
mcp
api-keys
api.ts
hosting
api.ts
sandbox
api.ts
run.ts
tools.ts
utils.ts
workflow-schemas.ts
workflows.ts
5
assertions.ts
context.ts
index.ts
workflows
index.ts
workflow-runner.ts
index.ts
lazy.ts
supabase/migrations
20250915134951_workflow.sql
20250915151844_workflow-crud.sql
20250915155631_workflow-async.sql
workflow.md
‎apps/api/src/middlewares/actors-stub.ts
+2
-17
Lines changed: 2 additions & 17 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -1,26 +1,11 @@
import type { ActorConstructor, StubFactory } from "@deco/actors";
import { ActorCfRuntime } from "@deco/actors/cf";
import { actors } from "@deco/actors/stub";
import type { AIAgent, Trigger } from "@deco/ai/actors";
import type { MiddlewareHandler } from "hono";
import type { MiddlewareHandler } from "hono";
import type { AppEnv } from "../utils/context.ts";
import type { AppEnv } from "../utils/context.ts";
import { runtime } from "./actors.ts";
import { stubFor } from "./actors.ts";


export const withActorsStubMiddleware: MiddlewareHandler<AppEnv> = async (
export const withActorsStubMiddleware: MiddlewareHandler<AppEnv> = async (
  ctx,
  ctx,
  next,
  next,
) => {
) => {
  const stub: <
  ctx.set("stub", stubFor(ctx.env));
    Constructor extends ActorConstructor<Trigger> | ActorConstructor<AIAgent>,
  >(
    c: Constructor,
  ) => StubFactory<InstanceType<Constructor>> = (c) => {
    return runtime instanceof ActorCfRuntime
      ? // deno-lint-ignore no-explicit-any
        runtime.stub(c, ctx.env as any)
      : actors.stub(c.name);
  };
  ctx.set("stub", stub);
  await next();
  await next();
};
};
‎apps/api/src/middlewares/actors.ts
+2
-4
Lines changed: 2 additions & 4 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -1,12 +1,10 @@
import { RuntimeClass } from "@deco/actors";
import { withActors } from "@deco/actors/hono";
import { withActors } from "@deco/actors/hono";
import { Hosts } from "@deco/sdk/hosts";
import { Hosts } from "@deco/sdk/hosts";
import type { Handler } from "hono";
import type { Handler } from "hono";
import { endTime, startTime } from "hono/timing";
import { endTime, startTime } from "hono/timing";
import type { AppEnv } from "../utils/context.ts";
import type { AppEnv } from "../utils/context.ts";
import { runtime, stubFor } from "@deco/sdk/actors";
export const runtime = new RuntimeClass();
export { runtime, stubFor };
// Create actors routes for both API hosts
// Create actors routes for both API hosts
const actorsRoutePathLegacy = `/${Hosts.API_LEGACY}/actors`;
const actorsRoutePathLegacy = `/${Hosts.API_LEGACY}/actors`;
const actorsRoutePath = `/${Hosts.API}/actors`;
const actorsRoutePath = `/${Hosts.API}/actors`;
‎apps/api/src/oauth/code.ts
+2
-2
Lines changed: 2 additions & 2 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -2,7 +2,7 @@ import { type JWTPayload } from "@deco/sdk/auth";
import type { Context } from "hono";
import type { Context } from "hono";
import { HTTPException } from "hono/http-exception";
import { HTTPException } from "hono/http-exception";
import { honoCtxToAppCtx } from "../api.ts";
import { honoCtxToAppCtx } from "../api.ts";
import { issuerFromContext, type AppEnv } from "../utils/context.ts";
import { type AppEnv } from "../utils/context.ts";


const tryParseUser = (user: unknown) => {
const tryParseUser = (user: unknown) => {
  if (typeof user === "string") {
  if (typeof user === "string") {
@@ -30,7 +30,7 @@ export const handleCodeExchange = async (c: Context<AppEnv>) => {
    }
    }


    const { claims } = data as unknown as { claims: JWTPayload };
    const { claims } = data as unknown as { claims: JWTPayload };
    const issuer = await issuerFromContext(appCtx);
    const issuer = await appCtx.jwtIssuer();
    const token = await issuer.issue({
    const token = await issuer.issue({
      ...claims,
      ...claims,
      user: "user" in claims ? tryParseUser(claims.user) : undefined,
      user: "user" in claims ? tryParseUser(claims.user) : undefined,
‎apps/api/src/utils/context.ts
+2
-19
Lines changed: 2 additions & 19 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -1,25 +1,8 @@
import type { EnvVars, IWorkspaceDB, Vars } from "@deco/sdk/mcp";
import type { Bindings, Vars } from "@deco/sdk/mcp";
import type { Context } from "hono";
import type { Context } from "hono";
import type { TimingVariables } from "hono/timing";
import type { TimingVariables } from "hono/timing";
import type { Blobs, Branch } from "../durable-objects/deconfig.ts";
export * from "@deco/sdk/mcp";
export * from "@deco/sdk/mcp";
export type { Bindings };
export type Bindings = EnvVars & {
  DECO_CHAT_APP_ORIGIN?: string;
  WORKSPACE_DB: DurableObjectNamespace<IWorkspaceDB & Rpc.DurableObjectBranded>;
  // DECONFIG DurableObjects
  BRANCH: DurableObjectNamespace<Branch>;
  BLOBS: DurableObjectNamespace<Blobs>;
  PROD_DISPATCHER: {
    get: <TOutbound extends Record<string, unknown> = Record<string, unknown>>(
      script: string,
      ctx?: Record<string, unknown>,
      metadata?: { outbound?: TOutbound },
    ) => { fetch: typeof fetch };
  };
  KB_FILE_PROCESSOR?: Workflow;
};
export type AppEnv = {
export type AppEnv = {
  Variables: Vars & TimingVariables;
  Variables: Vars & TimingVariables;
  Bindings: Bindings;
  Bindings: Bindings;
‎apps/api/src/workflows/index.ts
+2
Lines changed: 2 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,2 @@
export { WorkflowRunner } from "@deco/sdk/workflows";
export { KbFileProcessorWorkflow } from "./kb-file-processor-workflow.ts";
‎apps/api/src/api.ts
+15
-25
Lines changed: 15 additions & 25 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -10,7 +10,6 @@ import { DECO_CHAT_KEY_ID, getKeyPair } from "@deco/sdk/auth";
import {
import {
  AGENT_TOOLS,
  AGENT_TOOLS,
  assertWorkspaceResourceAccess,
  assertWorkspaceResourceAccess,
  AuthorizationClient,
  CallToolMiddleware,
  CallToolMiddleware,
  compose,
  compose,
  CONTRACTS_TOOLS,
  CONTRACTS_TOOLS,
@@ -23,16 +22,16 @@ import {
  getWorkspaceBucketName,
  getWorkspaceBucketName,
  GLOBAL_TOOLS,
  GLOBAL_TOOLS,
  type IntegrationWithTools,
  type IntegrationWithTools,
  issuerFromContext,
  ListToolsMiddleware,
  ListToolsMiddleware,
  PolicyClient,
  PrincipalExecutionContext,
  PROJECT_TOOLS,
  PROJECT_TOOLS,
  IntegrationSub as ProxySub,
  IntegrationSub as ProxySub,
  toBindingsContext,
  type ToolLike,
  type ToolLike,
  watchSSE,
  withMCPAuthorization,
  withMCPAuthorization,
  withMCPErrorHandling,
  withMCPErrorHandling,
  wrapToolFn,
  wrapToolFn,
  watchSSE,
} from "@deco/sdk/mcp";
} from "@deco/sdk/mcp";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import {
import {
@@ -48,7 +47,6 @@ import { logger } from "hono/logger";
import { endTime, startTime } from "hono/timing";
import { endTime, startTime } from "hono/timing";
import type { ContentfulStatusCode } from "hono/utils/http-status";
import type { ContentfulStatusCode } from "hono/utils/http-status";
import { studio } from "outerbase-browsable-do-enforced";
import { studio } from "outerbase-browsable-do-enforced";
import { createPosthogServerClient } from "packages/sdk/src/posthog.ts";
import { z } from "zod";
import { z } from "zod";
import { ROUTES as loginRoutes } from "./auth/index.ts";
import { ROUTES as loginRoutes } from "./auth/index.ts";
import { withActorsStubMiddleware } from "./middlewares/actors-stub.ts";
import { withActorsStubMiddleware } from "./middlewares/actors-stub.ts";
@@ -62,9 +60,10 @@ import { handleTrigger } from "./webhooks/trigger.ts";


const PROXY_TOKEN_HEADER = "X-Proxy-Auth";
const PROXY_TOKEN_HEADER = "X-Proxy-Auth";
export const app = new Hono<AppEnv>();
export const app = new Hono<AppEnv>();
export const honoCtxToAppCtx = (c: Context<AppEnv>): AppContext => {
  const envs = env(c);


const contextToPrincipalExecutionContext = (
  c: Context<AppEnv>,
): PrincipalExecutionContext => {
  const org = c.req.param("org") ?? c.req.param("root");
  const org = c.req.param("org") ?? c.req.param("root");
  const project = c.req.param("project") ?? c.req.param("slug");
  const project = c.req.param("project") ?? c.req.param("slug");
  const locator = org && project ? Locator.from({ org, project }) : undefined;
  const locator = org && project ? Locator.from({ org, project }) : undefined;
@@ -100,31 +99,22 @@ export const honoCtxToAppCtx = (c: Context<AppEnv>): AppContext => {
        branch,
        branch,
      }
      }
    : undefined;
    : undefined;
  const policyClient = PolicyClient.getInstance(c.var.db);
  const authorizationClient = new AuthorizationClient(policyClient);
  return {
  return {
    ...c.var,
    ...c.var,
    params: { ...c.req.query(), ...c.req.param() },
    params: { ...c.req.query(), ...c.req.param() },
    envVars: envs,
    workspace: ctxWorkspace,
    locator: ctxLocator,
    cookie: c.req.header("Cookie"),
    cookie: c.req.header("Cookie"),
    // token issued by the MCP Proxy server to identify the caller as deco api
    // token issued by the MCP Proxy server to identify the caller as deco api
    proxyToken: c.req.header(PROXY_TOKEN_HEADER)?.replace("Bearer ", ""),
    proxyToken: c.req.header(PROXY_TOKEN_HEADER)?.replace("Bearer ", ""),
    callerApp: c.req.header("x-caller-app"),
    callerApp: c.req.header("x-caller-app"),
    policy: policyClient,
    authorization: authorizationClient,
    token: c.req.header("Authorization")?.replace("Bearer ", ""),
    token: c.req.header("Authorization")?.replace("Bearer ", ""),
    kbFileProcessor: c.env.KB_FILE_PROCESSOR,
  };
    workspaceDO: c.env.WORKSPACE_DB,
};
    branchDO: c.env.BRANCH,
export const honoCtxToAppCtx = (c: Context<AppEnv>): AppContext => {
    blobsDO: c.env.BLOBS,
  return {
    workspace: ctxWorkspace,
    ...contextToPrincipalExecutionContext(c),
    locator: ctxLocator,
    ...toBindingsContext(env(c)),
    posthog: createPosthogServerClient({
      apiKey: envs.POSTHOG_API_KEY,
      apiHost: envs.POSTHOG_API_HOST,
    }),
  };
  };
};
};


@@ -342,7 +332,7 @@ const createMcpServerProxyForIntegration = async (


  const [integration, issuer] = await Promise.all([
  const [integration, issuer] = await Promise.all([
    fetchIntegration(),
    fetchIntegration(),
    issuerFromContext(ctx),
    ctx.jwtIssuer(),
  ]);
  ]);


  const token = await issuer.issue({
  const token = await issuer.issue({
‎apps/api/main.ts
+5
-5
Lines changed: 5 additions & 5 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -2,14 +2,17 @@
export * from "./src/actors.ts";
export * from "./src/actors.ts";
export { WorkspaceDatabase } from "./src/durable-objects/workspace-database.ts";
export { WorkspaceDatabase } from "./src/durable-objects/workspace-database.ts";
// DECONFIG DurableObjects (re-exported from SDK)
// DECONFIG DurableObjects (re-exported from SDK)
export { Branch, Blobs } from "./src/durable-objects/deconfig.ts";
export { Blobs, Branch } from "./src/durable-objects/deconfig.ts";
export {
  KbFileProcessorWorkflow,
  WorkflowRunner,
} from "./src/workflows/index.ts";
import { contextStorage } from "@deco/sdk/fetch";
import { contextStorage } from "@deco/sdk/fetch";
import { Hosts } from "@deco/sdk/hosts";
import { Hosts } from "@deco/sdk/hosts";
import { instrument } from "@deco/sdk/observability";
import { instrument } from "@deco/sdk/observability";
import { env } from "cloudflare:workers";
import { env } from "cloudflare:workers";
import { default as app } from "./src/app.ts";
import { default as app } from "./src/app.ts";
import { email } from "./src/email.ts";
import { email } from "./src/email.ts";
import { KbFileProcessorWorkflow } from "./src/workflows/kb-file-processor-workflow.ts";
import { tail } from "./tail.ts";
import { tail } from "./tail.ts";


// Choose instrumented app depending on runtime
// Choose instrumented app depending on runtime
@@ -85,6 +88,3 @@ export default {
    });
    });
  },
  },
};
};
// Export the workflow
export { KbFileProcessorWorkflow };
‎apps/api/wrangler.toml
+5
Lines changed: 5 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -68,6 +68,11 @@ name = "kb-file-processor"
binding = "KB_FILE_PROCESSOR"
binding = "KB_FILE_PROCESSOR"
class_name = "KbFileProcessorWorkflow"
class_name = "KbFileProcessorWorkflow"


[[workflows]]
name = "workflow-runner"
binding = "WORKFLOW_RUNNER"
class_name = "WorkflowRunner"
[[migrations]]
[[migrations]]
tag = "v4"
tag = "v4"
new_sqlite_classes = ["WorkspaceDatabase"] # Array of new classes
new_sqlite_classes = ["WorkspaceDatabase"] # Array of new classes
‎apps/web/src/components/workflow-builder/dialogs/mapper-config-dialog.tsx
+114
Lines changed: 114 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,114 @@
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@deco/ui/components/dialog.tsx";
import { Button } from "@deco/ui/components/button.tsx";
import { Input } from "@deco/ui/components/input.tsx";
import { Label } from "@deco/ui/components/label.tsx";
import { Textarea } from "@deco/ui/components/textarea.tsx";
import { useState } from "react";
interface MapperData {
  name: string;
  description: string;
  execute: string;
  outputSchema: Record<string, unknown>;
}
interface MapperConfigDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSubmit: (mapperData: MapperData) => void;
}
export function MapperConfigDialog({
  open,
  onOpenChange,
  onSubmit,
}: MapperConfigDialogProps) {
  const [name, setName] = useState("New Mapper");
  const [description, setDescription] = useState(
    "Transform data between workflow steps",
  );
  const [execute, setExecute] = useState(`export default async function(ctx) {
  const input = await ctx.readStepResult('previous-step');
  return input; // Identity transformation
}`);
  const handleSubmit = () => {
    onSubmit({
      name,
      description,
      execute,
      outputSchema: {},
    });
    onOpenChange(false);
    // Reset form
    setName("New Mapper");
    setDescription("Transform data between workflow steps");
    setExecute(`export default async function(ctx) {
  const input = await ctx.readStepResult('previous-step');
  return input; // Identity transformation
}`);
  };
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Configure Mapper</DialogTitle>
        </DialogHeader>
        <div className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="mapper-name">Name</Label>
            <Input
              id="mapper-name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="Enter mapper name"
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="mapper-description">Description</Label>
            <Textarea
              id="mapper-description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Describe what this mapper does"
              rows={2}
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="mapper-execute">Execute Function</Label>
            <Textarea
              id="mapper-execute"
              value={execute}
              onChange={(e) => setExecute(e.target.value)}
              placeholder="Enter the mapper function code"
              rows={8}
              className="font-mono text-sm"
            />
            <p className="text-xs text-muted-foreground">
              This function receives a context object with access to previous
              step results. Use <code>ctx.readStepResult('step-name')</code> to
              read data from previous steps.
            </p>
          </div>
        </div>
        <div className="flex justify-end gap-2 pt-4">
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button onClick={handleSubmit}>Add Mapper</Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
‎apps/web/src/components/workflow-builder/dialogs/tool-config-dialog.tsx
+62
Lines changed: 62 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,62 @@
import { Form } from "@rjsf/shadcn";
import { RJSFSchema } from "@rjsf/utils";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@deco/ui/components/dialog.tsx";
interface ToolConfigDialogProps {
  tool: {
    name: string;
    tool_name: string;
    integration: string;
    options?: Record<string, unknown>;
  };
  onSave: (options: Record<string, unknown>) => void;
  isOpen: boolean;
  onClose: () => void;
}
export function ToolConfigDialog({
  tool,
  onSave,
  isOpen,
  onClose,
}: ToolConfigDialogProps) {
  const schema: RJSFSchema = {
    type: "object",
    title: `Configure ${tool.name}`,
    properties: {
      retry: {
        type: "number",
        title: "Retry Attempts",
        minimum: 0,
        default: 0,
      },
      timeout: {
        type: "number",
        title: "Timeout (ms)",
        minimum: 1000,
        default: 30000,
      },
    },
  };
  const handleSubmit = ({ formData }: { formData: Record<string, unknown> }) => {
    onSave(formData);
    onClose();
  };
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-lg">
Comment on lines R53 to R54
coderabbitai[bot] commented 2 hours ago
@coderabbitai[bot]
coderabbitai[bot]
2 hours ago
Contributor
⚠️ Potential issue

Fix onOpenChange: don’t call onClose when opening.

Passing onClose directly causes it to fire for both open and close transitions, which can immediately re‑close the dialog.

- <Dialog open={isOpen} onOpenChange={onClose}>
+ <Dialog
+   open={isOpen}
+   onOpenChange={(open) => {
+     if (!open) onClose();
+   }}
+ >
📝 Committable suggestion
🤖 Prompt for AI Agents
Write a reply
        <DialogHeader>
          <DialogTitle>Configure Tool</DialogTitle>
        </DialogHeader>
        <Form schema={schema} formData={tool.options} onSubmit={handleSubmit} />
      </DialogContent>
    </Dialog>
  );
Comment on lines R1 to R61
coderabbitai[bot] commented 2 hours ago
@coderabbitai[bot]
coderabbitai[bot]
2 hours ago
Contributor
⚠️ Potential issue

🧩 Analysis chain
Run Biome formatter and commit formatting fixes.

Run pnpm biome format and commit the resulting changes. Biome reported formatting errors in:

apps/web/src/components/workflow-builder/dialogs/tool-config-dialog.tsx
apps/web/src/components/workflow-builder/workflow-canvas.tsx
apps/web/src/components/workflow-builder/workflow-input-form.tsx
packages/sdk/src/hooks/workflow-builder.ts
🧰 Tools
🤖 Prompt for AI Agents
Write a reply
}
‎apps/web/src/components/workflow-builder/nodes/mapper-node.tsx
+48
Lines changed: 48 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,48 @@
import { Handle, Position, type NodeProps } from "@xyflow/react";
import { Card, CardContent, CardHeader } from "@deco/ui/components/card.tsx";
import { Badge } from "@deco/ui/components/badge.tsx";
import { Icon } from "@deco/ui/components/icon.tsx";
interface MapperNodeData {
  type: "mapping";
  name: string;
  description: string;
  execute: string;
  outputSchema: Record<string, unknown>;
}
export function MapperNode({ data }: NodeProps<MapperNodeData>) {
  const isIdentityFunction = data.execute.includes(
    "return input; // Identity transformation",
  );
  return (
    <Card className="min-w-[200px] shadow-lg">
      <Handle type="target" position={Position.Top} />
      <CardHeader className="pb-2">
        <div className="flex items-center gap-2">
          <Icon name="transform" className="h-4 w-4 text-success" />
          <h3 className="font-semibold text-sm">{data.name}</h3>
        </div>
        <Badge
          variant={isIdentityFunction ? "secondary" : "default"}
          className="text-xs"
        >
          {isIdentityFunction ? "Identity" : "Transform"}
        </Badge>
      </CardHeader>
      <CardContent className="pt-0">
        <p className="text-xs text-muted-foreground mb-2">{data.description}</p>
        <div className="text-xs text-muted-foreground">
          {isIdentityFunction
            ? "Passes data through unchanged"
            : "Transforms data between steps"}
        </div>
      </CardContent>
      <Handle type="source" position={Position.Bottom} />
    </Card>
  );
}
‎apps/web/src/components/workflow-builder/nodes/tool-node.tsx
+47
Lines changed: 47 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,47 @@
import { Handle, Position, type NodeProps } from "@xyflow/react";
import { Card, CardContent, CardHeader } from "@deco/ui/components/card.tsx";
import { Badge } from "@deco/ui/components/badge.tsx";
import { Icon } from "@deco/ui/components/icon.tsx";
interface ToolNodeData {
  type: "tool_call";
  name: string;
  description: string;
  tool_name: string;
  integration: string;
  options?: Record<string, unknown>;
}
export function ToolNode({ data }: NodeProps<ToolNodeData>) {
  return (
    <Card className="min-w-[200px] shadow-lg">
      <Handle type="target" position={Position.Top} />
      <CardHeader className="pb-2">
        <div className="flex items-center gap-2">
          <Icon name="build" className="h-4 w-4 text-primary" />
          <h3 className="font-semibold text-sm">{data.name}</h3>
        </div>
        <Badge variant="secondary" className="text-xs">
          {data.integration}
        </Badge>
      </CardHeader>
      <CardContent className="pt-0">
        <p className="text-xs text-muted-foreground mb-2">{data.description}</p>
        <div className="text-xs text-muted-foreground">
          Tool: {data.tool_name}
        </div>
        {data.options && Object.keys(data.options).length > 0 && (
          <div className="mt-2">
            <Badge variant="outline" className="text-xs">
              Configured
            </Badge>
          </div>
        )}
      </CardContent>
      <Handle type="source" position={Position.Bottom} />
    </Card>
  );
}
‎apps/web/src/components/workflow-builder/select-tool-dialog.tsx
+243
Lines changed: 243 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,243 @@
import {
  type Integration,
  useIntegrations,
  useTools,
  type MCPConnection,
} from "@deco/sdk";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@deco/ui/components/dialog.tsx";
import { Icon } from "@deco/ui/components/icon.tsx";
import { Input } from "@deco/ui/components/input.tsx";
import { Card, CardContent } from "@deco/ui/components/card.tsx";
import { Badge } from "@deco/ui/components/badge.tsx";
import { cn } from "@deco/ui/lib/utils.ts";
import { useState, useMemo, useDeferredValue } from "react";
import { IntegrationIcon } from "../integrations/common.tsx";
interface Tool {
  name: string;
  description?: string;
  inputSchema?: Record<string, unknown>;
  integration: Integration;
}
interface SelectToolDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSelectTool: (tool: Tool) => void;
}
export function SelectToolDialog({
  open,
  onOpenChange,
  onSelectTool,
}: SelectToolDialogProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const deferredSearchTerm = useDeferredValue(searchTerm);
  const [selectedIntegrationId, setSelectedIntegrationId] = useState<
    string | null
  >(null);
  const { data: integrations = [] } = useIntegrations();
  // Filter integrations that have tools
  const integrationsWithTools = useMemo(() => {
    return integrations.filter(
      (integration) =>
        integration.connection &&
        ["HTTP", "SSE", "Websocket", "INNATE", "Deco"].includes(
          integration.connection.type,
        ),
    );
  }, [integrations]);
  const selectedIntegration = useMemo(() => {
    return (
      integrationsWithTools.find((i) => i.id === selectedIntegrationId) ||
      integrationsWithTools[0]
    );
  }, [integrationsWithTools, selectedIntegrationId]);
  // Get tools for the selected integration
  const { data: toolsData } = useTools(
    selectedIntegration?.connection as MCPConnection,
  );
  const tools = toolsData?.tools || [];
  // Filter tools based on search term
  const filteredTools = useMemo(() => {
    if (!deferredSearchTerm) return tools;
    const lowercaseSearch = deferredSearchTerm.toLowerCase();
    return tools.filter(
      (tool) =>
        tool.name.toLowerCase().includes(lowercaseSearch) ||
        (tool.description &&
          tool.description.toLowerCase().includes(lowercaseSearch)),
    );
  }, [tools, deferredSearchTerm]);
  const handleToolSelect = (tool: Tool) => {
    if (selectedIntegration) {
      onSelectTool({
        name: tool.name,
        description: tool.description,
        inputSchema: tool.inputSchema,
        integration: selectedIntegration,
      });
      onOpenChange(false);
    }
  };
  const handleIntegrationSelect = (integration: Integration) => {
    setSelectedIntegrationId(integration.id);
    setSearchTerm(""); // Clear search when switching integrations
  };
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-4/5 h-[90vh] p-0">
        <DialogHeader className="p-6 pb-4 border-b">
          <DialogTitle>Select Tool</DialogTitle>
        </DialogHeader>
        <div className="flex h-[calc(90vh-120px)]">
          {/* Integration List - Left Side */}
          <div className="w-1/3 border-r border-border flex flex-col">
            <div className="p-4 border-b border-border">
              <h3 className="font-medium text-sm mb-3">Integrations</h3>
              <Input
                placeholder="Search integrations..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="h-9"
              />
            </div>
            <div className="flex-1 overflow-y-auto p-2 space-y-1">
              {integrationsWithTools.map((integration) => (
                <Card
                  key={integration.id}
                  className={cn(
                    "cursor-pointer transition-colors hover:bg-accent",
                    selectedIntegrationId === integration.id &&
                      "bg-accent border-primary",
                  )}
                  onClick={() => handleIntegrationSelect(integration)}
                >
                  <CardContent className="p-3">
                    <div className="flex items-center gap-3">
                      <IntegrationIcon
                        icon={integration.icon}
                        name={integration.name}
                        size="sm"
                      />
                      <div className="flex-1 min-w-0">
                        <div className="font-medium text-sm truncate">
                          {integration.name}
                        </div>
                        <div className="text-xs text-muted-foreground">
                          {integration.connection?.type}
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>
          {/* Tools List - Right Side */}
          <div className="flex-1 flex flex-col">
            {selectedIntegration ? (
              <>
                <div className="p-4 border-b border-border">
                  <div className="flex items-center gap-3">
                    <IntegrationIcon
                      icon={selectedIntegration.icon}
                      name={selectedIntegration.name}
                      size="sm"
                    />
                    <div>
                      <h3 className="font-medium text-sm">
                        {selectedIntegration.name}
                      </h3>
                      <p className="text-xs text-muted-foreground">
                        {tools.length} tool{tools.length !== 1 ? "s" : ""}{" "}
                        available
                      </p>
                    </div>
                  </div>
                </div>
                <div className="flex-1 overflow-y-auto p-4 space-y-2">
                  {filteredTools.length === 0 ? (
                    <div className="text-center py-8 text-muted-foreground">
                      <Icon
                        name="search_off"
                        className="h-8 w-8 mx-auto mb-2"
                      />
                      <p>No tools found</p>
                      {deferredSearchTerm && (
                        <p className="text-xs">Try a different search term</p>
                      )}
                    </div>
                  ) : (
                    filteredTools.map((tool) => (
                      <Card
                        key={tool.name}
                        className="cursor-pointer transition-colors hover:bg-accent"
                        onClick={() => handleToolSelect(tool)}
                      >
                        <CardContent className="p-4">
                          <div className="flex items-start gap-3">
                            <Icon
                              name="build"
                              className="h-4 w-4 text-primary mt-0.5"
                            />
                            <div className="flex-1 min-w-0">
                              <div className="font-medium text-sm mb-1">
                                {tool.name}
                              </div>
                              {tool.description && (
                                <div className="text-xs text-muted-foreground line-clamp-2">
                                  {tool.description}
                                </div>
                              )}
                              {tool.inputSchema && (
                                <div className="mt-2">
                                  <Badge variant="outline" className="text-xs">
                                    {
                                      Object.keys(
                                        tool.inputSchema.properties || {},
                                      ).length
                                    }{" "}
                                    parameters
                                  </Badge>
                                </div>
                              )}
                            </div>
                          </div>
                        </CardContent>
                      </Card>
                    ))
                  )}
                </div>
              </>
            ) : (
              <div className="flex-1 flex items-center justify-center text-muted-foreground">
                <div className="text-center">
                  <Icon name="build" className="h-8 w-8 mx-auto mb-2" />
                  <p>Select an integration to view its tools</p>
                </div>
              </div>
            )}
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
‎apps/web/src/components/workflow-builder/workflow-canvas.tsx
+295
Lines changed: 295 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,295 @@
import React from "react";
import { WorkflowDefinitionSchema } from "@deco/sdk";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Background,
  type Connection,
  Controls,
  type Edge,
  type Node,
  type NodeChange,
  type EdgeChange,
  ReactFlow,
  applyEdgeChanges,
  applyNodeChanges,
  useEdgesState,
  useNodesState,
} from "@xyflow/react";
import "@xyflow/react/dist/style.css";
import { useCallback, useMemo, useEffect, useRef } from "react";
import { useForm } from "react-hook-form";
import { useWorkflowBuilder } from "@deco/sdk";
import type { WorkflowDefinition } from "@deco/sdk";
import { WorkflowPalette } from "./workflow-palette.tsx";
import { WorkflowToolbar } from "./workflow-toolbar.tsx";
import { MapperNode } from "./nodes/mapper-node.tsx";
import { ToolNode } from "./nodes/tool-node.tsx";
interface ToolData {
  name: string;
  description?: string;
  inputSchema?: Record<string, unknown>;
  integration: {
    name: string;
    id: string;
  };
}
interface MapperData {
  name: string;
  description: string;
  execute: string;
  outputSchema: Record<string, unknown>;
}
const nodeTypes = {
  tool: ToolNode,
  mapper: MapperNode,
};
interface WorkflowCanvasProps {
  workflow: WorkflowDefinition;
}
export function WorkflowCanvas({ workflow }: WorkflowCanvasProps) {
  const {
    convertWorkflowToFlow,
    convertFlowToWorkflow,
    handleGenerateWorkflow,
    handleRunWorkflow,
  } = useWorkflowBuilder(workflow);
  // Track when we should update nodes/edges from workflow (only on mount and after AI generation)
  const shouldUpdateFromWorkflow = useRef(true);
  const lastWorkflowRef = useRef(workflow);
  // Initialize nodes/edges from workflow on mount
  const initialFlowData = useMemo(() => {
    return convertWorkflowToFlow(workflow);
  }, [workflow, convertWorkflowToFlow]);
  const [nodes, setNodes] = useNodesState<Node>(initialFlowData.nodes);
  const [edges, setEdges] = useEdgesState<Edge>(initialFlowData.edges);
  // Update nodes/edges from workflow only when we should (mount or after AI generation)
  useEffect(() => {
    if (shouldUpdateFromWorkflow.current && workflow !== lastWorkflowRef.current) {
      const { nodes: newNodes, edges: newEdges } = convertWorkflowToFlow(workflow);
      setNodes(newNodes);
      setEdges(newEdges);
      lastWorkflowRef.current = workflow;
      shouldUpdateFromWorkflow.current = false; // Reset flag after update
    }
  }, [workflow, convertWorkflowToFlow, setNodes, setEdges]);
  const form = useForm<WorkflowDefinition>({
    resolver: zodResolver(WorkflowDefinitionSchema),
    defaultValues: workflow,
    mode: "onChange",
  });
  const { formState, setValue, reset } = form;
  const syncStepsFromFlow = useCallback(
    (nextNodes: Node[], nextEdges: Edge[]) => {
      const wf = convertFlowToWorkflow(nextNodes, nextEdges);
      setValue("steps", wf.steps, {
        shouldDirty: true,
        shouldTouch: true,
      });
    },
    [convertFlowToWorkflow, setValue],
  );
  const handleNodesChange = useCallback(
    (changes: NodeChange[]) => {
      setNodes((nds) => {
        const updated = applyNodeChanges(changes, nds);
        syncStepsFromFlow(updated, edges);
        return updated;
      });
    },
    [setNodes, edges, syncStepsFromFlow],
  );
  const handleEdgesChange = useCallback(
    (changes: EdgeChange[]) => {
      setEdges((eds) => {
        const updated = applyEdgeChanges(changes, eds);
        syncStepsFromFlow(nodes, updated);
        return updated;
      });
    },
    [setEdges, nodes, syncStepsFromFlow],
  );
  const handleConnect = useCallback(
    (connection: Connection) => {
      const sourceNode = nodes.find((n) => n.id === connection.source);
      const targetNode = nodes.find((n) => n.id === connection.target);
      if (sourceNode?.type === "tool" && targetNode?.type === "tool") {
        // Remove direct connection and insert mapper
        const newEdges = edges.filter(
          (e) =>
            !(e.source === connection.source && e.target === connection.target),
        );
        // Create mapper node
        const mapperId = `mapper-${Date.now()}`;
        const mapperNode: Node = {
          id: mapperId,
          type: "mapper",
          position: {
            x: (sourceNode.position.x + targetNode.position.x) / 2,
            y: (sourceNode.position.y + targetNode.position.y) / 2,
          },
          data: {
            type: "mapping",
            name: `map-${sourceNode.data.name}-to-${targetNode.data.name}`,
            description:
              "This mapper transforms the output from the previous step to match the input requirements of the next step",
            execute: `export default async function(ctx) {
  const input = await ctx.readStepResult('${sourceNode.data.name}');
  return input; // Identity transformation
}`,
            outputSchema: {},
          },
        };
        // Create new edges: source -> mapper -> target
        const newMapperEdges = [
          {
            id: `edge-${connection.source}-${mapperId}`,
            source: connection.source!,
            target: mapperId,
            type: "smoothstep",
          },
          {
            id: `edge-${mapperId}-${connection.target}`,
            source: mapperId,
            target: connection.target!,
            type: "smoothstep",
          },
        ];
        const nextNodes = [...nodes, mapperNode];
        const nextEdges = [...newEdges, ...newMapperEdges];
        setNodes(nextNodes);
        setEdges(nextEdges);
        syncStepsFromFlow(nextNodes, nextEdges);
      } else {
        // Regular connection
        const newEdge = {
          id: `edge-${connection.source}-${connection.target}`,
          source: connection.source!,
          target: connection.target!,
          type: "smoothstep",
        };
        const nextEdges = [...edges, newEdge];
        setEdges(nextEdges);
        syncStepsFromFlow(nodes, nextEdges);
      }
    },
    [nodes, edges, syncStepsFromFlow],
  );
  const handleGenerate = useCallback(async () => {
    const workflowDefinition = convertFlowToWorkflow(nodes, edges);
    await handleGenerateWorkflow(workflowDefinition);
    
    // After AI generation, mark that we should update from workflow when it changes
    shouldUpdateFromWorkflow.current = true;
    reset(workflowDefinition, { keepDirty: false, keepTouched: false });
  }, [nodes, edges, convertFlowToWorkflow, handleGenerateWorkflow, reset]);
  const handleRun = useCallback(async () => {
    const workflowDefinition = convertFlowToWorkflow(nodes, edges);
    await handleRunWorkflow(workflowDefinition);
  }, [nodes, edges, convertFlowToWorkflow, handleRunWorkflow]);
  // Function to add a tool to the canvas
  const handleAddTool = useCallback(
    (tool: ToolData) => {
      const newNode: Node = {
        id: `tool-${Date.now()}`,
        type: "tool",
        position: {
          x: Math.random() * 400 + 100,
          y: Math.random() * 300 + 100,
        },
        data: {
          type: "tool_call",
          name: tool.name,
          description: tool.description || `Tool: ${tool.name}`,
          tool_name: tool.name,
          integration: tool.integration.name,
          options: tool.inputSchema || {},
        },
      };
      const nextNodes = [...nodes, newNode];
      setNodes(nextNodes);
      syncStepsFromFlow(nextNodes, edges);
    },
    [setNodes, nodes, edges, syncStepsFromFlow],
  );
  // Function to add a mapper to the canvas
  const handleAddMapper = useCallback(
    (mapperData: MapperData) => {
      const newNode: Node = {
        id: `mapper-${Date.now()}`,
        type: "mapper",
        position: {
          x: Math.random() * 400 + 100,
          y: Math.random() * 300 + 100,
        },
        data: {
          type: "mapping",
          name: mapperData.name || "New Mapper",
          description:
            mapperData.description || "Transform data between workflow steps",
          execute:
            mapperData.execute ||
            `export default async function(ctx) {
  const input = await ctx.readStepResult('previous-step');
  return input; // Identity transformation
}`,
          outputSchema: mapperData.outputSchema || {},
        },
      };
      const nextNodes = [...nodes, newNode];
      setNodes(nextNodes);
      syncStepsFromFlow(nextNodes, edges);
    },
    [setNodes, nodes, edges, syncStepsFromFlow],
  );
  return (
    <div className="h-screen w-full">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={handleNodesChange}
        onEdgesChange={handleEdgesChange}
        onConnect={handleConnect}
        nodeTypes={nodeTypes as Record<string, React.ComponentType<unknown>>}
        fitView
      >
        <Background />
        <Controls />
        <WorkflowToolbar
          isDirty={formState.isDirty}
          onGenerate={handleGenerate}
          onRun={handleRun}
        />
        <WorkflowPalette
          onAddTool={handleAddTool}
          onAddMapper={handleAddMapper}
        />
      </ReactFlow>
    </div>
  );
}
‎apps/web/src/components/workflow-builder/workflow-execution-panel.tsx
+143
Lines changed: 143 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,143 @@
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from "@deco/ui/components/card.tsx";
import { Badge } from "@deco/ui/components/badge.tsx";
import { Button } from "@deco/ui/components/button.tsx";
import { Icon } from "@deco/ui/components/icon.tsx";
import { ScrollArea } from "@deco/ui/components/scroll-area.tsx";
interface ExecutionState {
  runId: string;
  status: "pending" | "running" | "completed" | "failed";
  currentStep?: string;
  stepResults: Record<string, unknown>;
  logs: Array<{ type: "log" | "warn" | "error"; content: string }>;
  startTime: number;
  endTime?: number;
}
interface WorkflowExecutionPanelProps {
  executionState?: ExecutionState;
  onReplayStep?: (stepName: string) => void;
}
export function WorkflowExecutionPanel({
  executionState,
  onReplayStep,
}: WorkflowExecutionPanelProps) {
  if (!executionState) {
    return null;
  }
  const getStatusBadge = (status: ExecutionState["status"]) => {
    switch (status) {
      case "pending":
        return <Badge variant="secondary">Pending</Badge>;
      case "running":
        return <Badge variant="default">Running</Badge>;
      case "completed":
        return (
          <Badge variant="default" className="bg-success">
            Completed
          </Badge>
        );
      case "failed":
        return <Badge variant="destructive">Failed</Badge>;
    }
  };
  const getLogIcon = (type: "log" | "warn" | "error") => {
    switch (type) {
      case "log":
        return <Icon name="info" className="h-3 w-3 text-primary" />;
      case "warn":
        return <Icon name="warning" className="h-3 w-3 text-warning" />;
      case "error":
        return <Icon name="error" className="h-3 w-3 text-destructive" />;
    }
  };
  return (
    <div className="absolute bottom-4 left-4 right-4 z-10">
      <Card className="shadow-lg">
        <CardHeader className="pb-3">
          <div className="flex items-center justify-between">
            <CardTitle className="text-sm">Workflow Execution</CardTitle>
            {getStatusBadge(executionState.status)}
          </div>
          {executionState.currentStep && (
            <p className="text-xs text-muted-foreground">
              Current Step: {executionState.currentStep}
            </p>
          )}
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Step Results */}
          {Object.keys(executionState.stepResults).length > 0 && (
            <div>
              <h4 className="text-sm font-medium mb-2">Step Results</h4>
              <div className="space-y-2">
                {Object.entries(executionState.stepResults).map(
                  ([stepName, _result]) => (
                    <div
                      key={stepName}
                      className="flex items-center justify-between p-2 bg-muted rounded"
                    >
                      <span className="text-xs font-medium">{stepName}</span>
                      <div className="flex items-center gap-2">
                        <Badge variant="outline" className="text-xs">
                          Completed
                        </Badge>
                        {onReplayStep && (
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={() => onReplayStep(stepName)}
                            className="h-6 px-2"
                          >
                            <Icon name="refresh" className="h-3 w-3" />
                          </Button>
                        )}
                      </div>
                    </div>
                  ),
                )}
              </div>
            </div>
          )}
          {/* Logs */}
          {executionState.logs.length > 0 && (
            <div>
              <h4 className="text-sm font-medium mb-2">Execution Logs</h4>
              <ScrollArea className="h-32">
                <div className="space-y-1">
                  {executionState.logs.map((log, index) => (
                    <div key={index} className="flex items-start gap-2 text-xs">
                      {getLogIcon(log.type)}
                      <span className="flex-1">{log.content}</span>
                    </div>
                  ))}
                </div>
              </ScrollArea>
            </div>
          )}
          {/* Execution Time */}
          <div className="text-xs text-muted-foreground">
            Started: {new Date(executionState.startTime).toLocaleTimeString()}
            {executionState.endTime && (
              <span className="ml-4">
                Ended: {new Date(executionState.endTime).toLocaleTimeString()}
              </span>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
‎apps/web/src/components/workflow-builder/workflow-input-form.tsx
+55
Lines changed: 55 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,55 @@
import { Form } from "@rjsf/shadcn";
import { RJSFSchema, UiSchema } from "@rjsf/utils";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@deco/ui/components/dialog.tsx";
interface WorkflowInputFormProps {
  schema: RJSFSchema;
  onSubmit: (data: Record<string, unknown>) => void;
  initialData?: Record<string, unknown>;
  isOpen: boolean;
  onClose: () => void;
}
export function WorkflowInputForm({
  schema,
  onSubmit,
  initialData,
  isOpen,
  onClose,
}: WorkflowInputFormProps) {
  const uiSchema: UiSchema = {
    "ui:submitButtonOptions": {
      submitText: "Run Workflow",
      norender: false,
      props: {
        className: "w-full",
      },
    },
  };
  const handleSubmit = ({ formData }: { formData: Record<string, unknown> }) => {
    onSubmit(formData);
    onClose();
  };
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Run Workflow</DialogTitle>
        </DialogHeader>
        <Form
          schema={schema}
          uiSchema={uiSchema}
          formData={initialData}
          onSubmit={handleSubmit}
        />
      </DialogContent>
    </Dialog>
  );
}
‎apps/web/src/components/workflow-builder/workflow-palette.tsx
+95
Lines changed: 95 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,95 @@
import { Button } from "@deco/ui/components/button.tsx";
import { Icon } from "@deco/ui/components/icon.tsx";
import { Card, CardContent, CardHeader } from "@deco/ui/components/card.tsx";
import { useState } from "react";
import { SelectToolDialog } from "./select-tool-dialog.tsx";
import { MapperConfigDialog } from "./dialogs/mapper-config-dialog.tsx";
interface Tool {
  name: string;
  description?: string;
  inputSchema?: Record<string, unknown>;
  integration: {
    name: string;
    id: string;
  };
}
interface MapperData {
  name: string;
  description: string;
  execute: string;
  outputSchema: Record<string, unknown>;
}
interface WorkflowPaletteProps {
  onAddTool: (tool: Tool) => void;
  onAddMapper: (mapperData: MapperData) => void;
}
export function WorkflowPalette({
  onAddTool,
  onAddMapper,
}: WorkflowPaletteProps) {
  const [isToolDialogOpen, setIsToolDialogOpen] = useState(false);
  const [isMapperDialogOpen, setIsMapperDialogOpen] = useState(false);
  const handleAddTool = () => {
    setIsToolDialogOpen(true);
  };
  const handleSelectTool = (tool: Tool) => {
    onAddTool(tool);
  };
  const handleAddMapper = () => {
    setIsMapperDialogOpen(true);
  };
  const handleMapperSubmit = (mapperData: MapperData) => {
    onAddMapper(mapperData);
  };
  return (
    <div className="absolute top-4 right-4 z-10">
      <Card className="w-64 shadow-lg">
        <CardHeader className="pb-3">
          <h3 className="font-semibold text-sm">Add Components</h3>
        </CardHeader>
        <CardContent className="space-y-2">
          <Button
            onClick={handleAddTool}
            variant="outline"
            className="w-full justify-start"
            size="sm"
          >
            <Icon name="build" className="h-4 w-4 mr-2" />
            Add Tool
          </Button>
          <Button
            onClick={handleAddMapper}
            variant="outline"
            className="w-full justify-start"
            size="sm"
          >
            <Icon name="transform" className="h-4 w-4 mr-2" />
            Add Mapper
          </Button>
        </CardContent>
      </Card>
      <SelectToolDialog
        open={isToolDialogOpen}
        onOpenChange={setIsToolDialogOpen}
        onSelectTool={handleSelectTool}
      />
      <MapperConfigDialog
        open={isMapperDialogOpen}
        onOpenChange={setIsMapperDialogOpen}
        onSubmit={handleMapperSubmit}
      />
    </div>
  );
}
‎apps/web/src/components/workflow-builder/workflow-toolbar.tsx
+47
Lines changed: 47 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,47 @@
import { Button } from "@deco/ui/components/button.tsx";
import { Icon } from "@deco/ui/components/icon.tsx";
import { Badge } from "@deco/ui/components/badge.tsx";
interface WorkflowToolbarProps {
  isDirty: boolean;
  onGenerate: () => void;
  onRun: () => void;
}
export function WorkflowToolbar({
  isDirty,
  onGenerate,
  onRun,
}: WorkflowToolbarProps) {
  return (
    <div className="absolute top-4 left-4 z-10">
      <div className="bg-background border rounded-lg shadow-lg p-4 flex items-center gap-3">
        <div className="flex items-center gap-2">
          <Icon name="account_tree" className="h-5 w-5" />
          <span className="font-semibold">Workflow Builder</span>
          {isDirty && (
            <Badge variant="destructive" className="text-xs">
              Unsaved Changes
            </Badge>
          )}
        </div>
        <div className="h-4 w-px bg-border" />
        <div className="flex gap-2">
          {isDirty ? (
            <Button onClick={onGenerate} size="sm">
              <Icon name="auto_fix_high" className="h-4 w-4 mr-2" />
              Generate Workflow
            </Button>
          ) : (
            <Button onClick={onRun} size="sm" variant="default">
              <Icon name="play_arrow" className="h-4 w-4 mr-2" />
              Run Workflow
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}
‎apps/web/src/pages/workflow-builder/workflow-builder-page.tsx
+24
Lines changed: 24 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,24 @@
import { useParams } from "react-router";
import { WorkflowCanvas } from "../../components/workflow-builder/workflow-canvas.tsx";
import { useWorkflow } from "@deco/sdk";
import { WorkflowErrorState } from "./workflow-error-state.tsx";
import { WorkflowLoadingSkeleton } from "./workflow-loading-skeleton.tsx";
import { WorkflowNotFoundState } from "./workflow-not-found-state.tsx";
export default function WorkflowBuilderPage() {
  const { org, project, workflowName } = useParams();
  if (!org || !project || !workflowName) {
    return (
      <WorkflowErrorState error="Missing required parameters: org, project, or workflowName" />
    );
  }
  const { workflow, isLoading, error } = useWorkflow(workflowName);
  if (isLoading) return <WorkflowLoadingSkeleton />;
  if (error) return <WorkflowErrorState error={error} />;
  if (!workflow) return <WorkflowNotFoundState workflowName={workflowName} />;
  return <WorkflowCanvas workflow={workflow} />;
}
‎apps/web/src/pages/workflow-builder/workflow-error-state.tsx
+26
Lines changed: 26 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,26 @@
import { Button } from "@deco/ui/components/button.tsx";
import { Icon } from "@deco/ui/components/icon.tsx";
import { useNavigate } from "react-router";
interface WorkflowErrorStateProps {
  error: string;
}
export function WorkflowErrorState({ error }: WorkflowErrorStateProps) {
  const navigate = useNavigate();
  return (
    <div className="h-screen w-full flex items-center justify-center">
      <div className="flex flex-col items-center gap-4 max-w-md text-center">
        <Icon name="alert-circle" className="h-12 w-12 text-destructive" />
        <div>
          <h2 className="text-lg font-semibold">Failed to Load Workflow</h2>
          <p className="text-muted-foreground mt-2">{error}</p>
        </div>
        <Button onClick={() => navigate(-1)} variant="outline">
          Go Back
        </Button>
      </div>
    </div>
  );
}
‎apps/web/src/pages/workflow-builder/workflow-loading-skeleton.tsx
+12
Lines changed: 12 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,12 @@
import { Spinner } from "@deco/ui/components/spinner.tsx";
export function WorkflowLoadingSkeleton() {
  return (
    <div className="h-screen w-full flex items-center justify-center">
      <div className="flex flex-col items-center gap-4">
        <Spinner className="h-8 w-8" />
        <p className="text-muted-foreground">Loading workflow...</p>
      </div>
    </div>
  );
}
‎apps/web/src/pages/workflow-builder/workflow-not-found-state.tsx
+36
Lines changed: 36 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,36 @@
import { Button } from "@deco/ui/components/button.tsx";
import { Icon } from "@deco/ui/components/icon.tsx";
import { useNavigate } from "react-router";
interface WorkflowNotFoundStateProps {
  workflowName: string;
}
export function WorkflowNotFoundState({
  workflowName,
}: WorkflowNotFoundStateProps) {
  const navigate = useNavigate();
  return (
    <div className="h-screen w-full flex items-center justify-center">
      <div className="flex flex-col items-center gap-4 max-w-md text-center">
        <Icon name="file-x" className="h-12 w-12 text-muted-foreground" />
        <div>
          <h2 className="text-lg font-semibold">Workflow Not Found</h2>
          <p className="text-muted-foreground mt-2">
            The workflow "{workflowName}" does not exist. You can create a new
            workflow by adding tools and mappers to the canvas.
          </p>
        </div>
        <div className="flex gap-2">
          <Button onClick={() => navigate(-1)} variant="outline">
            Go Back
          </Button>
          <Button onClick={() => globalThis.location.reload()}>
            Create New Workflow
          </Button>
        </div>
      </div>
    </div>
  );
}
‎apps/web/src/main.tsx
+7
Lines changed: 7 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -162,6 +162,12 @@ const WorkflowDetailPage = lazy(() =>
  wrapWithUILoadingFallback(import("./components/workflows/detail.tsx")),
  wrapWithUILoadingFallback(import("./components/workflows/detail.tsx")),
);
);


const WorkflowBuilderPage = lazy(() =>
  wrapWithUILoadingFallback(
    import("./pages/workflow-builder/workflow-builder-page.tsx"),
  ),
);
const AppAuth = lazy(() =>
const AppAuth = lazy(() =>
  wrapWithUILoadingFallback(import("./components/apps/auth.tsx")),
  wrapWithUILoadingFallback(import("./components/apps/auth.tsx")),
);
);
@@ -345,6 +351,7 @@ const router = createBrowserRouter([
          { path: "prompts", Component: ListPrompts },
          { path: "prompts", Component: ListPrompts },
          { path: "prompt/:id", Component: PromptDetail },
          { path: "prompt/:id", Component: PromptDetail },
          { path: "workflows", Component: WorkflowListPage },
          { path: "workflows", Component: WorkflowListPage },
          { path: "workflows/:workflowName", Component: WorkflowBuilderPage },
          { path: "discover", Component: Discover },
          { path: "discover", Component: Discover },
          {
          {
            path: "workflows/:workflowName/instances/:instanceId",
            path: "workflows/:workflowName/instances/:instanceId",
‎apps/web/package.json
+1
Lines changed: 1 addition & 0 deletions


Original file line number	Original file line	Diff line number	Diff line change
@@ -17,6 +17,7 @@
    "@deco/ui": "^1.0.0",
    "@deco/ui": "^1.0.0",
    "@gsap/react": "^2.1.2",
    "@gsap/react": "^2.1.2",
    "@hookform/resolvers": "^5.2.0",
    "@hookform/resolvers": "^5.2.0",
    "@rjsf/shadcn": "^6.0.0-beta.10",
    "@std/path": "npm:@jsr/std__path@1.1.0",
    "@std/path": "npm:@jsr/std__path@1.1.0",
    "@tanstack/react-query": "^5.80.6",
    "@tanstack/react-query": "^5.80.6",
    "@tiptap/extension-mention": "^2.14.0",
    "@tiptap/extension-mention": "^2.14.0",
‎apps/web/vite.config.ts
+6
Lines changed: 6 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -29,5 +29,11 @@ export default defineConfig({
    esbuildOptions: {
    esbuildOptions: {
      target: "es2022",
      target: "es2022",
    },
    },
    exclude: ["@deco/cf-sandbox"],
  },
  build: {
    rollupOptions: {
      external: ["@deco/cf-sandbox"],
    },
  },
  },
});
});
‎packages/ai/src/triggers/trigger.ts
+16
-54
Lines changed: 16 additions & 54 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -12,38 +12,31 @@
// are not enforced at runtime in JavaScript and are not preserved in the transpiled output.
// are not enforced at runtime in JavaScript and are not preserved in the transpiled output.
import type { ActorState } from "@deco/actors";
import type { ActorState } from "@deco/actors";
import { Actor } from "@deco/actors";
import { Actor } from "@deco/actors";
import { JwtIssuer, SUPABASE_URL } from "@deco/sdk/auth";
import { Locator } from "@deco/sdk";
import { WELL_KNOWN_AGENT_IDS } from "@deco/sdk/constants";
import { WELL_KNOWN_AGENT_IDS } from "@deco/sdk/constants";
import { contextStorage } from "@deco/sdk/fetch";
import { contextStorage } from "@deco/sdk/fetch";
import { Hosts } from "@deco/sdk/hosts";
import { Hosts } from "@deco/sdk/hosts";
import {
import {
  type AppContext,
  type AppContext,
  AuthorizationClient,
  BindingsContext,
  createResourceAccess,
  createResourceAccess,
  fromWorkspaceString,
  fromWorkspaceString,
  MCPClient,
  MCPClient,
  type MCPClientStub,
  type MCPClientStub,
  PolicyClient,
  PrincipalExecutionContext,
  type ProjectTools,
  type ProjectTools,
  toBindingsContext,
} from "@deco/sdk/mcp";
} from "@deco/sdk/mcp";
import type { Callbacks } from "@deco/sdk/mcp/binder";
import type { Callbacks } from "@deco/sdk/mcp/binder";
import type { CallTool } from "@deco/sdk/models";
import type { CallTool } from "@deco/sdk/models";
import { getTwoFirstSegments, type Workspace } from "@deco/sdk/path";
import { getTwoFirstSegments, type Workspace } from "@deco/sdk/path";
import {
  createPosthogServerClient,
  PosthogServerClient,
} from "@deco/sdk/posthog";
import type { Json } from "@deco/sdk/storage";
import type { Json } from "@deco/sdk/storage";
import { createServerClient } from "@supabase/ssr";
import { Cloudflare } from "cloudflare";
import { getRuntimeKey } from "hono/adapter";
import { getRuntimeKey } from "hono/adapter";
import process from "node:process";
import { AIAgent } from "../agent.ts";
import { AIAgent } from "../agent.ts";
import { isApiDecoChatMCPConnection } from "../mcp.ts";
import { isApiDecoChatMCPConnection } from "../mcp.ts";
import { hooks as cron } from "./cron.ts";
import { hooks as cron } from "./cron.ts";
import type { TriggerData, TriggerRun } from "./services.ts";
import type { TriggerData, TriggerRun } from "./services.ts";
import { hooks as webhook } from "./webhook.ts";
import { hooks as webhook } from "./webhook.ts";
import { Locator } from "@deco/sdk";
export type { TriggerData };
export type { TriggerData };


export const threadOf = (
export const threadOf = (
@@ -132,27 +125,16 @@ export class Trigger {
  protected data: TriggerData | null = null;
  protected data: TriggerData | null = null;
  protected hooks: TriggerHooks<TriggerData> | null = null;
  protected hooks: TriggerHooks<TriggerData> | null = null;
  protected workspace: Workspace;
  protected workspace: Workspace;
  protected context: BindingsContext;
  private branch: string = "main"; // TODO(@mcandeia) for now only main branch is supported
  private branch: string = "main"; // TODO(@mcandeia) for now only main branch is supported
  protected posthog: PosthogServerClient;
  private db: ReturnType<typeof createServerClient>;
  private env: any;
  private env: any;


  constructor(
  constructor(
    public state: ActorState,
    public state: ActorState,
    protected actorEnv: any,
    protected actorEnv: any,
  ) {
  ) {
    this.env = {
    this.context = toBindingsContext(this.actorEnv);
      ...process.env,
      ...actorEnv,
    };
    this.workspace = getTwoFirstSegments(this.state.id);
    this.workspace = getTwoFirstSegments(this.state.id);
    this.db = createServerClient(SUPABASE_URL, this.env.SUPABASE_SERVER_TOKEN, {
      cookies: { getAll: () => [] },
    });
    this.posthog = createPosthogServerClient({
      apiKey: this.env.POSTHOG_API_KEY,
      apiHost: this.env.POSTHOG_API_HOST,
    });


    this.mcpClient = this._createMCPClient();
    this.mcpClient = this._createMCPClient();


@@ -173,7 +155,7 @@ export class Trigger {
  }
  }


  private _trackEvent(event: string, properties: Record<string, unknown> = {}) {
  private _trackEvent(event: string, properties: Record<string, unknown> = {}) {
    this.posthog.trackEvent(event as any, {
    this.context.posthog.trackEvent(event as any, {
      distinctId: this.state.id,
      distinctId: this.state.id,
      $process_person_profile: false,
      $process_person_profile: false,
      actorId: this.state.id,
      actorId: this.state.id,
@@ -191,46 +173,26 @@ export class Trigger {
  }
  }


  private _createContext(): AppContext {
  private _createContext(): AppContext {
    const policyClient = PolicyClient.getInstance(this.db);
    const authorizationClient = new AuthorizationClient(policyClient);
    const workspace = fromWorkspaceString(this.workspace, this.branch);
    const workspace = fromWorkspaceString(this.workspace, this.branch);
    const { org, project } = Locator.parse(this.workspace);
    const { org, project } = Locator.parse(this.workspace);
    const locatorValue = Locator.from({ org, project });
    const locatorValue = Locator.from({ org, project });
    const principalContext: PrincipalExecutionContext = {
    return {
      params: {},
      params: {},
      envVars: this.env,
      db: this.db,
      // can be ignored for now.
      user: null as unknown as AppContext["user"],
      user: null as unknown as AppContext["user"],
      isLocal: true,
      isLocal: true,
      workspaceDO: this.actorEnv.WORKSPACE_DB,
      resourceAccess: createResourceAccess(),
      stub: this.state.stub as AppContext["stub"],
      // i suspect triggers on old root/slug format for
      // root == "users" will not work anymore
      workspace,
      workspace,
      locator: { org, project, value: locatorValue, branch: this.branch },
      locator: { org, project, value: locatorValue, branch: this.branch },
      resourceAccess: createResourceAccess(),
    };
      cf: new Cloudflare({ apiToken: this.env.CF_API_TOKEN }),
      policy: policyClient,
    return {
      authorization: authorizationClient,
      ...this.context,
      posthog: this.posthog,
      ...principalContext,
      branchDO: this.actorEnv.BRANCH,
      blobsDO: this.actorEnv.BLOBS,
    };
    };
  }
  }


  _token() {
  _token() {
    const keyPair =
    return this.context.jwtIssuer().then((issuer) =>
      this.env.DECO_CHAT_API_JWT_PRIVATE_KEY &&
      this.env.DECO_CHAT_API_JWT_PUBLIC_KEY
        ? {
            public: this.env.DECO_CHAT_API_JWT_PUBLIC_KEY,
            private: this.env.DECO_CHAT_API_JWT_PRIVATE_KEY,
          }
        : undefined;
    return JwtIssuer.forKeyPair(keyPair).then((issuer) =>
      issuer.issue({
      issuer.issue({
        sub: `trigger:${this._getTriggerId()}`,
        sub: `trigger:${this._getTriggerId()}`,
        aud: this.workspace,
        aud: this.workspace,
@@ -378,7 +340,7 @@ export class Trigger {
  }
  }


  private async _saveRun(run: Omit<TriggerRun, "id" | "timestamp">) {
  private async _saveRun(run: Omit<TriggerRun, "id" | "timestamp">) {
    await this.db
    await this.context.db
      .from("deco_chat_trigger_runs")
      .from("deco_chat_trigger_runs")
      .insert({
      .insert({
        trigger_id: run.triggerId,
        trigger_id: run.triggerId,
‎packages/ai/src/agent.ts
+14
-43
Lines changed: 14 additions & 43 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -16,7 +16,6 @@ import type { ActorState, InvokeMiddlewareOptions } from "@deco/actors";
import { Actor } from "@deco/actors";
import { Actor } from "@deco/actors";
import { type Agent as Configuration, Locator } from "@deco/sdk";
import { type Agent as Configuration, Locator } from "@deco/sdk";
import { type AuthMetadata, BaseActor } from "@deco/sdk/actors";
import { type AuthMetadata, BaseActor } from "@deco/sdk/actors";
import { JwtIssuer, SUPABASE_URL } from "@deco/sdk/auth";
import {
import {
  DEFAULT_MAX_STEPS,
  DEFAULT_MAX_STEPS,
  DEFAULT_MAX_THINKING_TOKENS,
  DEFAULT_MAX_THINKING_TOKENS,
@@ -32,23 +31,20 @@ import { contextStorage } from "@deco/sdk/fetch";
import {
import {
  type AppContext,
  type AppContext,
  assertWorkspaceResourceAccess,
  assertWorkspaceResourceAccess,
  AuthorizationClient,
  BindingsContext,
  createResourceAccess,
  createResourceAccess,
  fromWorkspaceString,
  fromWorkspaceString,
  MCPClient,
  MCPClient,
  type MCPClientStub,
  type MCPClientStub,
  PolicyClient,
  PrincipalExecutionContext,
  type ProjectTools,
  type ProjectTools,
  serializeError,
  serializeError,
  SupabaseLLMVault,
  SupabaseLLMVault,
  toBindingsContext,
} from "@deco/sdk/mcp";
} from "@deco/sdk/mcp";
import type { AgentMemoryConfig } from "@deco/sdk/memory";
import type { AgentMemoryConfig } from "@deco/sdk/memory";
import { AgentMemory, slugify, toAlphanumericId } from "@deco/sdk/memory";
import { AgentMemory, slugify, toAlphanumericId } from "@deco/sdk/memory";
import { trace } from "@deco/sdk/observability";
import { trace } from "@deco/sdk/observability";
import {
  createPosthogServerClient,
  type PosthogServerClient,
} from "@deco/sdk/posthog";
import {
import {
  createServerTimings,
  createServerTimings,
  type ServerTimingsBuilder,
  type ServerTimingsBuilder,
@@ -58,7 +54,6 @@ import type { ToolsetsInput, ToolsInput } from "@mastra/core/agent";
import { Agent } from "@mastra/core/agent";
import { Agent } from "@mastra/core/agent";
import type { MastraMemory } from "@mastra/core/memory";
import type { MastraMemory } from "@mastra/core/memory";
import { TokenLimiter } from "@mastra/memory/processors";
import { TokenLimiter } from "@mastra/memory/processors";
import { createServerClient } from "@supabase/ssr";
import type { CoreMessage } from "ai";
import type { CoreMessage } from "ai";
import {
import {
  type GenerateObjectResult,
  type GenerateObjectResult,
@@ -67,7 +62,6 @@ import {
  type Message,
  type Message,
  smoothStream,
  smoothStream,
} from "ai";
} from "ai";
import { Cloudflare } from "cloudflare";
import { getRuntimeKey } from "hono/adapter";
import { getRuntimeKey } from "hono/adapter";
import jsonSchemaToZod from "json-schema-to-zod";
import jsonSchemaToZod from "json-schema-to-zod";
import process from "node:process";
import process from "node:process";
@@ -210,17 +204,16 @@ export class AIAgent extends BaseActor<AgentMetadata> implements IIAgent {
   * These tools are ready to be used. To use them, just filter using the pickCallableTools function.
   * These tools are ready to be used. To use them, just filter using the pickCallableTools function.
   */
   */
  protected callableToolSet: ToolsetsInput = {};
  protected callableToolSet: ToolsetsInput = {};
  protected context: BindingsContext;


  public locator: ProjectLocator;
  public locator: ProjectLocator;
  private id: string;
  private id: string;
  public _configuration?: Configuration;
  public _configuration?: Configuration;
  private agentMemoryConfig: AgentMemoryConfig;
  private agentMemoryConfig: AgentMemoryConfig;
  private agentId: string;
  private agentId: string;
  private wallet: AgentWallet;
  private wallet: AgentWallet;
  private db: Awaited<ReturnType<typeof createServerClient>>;
  private agentScoppedMcpClient: MCPClientStub<ProjectTools>;
  private agentScoppedMcpClient: MCPClientStub<ProjectTools>;
  private telemetry?: Telemetry;
  private telemetry?: Telemetry;
  private posthog: PosthogServerClient;
  private branch: string = "main"; // TODO(@mcandeia) for now only main branch is supported
  private branch: string = "main"; // TODO(@mcandeia) for now only main branch is supported


  constructor(
  constructor(
@@ -234,17 +227,10 @@ export class AIAgent extends BaseActor<AgentMetadata> implements IIAgent {
      ...process.env,
      ...process.env,
      ...this.env,
      ...this.env,
    };
    };
    this.context = toBindingsContext(this.actorEnv);
    this.locator = Locator.asFirstTwoSegmentsOf(this.state.id);
    this.locator = Locator.asFirstTwoSegmentsOf(this.state.id);
    this.agentMemoryConfig = null as unknown as AgentMemoryConfig;
    this.agentMemoryConfig = null as unknown as AgentMemoryConfig;
    this.agentId = this.state.id.split("/").pop() ?? "";
    this.agentId = this.state.id.split("/").pop() ?? "";
    this.db = createServerClient(SUPABASE_URL, this.env.SUPABASE_SERVER_TOKEN, {
      cookies: { getAll: () => [] },
    });
    this.posthog = createPosthogServerClient({
      apiKey: this.env.POSTHOG_API_KEY,
      apiHost: this.env.POSTHOG_API_HOST,
    });
    this.agentScoppedMcpClient = this._createMCPClient();
    this.agentScoppedMcpClient = this._createMCPClient();
    this.wallet = new AgentWallet({
    this.wallet = new AgentWallet({
      agentId: this.id,
      agentId: this.id,
@@ -271,15 +257,15 @@ export class AIAgent extends BaseActor<AgentMetadata> implements IIAgent {
  private get llmVault() {
  private get llmVault() {
    return this.env.LLMS_ENCRYPTION_KEY
    return this.env.LLMS_ENCRYPTION_KEY
      ? new SupabaseLLMVault(
      ? new SupabaseLLMVault(
          this.db,
          this.context.db,
          this.env.LLMS_ENCRYPTION_KEY,
          this.env.LLMS_ENCRYPTION_KEY,
          this.workspace,
          this.workspace,
        )
        )
      : undefined;
      : undefined;
  }
  }


  private _trackEvent(event: string, properties: Record<string, unknown> = {}) {
  private _trackEvent(event: string, properties: Record<string, unknown> = {}) {
    this.posthog.trackEvent(event as any, {
    this.context.posthog.trackEvent(event as any, {
      distinctId: this.metadata?.user?.id ?? this.id,
      distinctId: this.metadata?.user?.id ?? this.id,
      $process_person_profile: this.metadata?.user !== null,
      $process_person_profile: this.metadata?.user !== null,
      actorId: this.id,
      actorId: this.id,
@@ -290,18 +276,12 @@ export class AIAgent extends BaseActor<AgentMetadata> implements IIAgent {
  }
  }


  private _createAppContext(metadata?: AgentMetadata): AppContext {
  private _createAppContext(metadata?: AgentMetadata): AppContext {
    const policyClient = PolicyClient.getInstance(this.db);
    const workspace = fromWorkspaceString(this.workspace, this.branch);
    const workspace = fromWorkspaceString(this.workspace, this.branch);
    const { org, project } = Locator.parse(this.locator);
    const { org, project } = Locator.parse(this.locator);
    const principalContext: PrincipalExecutionContext = {
    return {
      params: {},
      params: {},
      envVars: this.env as any,
      db: this.db,
      user: metadata?.user!,
      user: metadata?.user!,
      isLocal: metadata?.user == null,
      isLocal: metadata?.user == null,
      stub: this.state.stub as AppContext["stub"],
      workspaceDO: this.actorEnv.WORKSPACE_DB,
      cookie: metadata?.userCookie ?? undefined,
      cookie: metadata?.userCookie ?? undefined,
      workspace,
      workspace,
      locator: {
      locator: {
@@ -311,12 +291,11 @@ export class AIAgent extends BaseActor<AgentMetadata> implements IIAgent {
        branch: this.branch,
        branch: this.branch,
      },
      },
      resourceAccess: createResourceAccess(),
      resourceAccess: createResourceAccess(),
      cf: new Cloudflare({ apiToken: this.env.CF_API_TOKEN }),
    };
      policy: policyClient,
      authorization: new AuthorizationClient(policyClient),
    return {
      posthog: this.posthog,
      ...this.context,
      branchDO: this.actorEnv.BRANCH,
      ...principalContext,
      blobsDO: this.actorEnv.BLOBS,
    };
    };
  }
  }


@@ -717,15 +696,7 @@ export class AIAgent extends BaseActor<AgentMetadata> implements IIAgent {
  }
  }


  _token() {
  _token() {
    const keyPair =
    return this.context.jwtIssuer().then((issuer) =>
      this.env.DECO_CHAT_API_JWT_PRIVATE_KEY &&
      this.env.DECO_CHAT_API_JWT_PUBLIC_KEY
        ? {
            public: this.env.DECO_CHAT_API_JWT_PUBLIC_KEY,
            private: this.env.DECO_CHAT_API_JWT_PRIVATE_KEY,
          }
        : undefined;
    return JwtIssuer.forKeyPair(keyPair).then((issuer) =>
      issuer.issue({
      issuer.issue({
        sub: `agent:${this.id}`,
        sub: `agent:${this.id}`,
        aud: this.workspace,
        aud: this.workspace,
‎packages/sdk/src/actors/index.ts
+21
-1
Lines changed: 21 additions & 1 deletion
Original file line number	Original file line	Diff line number	Diff line change
@@ -1,6 +1,14 @@
import {
  Actor,
  ActorConstructor,
  RuntimeClass,
  StubFactory,
} from "@deco/actors";
import { ActorCfRuntime } from "@deco/actors/cf";
import { actors } from "@deco/actors/proxy";
import process from "node:process";
import process from "node:process";
import { type AuthUser, getUserBySupabaseCookie } from "../auth/user.ts";
import { type AuthUser, getUserBySupabaseCookie } from "../auth/user.ts";
import type { Principal } from "../mcp/index.ts";
import type { Bindings, Principal } from "../mcp/index.ts";


export interface AuthMetadata {
export interface AuthMetadata {
  user?: AuthUser | null;
  user?: AuthUser | null;
@@ -45,3 +53,15 @@ export abstract class BaseActor<TMetadata extends AuthMetadata = AuthMetadata> {
    return user ?? null;
    return user ?? null;
  }
  }
}
}
export const runtime = new RuntimeClass();
export const stubFor = (env: Bindings) => {
  return <TActor extends Actor, Constructor extends ActorConstructor<TActor>>(
    c: Constructor,
  ): StubFactory<InstanceType<Constructor>> => {
    return runtime instanceof ActorCfRuntime
      ? // deno-lint-ignore no-explicit-any
        runtime.stub(c, env as any)
      : actors.stub(c.name);
  };
Comment on lines R62 to R66
coderabbitai[bot] commented 3 hours ago
@coderabbitai[bot]
coderabbitai[bot]
3 hours ago
Contributor
⚠️ Potential issue

Use a stable identifier instead of constructor.name for proxy stubs.

actors.stub(c.name) is brittle under minification/obfuscation and can break resolution in production builds. Prefer an explicit, non-minified static identifier on the actor constructor, with a safe fallback only during dev.

Apply this minimal change here and add static actorId on your actor classes:

-      : actors.stub(c.name);
+      : actors.stub((c as any).actorId ?? c.name);
Follow‑up: declare static actorId = "MyActor"; on each actor class to make this robust.

📝 Committable suggestion
🤖 Prompt for AI Agents
Write a reply
};
‎packages/sdk/src/auth/jwt.ts
+6
Lines changed: 6 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -102,6 +102,7 @@ export type JwtPayloadWithClaims<
> = JWTPayload & TClaims;
> = JWTPayload & TClaims;


export interface JwtVerifier {
export interface JwtVerifier {
  publicKey: () => Promise<string>;
  verify: <TClaims extends Record<string, unknown> = Record<string, unknown>>(
  verify: <TClaims extends Record<string, unknown> = Record<string, unknown>>(
    jwt: string,
    jwt: string,
  ) => Promise<JwtPayloadWithClaims<TClaims> | undefined>;
  ) => Promise<JwtPayloadWithClaims<TClaims> | undefined>;
@@ -123,6 +124,11 @@ export interface JwtIssuerKeyPair {


const newJwtVerifier = (key: CryptoKey): JwtVerifier => {
const newJwtVerifier = (key: CryptoKey): JwtVerifier => {
  return {
  return {
    publicKey: () => {
      return crypto.subtle
        .exportKey("jwk", key)
        .then((jwk) => stringifyJWK(jwk as JsonWebKey));
    },
    verify: async <
    verify: async <
      TClaims extends Record<string, unknown> = Record<string, unknown>,
      TClaims extends Record<string, unknown> = Record<string, unknown>,
    >(
    >(
‎packages/sdk/src/crud/sandbox-workflows.ts
+100
Lines changed: 100 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,100 @@
import { MCPClient } from "../fetcher.ts";
import { ProjectLocator } from "../locator.ts";
export interface SandboxWorkflowDefinition {
  name: string;
  description: string;
  inputSchema: Record<string, unknown>;
  outputSchema: Record<string, unknown>;
  steps: Array<{
    type: "tool_call" | "mapping";
    def: Record<string, unknown>;
  }>;
}
export interface SandboxWorkflowUpsertParams {
  name: string;
  description: string;
  inputSchema: Record<string, unknown>;
  outputSchema: Record<string, unknown>;
  steps: Array<{
    type: "tool_call" | "mapping";
    def: Record<string, unknown>;
  }>;
}
export interface SandboxWorkflowStartParams {
  name: string;
  input: Record<string, unknown>;
}
export interface SandboxWorkflowStatusParams {
  runId: string;
}
export interface SandboxWorkflowReplayParams {
  runId: string;
  stepName: string;
}
export function getSandboxWorkflow(
  locator: ProjectLocator,
  name: string,
  signal?: AbortSignal,
) {
  const client = MCPClient.forLocator(locator);
  return client.SANDBOX_GET_WORKFLOW({ name }, { signal });
}
export function upsertSandboxWorkflow(
  locator: ProjectLocator,
  params: SandboxWorkflowUpsertParams,
  signal?: AbortSignal,
) {
  const client = MCPClient.forLocator(locator);
  return client.SANDBOX_UPSERT_WORKFLOW(params, { signal });
}
export function startSandboxWorkflow(
  locator: ProjectLocator,
  params: SandboxWorkflowStartParams,
  signal?: AbortSignal,
) {
  const client = MCPClient.forLocator(locator);
  return client.SANDBOX_START_WORKFLOW(params, { signal });
}
Comment on lines R58 to R65
coderabbitai[bot] commented 18 hours ago
@coderabbitai[bot]
coderabbitai[bot]
18 hours ago
Contributor
💡 Verification agent

🧩 Analysis chain
Critical: replace SANDBOX_RUN_WORKFLOW → SANDBOX_START_WORKFLOW in DB migration

Code and MCP tool name use SANDBOX_START_WORKFLOW; supabase/migrations/20250915151844_workflow-crud.sql still grants SANDBOX_RUN_WORKFLOW — update the migration/policy to SANDBOX_START_WORKFLOW to avoid missing-permission/404 at runtime.

Offending: supabase/migrations/20250915151844_workflow-crud.sql — '{"effect":"allow","resource":"SANDBOX_RUN_WORKFLOW"}'::jsonb (line ~6).
Canonical: packages/sdk/src/mcp/sandbox/workflows.ts (name: "SANDBOX_START_WORKFLOW" ~line 732), packages/sdk/src/crud/sandbox-workflows.ts (client.SANDBOX_START_WORKFLOW ~line 64), supabase/migrations/20250915155631_workflow-async.sql (uses SANDBOX_START_WORKFLOW).
🤖 Prompt for AI Agents
Write a reply
export function getSandboxWorkflowStatus(
  locator: ProjectLocator,
  params: SandboxWorkflowStatusParams,
  signal?: AbortSignal,
) {
  const client = MCPClient.forLocator(locator);
  return client.SANDBOX_GET_WORKFLOW_STATUS(params, { signal });
}
export function replaySandboxWorkflowFromStep(
  locator: ProjectLocator,
  params: SandboxWorkflowReplayParams,
  signal?: AbortSignal,
) {
  const client = MCPClient.forLocator(locator);
  return client.SANDBOX_REPLAY_WORKFLOW_FROM_STEP(params, { signal });
}
export function deleteSandboxWorkflow(
  locator: ProjectLocator,
  name: string,
  signal?: AbortSignal,
) {
  const client = MCPClient.forLocator(locator);
  return client.SANDBOX_DELETE_WORKFLOW({ name }, { signal });
}
export function listSandboxWorkflows(
  locator: ProjectLocator,
  signal?: AbortSignal,
) {
  const client = MCPClient.forLocator(locator);
  return client.SANDBOX_LIST_WORKFLOWS({}, { signal });
}
‎packages/sdk/src/hooks/index.ts
+1
Lines changed: 1 addition & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -18,3 +18,4 @@ export * from "./keys.ts";
export * from "./registry.ts";
export * from "./registry.ts";
export * from "./permissions.ts";
export * from "./permissions.ts";
export * from "./models.ts";
export * from "./models.ts";
export * from "./sandbox-workflows.ts";
‎packages/sdk/src/hooks/sandbox-workflows.ts
+155
Lines changed: 155 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,155 @@
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import {
  getSandboxWorkflow,
  upsertSandboxWorkflow,
  startSandboxWorkflow,
  getSandboxWorkflowStatus,
  replaySandboxWorkflowFromStep,
  deleteSandboxWorkflow,
  listSandboxWorkflows,
  type SandboxWorkflowDefinition as _SandboxWorkflowDefinition,
  type SandboxWorkflowUpsertParams,
  type SandboxWorkflowStartParams,
  type SandboxWorkflowStatusParams as _SandboxWorkflowStatusParams,
  type SandboxWorkflowReplayParams,
} from "../crud/sandbox-workflows.ts";
import { InternalServerError } from "../errors.ts";
import { useSDK } from "./store.tsx";
/**
 * Hook to get a sandbox workflow by name
 */
export const useSandboxWorkflow = (workflowName: string) => {
  const { locator } = useSDK();
  const { data, isLoading, error, refetch } = useQuery({
    queryKey: ["sandbox-workflow", locator, workflowName],
    queryFn: async ({ signal }) => {
      const result = await getSandboxWorkflow(locator, workflowName, signal);
      return result.workflow;
    },
    retry: (failureCount, error) =>
      error instanceof InternalServerError && failureCount < 2,
    staleTime: 5 * 60 * 1000, // Cache for 5 minutes
  });
  return {
    data,
    isLoading,
    error,
    refetch,
  };
};
/**
 * Hook to upsert (create or update) a sandbox workflow
 */
export const useUpsertSandboxWorkflow = () => {
  const { locator } = useSDK();
  return useMutation({
    mutationFn: async (params: SandboxWorkflowUpsertParams) => {
      const result = await upsertSandboxWorkflow(locator, params);
      if (!result.success) {
        throw new Error(result.error || "Failed to save workflow");
      }
      return result;
    },
  });
};
/**
 * Hook to start a sandbox workflow execution
 */
export const useStartSandboxWorkflow = () => {
  const { locator } = useSDK();
  return useMutation({
    mutationFn: async (params: SandboxWorkflowStartParams) => {
      const result = await startSandboxWorkflow(locator, params);
      if (result.error) {
        throw new Error(result.error);
      }
      return result;
    },
  });
};
/**
 * Hook to get the status of a sandbox workflow run
 */
export const useSandboxWorkflowStatus = (runId: string) => {
  const { locator } = useSDK();
  return useSuspenseQuery({
    queryKey: ["sandbox-workflow-status", locator, runId],
    queryFn: ({ signal }) =>
      getSandboxWorkflowStatus(locator, { runId }, signal),
    retry: (failureCount, error) =>
      error instanceof InternalServerError && failureCount < 2,
    refetchInterval: (query) => {
      const data = query.state.data;
      const status = data?.status;
      if (status === "completed" || status === "failed") {
        return false;
      }
      return 1000; // Poll every 1 second by default
    },
  });
};
/**
 * Hook to replay a sandbox workflow from a specific step
 */
export const useReplaySandboxWorkflowFromStep = () => {
  const { locator } = useSDK();
  return useMutation({
    mutationFn: async (params: SandboxWorkflowReplayParams) => {
      const result = await replaySandboxWorkflowFromStep(locator, params);
      if (result.error) {
        throw new Error(result.error);
      }
      return result;
    },
  });
};
/**
 * Hook to delete a sandbox workflow
 */
export const useDeleteSandboxWorkflow = () => {
  const { locator } = useSDK();
  return useMutation({
    mutationFn: async (workflowName: string) => {
      const result = await deleteSandboxWorkflow(locator, workflowName);
      return result;
    },
  });
};
/**
 * Hook to list all sandbox workflows
 */
export const useSandboxWorkflows = () => {
  const { locator } = useSDK();
  const { data, isLoading, error, refetch } = useQuery({
    queryKey: ["sandbox-workflows", locator],
    queryFn: async ({ signal }) => {
      const result = await listSandboxWorkflows(locator, signal);
      return result.workflows;
    },
    retry: (failureCount, error) =>
      error instanceof InternalServerError && failureCount < 2,
    staleTime: 5 * 60 * 1000, // Cache for 5 minutes
  });
  return {
    data,
    isLoading,
    error,
    refetch,
  };
};
‎packages/sdk/src/hooks/workflow-builder.ts
+143
Lines changed: 143 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,143 @@
import { useCallback } from "react";
import type { Node, Edge } from "@xyflow/react";
import {
  useUpsertSandboxWorkflow,
  useStartSandboxWorkflow,
} from "./sandbox-workflows.ts";
import type { WorkflowDefinition } from "../mcp/sandbox/workflow-schemas.ts";
export function useWorkflowBuilder(workflow: WorkflowDefinition) {
  const convertWorkflowToFlow = useCallback((workflow: WorkflowDefinition) => {
    const nodes: Node[] = [];
    const edges: Edge[] = [];
    // Convert workflow steps to nodes
    workflow.steps.forEach((step, index) => {
      const nodeId = `node-${index}`;
      const node: Node = {
        id: nodeId,
        type: step.type === "tool_call" ? "tool" : "mapper",
        position: { x: index * 200, y: 100 },
        data: {
          type: step.type,
          name: step.def.name,
          description: step.def.description,
          ...(step.type === "tool_call"
            ? {
                tool_name: (step.def as Record<string, unknown>).tool_name as string,
                integration: (step.def as Record<string, unknown>).integration as string,
                options: (step.def as Record<string, unknown>).options as Record<string, unknown>,
              }
            : {
                execute: (step.def as Record<string, unknown>).execute as string,
                outputSchema: {},
              }),
        },
      };
      nodes.push(node);
      // Create edges between consecutive steps
      if (index > 0) {
        const prevNodeId = `node-${index - 1}`;
        edges.push({
          id: `edge-${prevNodeId}-${nodeId}`,
          source: prevNodeId,
          target: nodeId,
          type: "smoothstep",
        });
      }
    });
    return { nodes, edges };
  }, []);
  const convertFlowToWorkflow = useCallback(
    (nodes: Node[], _edges: Edge[]): WorkflowDefinition => {
      // Sort nodes by position to maintain order
      const sortedNodes = [...nodes].sort(
        (a, b) => a.position.x - b.position.x,
      );
      const steps = sortedNodes
        .map((node) => {
          if (node.data.type === "tool_call") {
            return {
              type: "tool_call" as const,
              def: {
                name: node.data.name,
                description: node.data.description,
                options: (node.data as Record<string, unknown>).options as Record<string, unknown>,
                tool_name: (node.data as Record<string, unknown>).tool_name as string,
                integration: (node.data as Record<string, unknown>).integration as string,
              },
            };
          } else if (node.data.type === "mapping") {
            return {
              type: "mapping" as const,
              def: {
                name: node.data.name,
                description: node.data.description,
                execute: (node.data as Record<string, unknown>).execute as string,
              },
            };
          }
          return null;
        })
        .filter(Boolean);
      return {
        name: workflow.name,
        description: workflow.description,
        inputSchema: workflow.inputSchema,
        outputSchema: workflow.outputSchema,
        steps: steps,
      };
    },
    [workflow],
  );
  const upsertWorkflow = useUpsertSandboxWorkflow();
  const startWorkflow = useStartSandboxWorkflow();
  const handleGenerateWorkflow = useCallback(
    async (workflowDefinition: WorkflowDefinition) => {
      try {
        await upsertWorkflow.mutateAsync(workflowDefinition);
        console.log("Workflow saved successfully:", workflowDefinition);
      } catch (error) {
        console.error("Failed to generate workflow:", error);
        throw error;
      }
    },
    [upsertWorkflow],
  );
  const handleRunWorkflow = useCallback(
    async (
      workflowDefinition: WorkflowDefinition,
      input?: Record<string, unknown>,
    ) => {
      try {
        // Use the SDK hook for workflow execution
        const result = await startWorkflow.mutateAsync({
          name: workflowDefinition.name,
          input: input || {},
        });
        console.log("Workflow started successfully:", result);
        return result;
      } catch (error) {
        console.error("Failed to run workflow:", error);
        throw error;
      }
    },
    [startWorkflow],
  );
  return {
    convertWorkflowToFlow,
    convertFlowToWorkflow,
    handleGenerateWorkflow,
    handleRunWorkflow,
  };
}
‎packages/sdk/src/hooks/workflows.ts
+36
Lines changed: 36 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -6,6 +6,8 @@ import {
} from "../crud/workflows.ts";
} from "../crud/workflows.ts";
import { InternalServerError } from "../errors.ts";
import { InternalServerError } from "../errors.ts";
import { useSDK } from "./store.tsx";
import { useSDK } from "./store.tsx";
import { useSandboxWorkflow } from "./sandbox-workflows.ts";
import type { WorkflowDefinition } from "../mcp/sandbox/workflow-schemas.ts";


/**
/**
 * Hook to get all unique workflow names in the workspace
 * Hook to get all unique workflow names in the workspace
@@ -114,3 +116,37 @@ export const useWorkflowStatus = (workflowName: string, instanceId: string) => {
    },
    },
  });
  });
};
};
/**
 * Hook to get a workflow definition with fallback to empty workflow
 */
export function useWorkflow(workflowName: string) {
  const { data, isLoading, error } = useSandboxWorkflow(workflowName);
  // If workflow doesn't exist, create a new one
  const workflow = data || createEmptyWorkflow(workflowName);
  return {
    workflow,
    isLoading,
    error: error?.message || null,
  };
}
function createEmptyWorkflow(name: string): WorkflowDefinition {
  return {
    name,
    description: `Workflow: ${name}`,
    inputSchema: {
      type: "object",
      properties: {},
      required: [],
    },
    outputSchema: {
      type: "object",
      properties: {},
      required: [],
    },
    steps: [],
  };
}
‎packages/sdk/src/mcp/api-keys/api.ts
+2
-3
Lines changed: 2 additions & 3 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -10,7 +10,6 @@ import type { QueryResult } from "../../storage/index.ts";
import {
import {
  assertHasWorkspace,
  assertHasWorkspace,
  assertWorkspaceResourceAccess,
  assertWorkspaceResourceAccess,
  issuerFromContext,
} from "../assertions.ts";
} from "../assertions.ts";
import { createToolGroup } from "../context.ts";
import { createToolGroup } from "../context.ts";
import { MCPClient } from "../index.ts";
import { MCPClient } from "../index.ts";
@@ -184,7 +183,7 @@ export const createApiKey = createTool({
      throw new InternalServerError(error.message);
      throw new InternalServerError(error.message);
    }
    }


    const issuer = await issuerFromContext(c);
    const issuer = await c.jwtIssuer();
    const value = await issuer.issue({
    const value = await issuer.issue({
      ...claims,
      ...claims,
      sub: `api-key:${apiKey.id}`,
      sub: `api-key:${apiKey.id}`,
@@ -232,7 +231,7 @@ export const reissueApiKey = createTool({


    // Generate new JWT token with the provided claims
    // Generate new JWT token with the provided claims


    const issuer = await issuerFromContext(c);
    const issuer = await c.jwtIssuer();
    const value = await issuer.issue({
    const value = await issuer.issue({
      ...claims,
      ...claims,
      sub: `api-key:${apiKey.id}`,
      sub: `api-key:${apiKey.id}`,
‎packages/sdk/src/mcp/hosting/api.ts
+3
-13
Lines changed: 3 additions & 13 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -1,8 +1,8 @@
import { D1Store } from "@deco/workers-runtime/d1";
import { D1Store } from "@deco/workers-runtime/d1";
import { parse as parseToml } from "smol-toml";
import { parse as parseToml } from "smol-toml";
import { z } from "zod";
import { z } from "zod";
import { JwtIssuer } from "../../auth/jwt.ts";
import { purge } from "../../cache/routing.ts";
import { purge } from "../../cache/routing.ts";
import { AppName } from "../../common/index.ts";
import { NotFoundError, UserInputError } from "../../errors.ts";
import { NotFoundError, UserInputError } from "../../errors.ts";
import { MCPConnection } from "../../models/index.ts";
import { MCPConnection } from "../../models/index.ts";
import type { Database } from "../../storage/index.ts";
import type { Database } from "../../storage/index.ts";
@@ -24,7 +24,6 @@ import { bundler } from "./bundler.ts";
import { assertsDomainUniqueness } from "./custom-domains.ts";
import { assertsDomainUniqueness } from "./custom-domains.ts";
import { type DeployResult, deployToCloudflare } from "./deployment.ts";
import { type DeployResult, deployToCloudflare } from "./deployment.ts";
import type { WranglerConfig } from "./wrangler.ts";
import type { WranglerConfig } from "./wrangler.ts";
import { AppName } from "../../common/index.ts";


const SCRIPT_FILE_NAME = "script.mjs";
const SCRIPT_FILE_NAME = "script.mjs";
export const HOSTING_APPS_DOMAIN = ".deco.page";
export const HOSTING_APPS_DOMAIN = ".deco.page";
@@ -779,16 +778,7 @@ Important Notes:
        );
        );
      }
      }


      const keyPair =
      const issuer = await c.jwtIssuer();
        c.envVars.DECO_CHAT_API_JWT_PRIVATE_KEY &&
        c.envVars.DECO_CHAT_API_JWT_PUBLIC_KEY
          ? {
              public: c.envVars.DECO_CHAT_API_JWT_PUBLIC_KEY,
              private: c.envVars.DECO_CHAT_API_JWT_PRIVATE_KEY,
            }
          : undefined;
      const issuer = await JwtIssuer.forKeyPair(keyPair);
      const scope = wranglerConfig?.scope ?? c.workspace.slug;
      const scope = wranglerConfig?.scope ?? c.workspace.slug;
      const appName = AppName.build(scope, scriptSlug);
      const appName = AppName.build(scope, scriptSlug);


@@ -800,7 +790,7 @@ Important Notes:
      const decoEnvVars = {
      const decoEnvVars = {
        DECO_WORKSPACE: workspace,
        DECO_WORKSPACE: workspace,
        DECO_API_TOKEN: token,
        DECO_API_TOKEN: token,
        DECO_API_JWT_PUBLIC_KEY: keyPair?.public,
        DECO_API_JWT_PUBLIC_KEY: await issuer.publicKey(),
        DECO_APP_SLUG: scriptSlug,
        DECO_APP_SLUG: scriptSlug,
        DECO_APP_NAME: appName,
        DECO_APP_NAME: appName,
      };
      };
‎packages/sdk/src/mcp/sandbox/api.ts
+8
-520
Lines changed: 8 additions & 520 deletions
Large diffs are not rendered by default.
‎packages/sdk/src/mcp/sandbox/run.ts
+102
Lines changed: 102 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,102 @@
import { callFunction, inspect } from "@deco/cf-sandbox";
import { WorkflowState } from "../../workflows/workflow-runner.ts";
import { MCPClientStub, ProjectTools } from "../index.ts";
import { asEnv, evalCodeAndReturnDefaultHandle } from "./utils.ts";
import { MappingStepDefinition, ToolCallStepDefinition } from "./workflows.ts";
export async function runMapping(
  input: unknown,
  state: WorkflowState,
  step: MappingStepDefinition,
  client: MCPClientStub<ProjectTools>,
  runtimeId: string = "default",
): Promise<Rpc.Serializable<unknown>> {
  try {
    // Load and execute the mapping step function
    using stepEvaluation = await evalCodeAndReturnDefaultHandle(
      step.execute,
      runtimeId,
    );
    const {
      ctx: stepCtx,
      defaultHandle: stepDefaultHandle,
      guestConsole: stepConsole,
    } = stepEvaluation;
    // Create step context with WellKnownOptions
    const stepContext = {
      readWorkflowInput() {
        return input;
      },
      readStepResult(stepName: string) {
        if (!state.steps[stepName]) {
          throw new Error(`Step '${stepName}' has not been executed yet`);
        }
        return state.steps[stepName];
      },
      env: await asEnv(client),
    };
    // Call the mapping function
    const stepCallHandle = await callFunction(
      stepCtx,
      stepDefaultHandle,
      undefined,
      stepContext,
      {},
    );
    const result = stepCtx.dump(stepCtx.unwrapResult(stepCallHandle));
    // Log any console output from the step execution
    if (stepConsole.logs.length > 0) {
      console.log(`Mapping step '${step.name}' logs:`, stepConsole.logs);
    }
    return result as Rpc.Serializable<unknown>;
  } catch (error) {
    throw new Error(
      `Mapping step '${step.name}' execution failed: ${inspect(error)}`,
    );
  }
}
export async function runTool(
  input: unknown,
  step: ToolCallStepDefinition,
  client: MCPClientStub<ProjectTools>,
): Promise<Rpc.Serializable<unknown>> {
  try {
    // Find the integration connection
    const { items: integrations } = await client.INTEGRATIONS_LIST({});
    const integration = integrations.find(
      (item) => item.id === step.integration,
    );
    if (!integration) {
      throw new Error(`Integration '${step.integration}' not found`);
    }
    // Call the tool with the current input (could be workflow input or previous step result)
    const toolCallResult = await client.INTEGRATIONS_CALL_TOOL({
      connection: integration.connection,
      params: {
        name: step.tool_name,
        arguments: input as Record<string, unknown>,
      },
    });
    if (toolCallResult.isError || toolCallResult.error) {
      throw new Error(`Tool call failed: ${inspect(toolCallResult)}`);
    }
    const result = toolCallResult.structuredContent || toolCallResult.content;
    console.log(`Tool call '${step.tool_name}' completed successfully`);
    return result as Rpc.Serializable<unknown>;
  } catch (error) {
    throw new Error(
      `Tool step '${step.name}' execution failed: ${inspect(error)}`,
    );
  }
}
‎packages/sdk/src/mcp/sandbox/tools.ts
+364
Lines changed: 364 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,364 @@
import { callFunction, inspect } from "@deco/cf-sandbox";
import z from "zod";
import { assertWorkspaceResourceAccess, MCPClient } from "../index.ts";
import {
  asEnv,
  createTool,
  evalCodeAndReturnDefaultHandle,
  fileNameSlugify,
  processExecuteCode,
  toolNameSlugify,
  validate,
  validateExecuteCode,
} from "./utils.ts";
/**
 * Reads a tool definition from the workspace and inlines the function code
 * @param name - The name of the tool
 * @param client - The MCP client
 * @param branch - The branch to read from
 * @returns The tool definition with inlined function code or null if not found
 */
async function readTool(
  name: string,
  client: ReturnType<typeof MCPClient.forContext>,
  branch?: string,
): Promise<z.infer<typeof ToolDefinitionSchema> | null> {
  try {
    const toolFileName = fileNameSlugify(name);
    const toolPath = `/src/tools/${toolFileName}.json`;
    const result = await client.READ_FILE({
      branch,
      path: toolPath,
      format: "json",
    });
    const tool = result.content as z.infer<typeof ToolDefinitionSchema>;
    // Inline the tool function code
    const toolFunctionPath = tool.execute.replace("file://", "");
    const toolFunctionResult = await client.READ_FILE({
      branch,
      path: toolFunctionPath,
      format: "plainString",
    });
    return {
      name: tool.name,
      description: tool.description,
      inputSchema: tool.inputSchema,
      outputSchema: tool.outputSchema,
      execute: toolFunctionResult.content, // Inline the code in the execute field
    };
  } catch {
    return null;
  }
}
export const ToolDefinitionSchema = z.object({
  name: z.string().describe("The name of the tool"),
  description: z.string().describe("The description of the tool"),
  inputSchema: z
    .object({})
    .passthrough()
    .describe("The JSON schema of the input of the tool"),
  outputSchema: z
    .object({})
    .passthrough()
    .describe("The JSON schema of the output of the tool"),
  execute: z
    .string()
    .describe(
      "Either a file:// URL to an existing function file, or inline ES module code with default export function. If inline code is provided, it will be saved to /src/functions/{name}.ts",
    ),
});
const SANDBOX_CREATE_TOOL_DESCRIPTION = `Create a new tool in the sandbox with JSON Schema validation.
example, create a greeting tool pass the following arguments:
{
  name: "Greeting",
  description: "Greet the user",
  inputSchema: {
    "type": "object",
    "properties": {
      "name": { "type": "string" }
    },
    "required": ["name"]
  },
  outputSchema: {
    "type": "object",
    "properties": {
      "greeting": { "type": "string" }
    },
    "required": ["greeting"]
  },
  execute: "export default async function (input, ctx) { return { greeting: 'Hello, ' + input.name }; }"
}
The execute field can be either:
1. Inline ES module code (will be saved to /src/functions/{name}.ts)
2. A file:// URL to an existing function file
The execute should be a complete ES module with a default export function that has this exact signature:
async (input: typeof inputSchema, ctx: unknown): Promise<typeof outputSchema> => {}
Note: Both inputSchema and outputSchema must be valid JSON Schema objects. Input and output data will be validated against these schemas when the tool is created and executed.
Tools can call other tools using the env object from the ctx variable. For this, follow the format of the example below:
async (input: typeof inputSchema, ctx: unknown): Promise<typeof outputSchema> => {
  // some code
  const response = await ctx.env.<INTEGRATION_ID>.<TOOL_NAME>(<tool_arguments>);
  // some more code
  ...
}
INTEGRATION_ID is the ID of the integration that the tool belongs to (you can retrieve it with the INTEGRATIONS_LIST tool)
TOOL_NAME is the name of the tool to call from that integration (you can retrieve it with the INTEGRATIONS_LIST tool)
tool_arguments is the arguments to pass to the tool
`;
const upsertTool = createTool({
  name: "SANDBOX_UPSERT_TOOL",
  description: SANDBOX_CREATE_TOOL_DESCRIPTION,
  inputSchema: ToolDefinitionSchema,
  outputSchema: z.object({
    success: z.boolean().describe("Whether the tool was created successfully"),
    error: z
      .string()
      .optional()
      .describe("Compilation or validation error if any"),
  }),
  handler: async (
    { name, description, inputSchema, outputSchema, execute },
    c,
  ) => {
    await assertWorkspaceResourceAccess(c);
    const runtimeId = c.locator?.value ?? "default";
    const branch = c.locator?.branch;
    const client = MCPClient.forContext(c);
    const filename = fileNameSlugify(name);
    const toolName = toolNameSlugify(name);
    try {
      // Process the execute code
      const functionPath = `/src/functions/${filename}.ts`;
      const { functionCode, functionPath: finalFunctionPath } =
        await processExecuteCode(execute, functionPath, client, branch);
      // Validate the function code
      const validation = await validateExecuteCode(
        functionCode,
        runtimeId,
        "Tool",
      );
      if (!validation.success) {
        return {
          success: false,
          error: validation.error,
        };
      }
      // Store the tool metadata with file reference
      const toolPath = `/src/tools/${filename}.json`;
      const toolData = {
        name: toolName,
        description,
        inputSchema,
        outputSchema,
        execute: `file://${finalFunctionPath}`,
      };
      await client.PUT_FILE({
        branch,
        path: toolPath,
        content: JSON.stringify(toolData, null, 2),
      });
      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: inspect(error),
      };
    }
  },
});
const runTool = createTool({
  name: "SANDBOX_RUN_TOOL",
  description: "Run a tool in the sandbox",
  inputSchema: z.object({
    name: z.string().describe("The name of the tool"),
    input: z.object({}).passthrough().describe("The input of the tool"),
  }),
  outputSchema: z.object({
    result: z.any().optional().describe("The result of the tool execution"),
    error: z.any().optional().describe("Error if any"),
    logs: z
      .array(
        z.object({
          type: z.enum(["log", "warn", "error"]),
          content: z.string(),
        }),
      )
      .optional()
      .describe("Console logs from the execution"),
  }),
  handler: async ({ name, input }, c) => {
    await assertWorkspaceResourceAccess(c);
    const runtimeId = c.locator?.value ?? "default";
    const branch = c.locator?.branch;
    const client = MCPClient.forContext(c);
    const envPromise = asEnv(client);
    const tool = await readTool(name, client, branch);
    if (!tool) {
      return { error: "Tool not found" };
    }
    // Validate input against the tool's input schema
    const inputValidation = validate(input, tool.inputSchema);
    if (!inputValidation.valid) {
      return { error: `Input validation failed: ${inspect(inputValidation)}` };
    }
    // Use the inlined function code
    using evaluation = await evalCodeAndReturnDefaultHandle(
      tool.execute,
      runtimeId,
    );
    const { ctx, defaultHandle, guestConsole } = evaluation;
    try {
      // Call the function using the callFunction utility
      const callHandle = await callFunction(
        ctx,
        defaultHandle,
        undefined,
        input,
        { env: await envPromise },
      );
      const callResult = ctx.dump(ctx.unwrapResult(callHandle));
      // Validate output against the tool's output schema
      const outputValidation = validate(callResult, tool.outputSchema);
      if (!outputValidation.valid) {
        return {
          error: `Output validation failed: ${inspect(outputValidation)}`,
          logs: guestConsole.logs,
        };
      }
      return { result: callResult, logs: guestConsole.logs };
    } catch (error) {
      return { error: inspect(error), logs: guestConsole.logs };
    }
  },
});
const getTool = createTool({
  name: "SANDBOX_GET_TOOL",
  description: "Get a tool from the sandbox",
  inputSchema: z.object({ name: z.string().describe("The name of the tool") }),
  outputSchema: z.object({
    tool: ToolDefinitionSchema.nullable().describe(
      "The tool definition. Null if not found",
    ),
  }),
  handler: async ({ name }, c) => {
    await assertWorkspaceResourceAccess(c);
    const branch = c.locator?.branch;
    const client = MCPClient.forContext(c);
    const tool = await readTool(name, client, branch);
    return { tool: tool ?? null };
  },
});
const deleteTool = createTool({
  name: "SANDBOX_DELETE_TOOL",
  description: "Delete a tool in the sandbox",
  inputSchema: z.object({ name: z.string().describe("The name of the tool") }),
  outputSchema: z.object({
    message: z.string().describe("The message of the tool"),
  }),
  handler: async ({ name }, c) => {
    await assertWorkspaceResourceAccess(c);
    const branch = c.locator?.branch;
    try {
      const toolFileName = fileNameSlugify(name);
      const toolPath = `/src/tools/${toolFileName}.json`;
      const client = MCPClient.forContext(c);
      await client.DELETE_FILE({
        branch,
        path: toolPath,
      });
      return { message: "Tool deleted successfully" };
    } catch {
      return { message: "Tool deletion failed" };
    }
  },
});
const listTools = createTool({
  name: "SANDBOX_LIST_TOOLS",
  description: "List all tools in the sandbox",
  inputSchema: z.object({}),
  outputSchema: z.object({ tools: z.array(ToolDefinitionSchema) }),
  handler: async (_, c) => {
    await assertWorkspaceResourceAccess(c);
    const branch = c.locator?.branch;
    try {
      const client = MCPClient.forContext(c);
      const result = await client.LIST_FILES({
        branch,
        prefix: "/src/tools/",
      });
      const tools: z.infer<typeof ToolDefinitionSchema>[] = [];
      for (const filePath of Object.keys(result.files)) {
        if (filePath.endsWith(".json")) {
          // Extract tool name from file path (e.g., "/src/tools/greeting.json" -> "greeting")
          const toolName = filePath
            .replace("/src/tools/", "")
            .replace(".json", "");
          const tool = await readTool(toolName, client, branch);
          if (tool) {
            tools.push(tool);
          }
        }
      }
      return { tools };
    } catch {
      return { tools: [] };
    }
  },
});
export const SANDBOX_TOOLS = [
  upsertTool,
  getTool,
  deleteTool,
  runTool,
  listTools,
];
‎packages/sdk/src/mcp/sandbox/utils.ts
+219
Lines changed: 219 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,219 @@
import {
  createSandboxRuntime,
  inspect,
  installConsole,
  QuickJSHandle,
} from "@deco/cf-sandbox";
import { Validator } from "jsonschema";
import { z } from "zod";
import { createToolGroup, MCPClientStub } from "../context.ts";
import { slugify } from "../deconfig/api.ts";
import { ProjectTools } from "../index.ts";
import { ToolDefinitionSchema } from "./tools.ts";
// Utility functions for consistent naming
export const toolNameSlugify = (txt: string) => slugify(txt).toUpperCase();
export const fileNameSlugify = (txt: string) => slugify(txt).toLowerCase();
// Cache for compiled validators
const validatorCache = new Map<string, Validator>();
export function validate(instance: unknown, schema: Record<string, unknown>) {
  const schemaKey = JSON.stringify(schema);
  let validator = validatorCache.get(schemaKey);
  if (!validator) {
    validator = new Validator();
    validator.addSchema(schema);
    validatorCache.set(schemaKey, validator);
  }
  return validator.validate(instance, schema);
}
// Common tool group for sandbox
export const createTool = createToolGroup("Sandbox", {
  name: "Code Sandbox",
  description: "Run JavaScript code",
  icon: "https://assets.decocache.com/mcp/81d602bb-45e2-4361-b52a-23379520a34d/sandbox.png",
});
// Common function for evaluating code and returning default handle
export const evalCodeAndReturnDefaultHandle = async (
  code: string,
  runtimeId: string,
) => {
  // Create sandbox runtime to validate the function
  const runtime = await createSandboxRuntime(runtimeId, {
    memoryLimitBytes: 64 * 1024 * 1024, // 64MB
    stackSizeBytes: 1 << 20, // 1MB,
  });
  const ctx = runtime.newContext({ interruptAfterMs: 100 });
  // Install built-ins
  const guestConsole = installConsole(ctx);
  // Validate the function by evaluating it as an ES module
  const result = ctx.evalCode(code, "index.js", {
    strict: true,
    strip: true,
    type: "module",
  });
  let exportsHandle: QuickJSHandle;
  if (ctx.runtime.hasPendingJob()) {
    const promise = ctx.resolvePromise(ctx.unwrapResult(result));
    ctx.runtime.executePendingJobs();
    exportsHandle = ctx.unwrapResult(await promise);
  } else {
    exportsHandle = ctx.unwrapResult(result);
  }
  const defaultHandle = ctx.getProp(exportsHandle, "default");
  return {
    ctx,
    defaultHandle,
    guestConsole,
    [Symbol.dispose]: ctx.dispose.bind(ctx),
  };
};
// Transform current workspace as callable integration environment
export const asEnv = async (client: MCPClientStub<ProjectTools>) => {
  const { items } = await client.INTEGRATIONS_LIST({});
  const env: Record<
    string,
    Record<string, (args: unknown) => Promise<unknown>>
  > = {};
  for (const item of items) {
    // @ts-expect-error Somehow tools are not typed
    const tools = item.tools;
    if (!Array.isArray(tools)) {
      continue;
    }
    env[item.id] = Object.fromEntries(
      tools.map((tool: z.infer<typeof ToolDefinitionSchema>) => [
        tool.name,
        async (args: unknown) => {
          const inputValidation = validate(args, tool.inputSchema);
          if (!inputValidation.valid) {
            throw new Error(
              `Input validation failed: ${inspect(inputValidation)}`,
            );
          }
          const response = await client.INTEGRATIONS_CALL_TOOL({
            connection: item.connection,
            params: {
              name: tool.name,
              arguments: args as Record<string, unknown>,
            },
          });
          if (response.isError) {
            throw new Error(
              `Tool ${tool.name} returned an error: ${inspect(response)}`,
            );
          }
          if (response.structuredContent && tool.outputSchema) {
            const outputValidation = validate(
              response.structuredContent,
              tool.outputSchema,
            );
            if (!outputValidation.valid) {
              throw new Error(
                `Output validation failed: ${inspect(outputValidation)}`,
              );
            }
            return response.structuredContent;
          }
          return response.structuredContent || response.content;
        },
      ]),
    );
  }
  return env;
};
// Helper function to process execute code (inline or file URL)
export async function processExecuteCode(
  execute: string,
  filePath: string,
  client: MCPClientStub<ProjectTools>,
  branch?: string,
): Promise<{ functionCode: string; functionPath: string }> {
  const isFileUrl = execute.startsWith("file://");
  if (isFileUrl) {
    // It's already a file:// URL, use it as is
    const functionPath = execute.replace("file://", "");
    // Read the existing file to validate it
    const fileResult = await client.READ_FILE({
      branch,
      path: functionPath,
    });
    return {
      functionCode: fileResult.content,
      functionPath,
    };
  } else {
    // It's inline code, save it to a file
    const functionPath = filePath;
    const functionCode = execute;
    await client.PUT_FILE({
      branch,
      path: functionPath,
      content: functionCode,
    });
    return {
      functionCode,
      functionPath,
    };
  }
}
// Helper function to validate execute code
export async function validateExecuteCode(
  functionCode: string,
  runtimeId: string,
  name: string,
): Promise<{ success: boolean; error?: string }> {
  try {
    using evaluation = await evalCodeAndReturnDefaultHandle(
      functionCode,
      runtimeId,
    );
    const { ctx, defaultHandle } = evaluation;
    if (ctx.typeof(defaultHandle) !== "function") {
      return {
        success: false,
        error: `${name} must export a default function`,
      };
    }
    return { success: true };
  } catch (error) {
    return {
      success: false,
      error: `Validation error for ${name}: ${inspect(error)}`,
    };
  }
}
‎packages/sdk/src/mcp/sandbox/workflow-schemas.ts
+93
Lines changed: 93 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,93 @@
import z from "zod";
// Mapping step definition - transforms data between tool calls
export const MappingStepDefinitionSchema = z.object({
  name: z
    .string()
    .min(1)
    .describe("The unique name of the mapping step within the workflow"),
  description: z
    .string()
    .min(1)
    .describe("A clear description of what this mapping step does"),
  execute: z
    .string()
    .min(1)
    .describe(
      "ES module code that exports a default async function: (ctx: WellKnownOptions) => Promise<any>. Use ctx.readWorkflowInput() or ctx.readStepResult(stepName) to access data",
    ),
});
// Tool call step definition - executes a tool from an integration
export const ToolCallStepDefinitionSchema = z.object({
  name: z
    .string()
    .min(1)
    .describe("The unique name of the tool call step within the workflow"),
  description: z
    .string()
    .min(1)
    .describe("A clear description of what this tool call step does"),
  options: z
    .object({
      retry: z
        .number()
        .int()
        .min(0)
        .default(0)
        .nullish()
        .describe("Number of retry attempts for this step (default: 0)"),
      timeout: z
        .number()
        .positive()
        .default(Infinity)
        .nullish()
        .describe("Maximum execution time in milliseconds (default: Infinity)"),
    })
    .passthrough()
    .nullish()
    .describe(
      "Step configuration options. Extend this object with custom properties for business user configuration",
    ),
  tool_name: z.string().min(1).describe("The name of the tool to call"),
  integration: z
    .string()
    .min(1)
    .describe("The name of the integration that provides this tool"),
});
// Union of step types
export const WorkflowStepDefinitionSchema = z.object({
  type: z.enum(["mapping", "tool_call"]).describe("The type of step"),
  def: z
    .union([MappingStepDefinitionSchema, ToolCallStepDefinitionSchema])
    .describe("The step definition based on the type"),
});
export const WorkflowDefinitionSchema = z.object({
  name: z.string().min(1).describe("The unique name of the workflow"),
  description: z
    .string()
    .min(1)
    .describe("A comprehensive description of what this workflow accomplishes"),
  inputSchema: z
    .object({})
    .passthrough()
    .describe(
      "JSON Schema defining the workflow's input parameters and data structure",
    ),
  outputSchema: z
    .object({})
    .passthrough()
    .describe(
      "JSON Schema defining the workflow's final output after all steps complete",
    ),
  steps: z
    .array(WorkflowStepDefinitionSchema)
    .min(1)
    .describe(
      "Array of workflow steps that execute sequentially. The last step should be a mapping step that returns the final output.",
    ),
});
export type WorkflowDefinition = z.infer<typeof WorkflowDefinitionSchema>;
‎packages/sdk/src/mcp/sandbox/workflows.ts
+788
Lines changed: 788 additions & 0 deletions
Large diffs are not rendered by default.
‎packages/sdk/src/mcp/assertions.ts
+1
-14
Lines changed: 1 addition & 14 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -1,4 +1,3 @@
import { JwtIssuer } from "../auth/jwt.ts";
import type { AuthContext, Statement } from "../auth/policy.ts";
import type { AuthContext, Statement } from "../auth/policy.ts";
import { ForbiddenError, NotFoundError, UnauthorizedError } from "../errors.ts";
import { ForbiddenError, NotFoundError, UnauthorizedError } from "../errors.ts";
import { ProjectLocator } from "../locator.ts";
import { ProjectLocator } from "../locator.ts";
@@ -296,18 +295,6 @@ export const IntegrationSub = {
  },
  },
};
};


export const issuerFromContext = async (c: AppContext) => {
  const keyPair =
    c.envVars.DECO_CHAT_API_JWT_PRIVATE_KEY &&
    c.envVars.DECO_CHAT_API_JWT_PUBLIC_KEY
      ? {
          public: c.envVars.DECO_CHAT_API_JWT_PUBLIC_KEY,
          private: c.envVars.DECO_CHAT_API_JWT_PRIVATE_KEY,
        }
      : undefined;
  return await JwtIssuer.forKeyPair(keyPair);
};
async function grantAccessForProxy(
async function grantAccessForProxy(
  c: AppContext,
  c: AppContext,
): Promise<Disposable | undefined> {
): Promise<Disposable | undefined> {
@@ -323,7 +310,7 @@ async function grantAccessForProxy(
  }
  }


  const integrationId = c.user.integrationId;
  const integrationId = c.user.integrationId;
  const issuer = await issuerFromContext(c);
  const issuer = await c.jwtIssuer();
  const payload = await issuer.verify(c.proxyToken).catch(() => null);
  const payload = await issuer.verify(c.proxyToken).catch(() => null);
  if (payload && payload.sub === IntegrationSub.build(integrationId)) {
  if (payload && payload.sub === IntegrationSub.build(integrationId)) {
    return c.resourceAccess.grant();
    return c.resourceAccess.grant();
‎packages/sdk/src/mcp/context.ts
+76
-12
Lines changed: 76 additions & 12 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -5,23 +5,24 @@ import type { Client } from "@deco/sdk/storage";
import { createClient } from "@libsql/client/web";
import { createClient } from "@libsql/client/web";
import type { ToolAnnotations } from "@modelcontextprotocol/sdk/types.d.ts";
import type { ToolAnnotations } from "@modelcontextprotocol/sdk/types.d.ts";
import * as api from "@opentelemetry/api";
import * as api from "@opentelemetry/api";
import { createServerClient } from "@supabase/ssr";
import type { User as SupaUser } from "@supabase/supabase-js";
import type { User as SupaUser } from "@supabase/supabase-js";
import type Cloudflare from "cloudflare";
import { Cloudflare } from "cloudflare";
import { AsyncLocalStorage } from "node:async_hooks";
import { AsyncLocalStorage } from "node:async_hooks";
import { z } from "zod";
import { z } from "zod";
import type { JWTPayload } from "../auth/jwt.ts";
import { stubFor } from "../actors/index.ts";
import type {
import { JwtIssuer, JWTPayload } from "../auth/jwt.ts";
  AuthorizationClient,
import { AuthorizationClient, Policy, PolicyClient } from "../auth/policy.ts";
  Policy,
import { SUPABASE_URL } from "../constants.ts";
  PolicyClient,
} from "../auth/policy.ts";
import { type WellKnownMcpGroup, WellKnownMcpGroups } from "../crud/groups.ts";
import { type WellKnownMcpGroup, WellKnownMcpGroups } from "../crud/groups.ts";
import { ForbiddenError, type HttpError } from "../errors.ts";
import { ForbiddenError, type HttpError } from "../errors.ts";
import { lazy } from "../lazy.ts";
import { ProjectLocator } from "../locator.ts";
import { ProjectLocator } from "../locator.ts";
import { trace } from "../observability/index.ts";
import { trace } from "../observability/index.ts";
import { PosthogServerClient } from "../posthog.ts";
import { createPosthogServerClient, PosthogServerClient } from "../posthog.ts";
import { WorkflowRunnerProps } from "../workflows/workflow-runner.ts";
import { type WithTool } from "./assertions.ts";
import { type WithTool } from "./assertions.ts";
import type { ResourceAccess } from "./auth/index.ts";
import { type ResourceAccess } from "./auth/index.ts";
import { DatatabasesRunSqlInput, QueryResult } from "./databases/api.ts";
import { DatatabasesRunSqlInput, QueryResult } from "./databases/api.ts";
import { Blobs } from "./deconfig/blobs.ts";
import { Blobs } from "./deconfig/blobs.ts";
import { Branch } from "./deconfig/branch.ts";
import { Branch } from "./deconfig/branch.ts";
@@ -165,7 +166,7 @@ export type WorkspaceDO = DurableObjectNamespace<
  IWorkspaceDB & Rpc.DurableObjectBranded
  IWorkspaceDB & Rpc.DurableObjectBranded
>;
>;


export interface Vars {
export interface PrincipalExecutionContext {
  params: Record<string, string>;
  params: Record<string, string>;
  /**
  /**
   * @deprecated Use locator instead
   * @deprecated Use locator instead
@@ -189,11 +190,14 @@ export interface Vars {
  token?: string;
  token?: string;
  proxyToken?: string;
  proxyToken?: string;
  callerApp?: string;
  callerApp?: string;
  db: Client;
  isLocal?: boolean;
  user: Principal;
  user: Principal;
}
export interface Vars extends PrincipalExecutionContext {
  db: Client;
  policy: PolicyClient;
  policy: PolicyClient;
  authorization: AuthorizationClient;
  authorization: AuthorizationClient;
  isLocal?: boolean;
  cf: Cloudflare;
  cf: Cloudflare;
  walletBinding?: { fetch: typeof fetch };
  walletBinding?: { fetch: typeof fetch };
  immutableRes?: boolean;
  immutableRes?: boolean;
@@ -202,6 +206,8 @@ export interface Vars {
  // DECONFIG DurableObjects
  // DECONFIG DurableObjects
  branchDO: DurableObjectNamespace<Branch>;
  branchDO: DurableObjectNamespace<Branch>;
  blobsDO: DurableObjectNamespace<Blobs>;
  blobsDO: DurableObjectNamespace<Blobs>;
  workflowRunner: Workflow<WorkflowRunnerProps>;
  jwtIssuer: () => Promise<JwtIssuer>;
  posthog: PosthogServerClient;
  posthog: PosthogServerClient;
  stub: <
  stub: <
    Constructor extends ActorConstructor<Trigger> | ActorConstructor<AIAgent>,
    Constructor extends ActorConstructor<Trigger> | ActorConstructor<AIAgent>,
@@ -411,3 +417,61 @@ export const State = {
};
};


export * from "./stub.ts";
export * from "./stub.ts";
export type Bindings = EnvVars & {
  WALLET: Service;
  DECO_CHAT_APP_ORIGIN?: string;
  WORKSPACE_DB: DurableObjectNamespace<IWorkspaceDB & Rpc.DurableObjectBranded>;
  // DECONFIG DurableObjects
  BRANCH: DurableObjectNamespace<Branch>;
  BLOBS: DurableObjectNamespace<Blobs>;
  WORKFLOW_RUNNER: Workflow<WorkflowRunnerProps>;
  PROD_DISPATCHER: {
    get: <TOutbound extends Record<string, unknown> = Record<string, unknown>>(
      script: string,
      ctx?: Record<string, unknown>,
      metadata?: { outbound?: TOutbound },
    ) => { fetch: typeof fetch };
  };
  KB_FILE_PROCESSOR?: Workflow;
};
export type BindingsContext = Omit<AppContext, keyof PrincipalExecutionContext>;
export const toBindingsContext = (bindings: Bindings): BindingsContext => {
  const db = createServerClient(SUPABASE_URL, bindings.SUPABASE_SERVER_TOKEN, {
    cookies: { getAll: () => [] },
  });
  const policy = PolicyClient.getInstance(db);
  const authorization = new AuthorizationClient(policy);
  return {
    blobsDO: bindings.BLOBS,
    branchDO: bindings.BRANCH,
    envVars: bindings,
    workflowRunner: bindings.WORKFLOW_RUNNER,
    workspaceDO: bindings.WORKSPACE_DB,
    kbFileProcessor: bindings.KB_FILE_PROCESSOR,
    walletBinding: bindings.WALLET,
    policy,
    authorization,
    db,
    cf: new Cloudflare({ apiToken: bindings.CF_API_TOKEN }),
    posthog: createPosthogServerClient({
      apiKey: bindings.POSTHOG_API_KEY,
      apiHost: bindings.POSTHOG_API_HOST,
    }),
    stub: stubFor(bindings),
    jwtIssuer: lazy(() => {
      const keyPair =
        bindings.DECO_CHAT_API_JWT_PRIVATE_KEY &&
        bindings.DECO_CHAT_API_JWT_PUBLIC_KEY
          ? {
              public: bindings.DECO_CHAT_API_JWT_PUBLIC_KEY,
              private: bindings.DECO_CHAT_API_JWT_PRIVATE_KEY,
            }
          : undefined;
      return JwtIssuer.forKeyPair(keyPair);
    }),
  };
};
‎packages/sdk/src/mcp/index.ts
+2
-2
Lines changed: 2 additions & 2 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -24,7 +24,7 @@ import * as oauthAPI from "./oauth/api.ts";
import * as profilesAPI from "./profiles/api.ts";
import * as profilesAPI from "./profiles/api.ts";
import * as promptsAPI from "./prompts/api.ts";
import * as promptsAPI from "./prompts/api.ts";
import * as registryAPI from "./registry/api.ts";
import * as registryAPI from "./registry/api.ts";
import { SANDBOX_TOOLS } from "./sandbox/api.ts";
import { SANDBOX_TOOLS_AND_WORKFLOWS } from "./sandbox/api.ts";
import type { CreateStubHandlerOptions, MCPClientStub } from "./stub.ts";
import type { CreateStubHandlerOptions, MCPClientStub } from "./stub.ts";
import * as teamsAPI from "./teams/api.ts";
import * as teamsAPI from "./teams/api.ts";
import * as threadsAPI from "./threads/api.ts";
import * as threadsAPI from "./threads/api.ts";
@@ -209,7 +209,7 @@ export const PROJECT_TOOLS = [
  // DECONFIG tools
  // DECONFIG tools
  ...deconfigAPI.DECONFIG_TOOLS,
  ...deconfigAPI.DECONFIG_TOOLS,
  // SANDBOX tools
  // SANDBOX tools
  ...SANDBOX_TOOLS,
  ...SANDBOX_TOOLS_AND_WORKFLOWS,
] as const;
] as const;


export const AGENT_TOOLS = [
export const AGENT_TOOLS = [
‎packages/sdk/src/workflows/index.ts
+1
Lines changed: 1 addition & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -1 +1,2 @@
export * from "./file-processor/batch-file-processor.ts";
export * from "./file-processor/batch-file-processor.ts";
export * from "./workflow-runner.ts";
‎packages/sdk/src/workflows/workflow-runner.ts
+154
Lines changed: 154 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,154 @@
import {
  WorkflowStep as CloudflareWorkflowStep,
  WorkflowEntrypoint,
  WorkflowEvent,
  WorkflowStepConfig,
} from "cloudflare:workers";
import {
  AppContext,
  PrincipalExecutionContext,
  toBindingsContext,
  type Bindings,
  type BindingsContext,
} from "../mcp/context.ts";
import {
  assertHasWorkspace,
  createResourceAccess,
  MCPClient,
} from "../mcp/index.ts";
import { runMapping, runTool } from "../mcp/sandbox/run.ts";
import type {
  MappingStepDefinition,
  ToolCallStepDefinition,
  WorkflowStepDefinition,
} from "../mcp/sandbox/workflows.ts";
export type { WorkflowStepConfig };
export type Runnable = (
  input: unknown,
  state: WorkflowState,
) => Promise<Rpc.Serializable<unknown>>;
export interface WorkflowState<T = unknown> {
  input: T;
  steps: Record<string, unknown>;
  sleep: (name: string, duration: number) => Promise<void>;
}
export interface WorkflowStep {
  name: string;
  config?: WorkflowStepConfig;
  fn: Runnable;
}
export interface WorkflowRunnerProps<T = unknown> {
  input: T;
  name: string;
  steps: WorkflowStepDefinition[]; // Changed from WorkflowStep[] to WorkflowStepDefinition[]
  state?: Record<string, unknown>;
  context: Pick<PrincipalExecutionContext, "workspace" | "locator">;
}
export class WorkflowRunner extends WorkflowEntrypoint<Bindings> {
  protected bindingsCtx: BindingsContext;
  constructor(ctx: ExecutionContext, env: Bindings) {
    super(ctx, env);
    this.bindingsCtx = toBindingsContext(env);
  }
  async principalContextFromRunnerProps(
    props: WorkflowRunnerProps,
  ): Promise<PrincipalExecutionContext> {
    assertHasWorkspace(props.context);
    const resourceAccess = createResourceAccess();
    resourceAccess.grant(); // all calls are authorized by default
    const issuer = await this.bindingsCtx.jwtIssuer();
    const token = await issuer.issue({
      sub: `workflow:${props.name}:${props.context.workspace.value}`,
    });
    return {
      params: {},
      resourceAccess,
      workspace: props.context.workspace,
      locator: props.context.locator,
      token,
      user: issuer.decode(token),
    };
  }
  /**
   * Convert WorkflowStepDefinition to WorkflowStep with actual runnable functions
   */
  private convertStepDefinitionToStep(
    stepDef: WorkflowStepDefinition,
    appContext: AppContext,
    runtimeId: string,
  ): WorkflowStep {
    const client = MCPClient.forContext(appContext);
    let runnable: Runnable;
    if (stepDef.type === "mapping") {
      runnable = (input, state) =>
        runMapping(
          input,
          state,
          stepDef.def as MappingStepDefinition,
          client,
          runtimeId,
        );
    } else if (stepDef.type === "tool_call") {
      runnable = (input) =>
        runTool(input, stepDef.def as ToolCallStepDefinition, client);
    } else {
      throw new Error(
        `Invalid step type: ${(stepDef as unknown as { type: string }).type}`,
      );
    }
    return {
      name: stepDef.def.name,
      config:
        stepDef.type === "tool_call" && "options" in stepDef.def
          ? (stepDef.def.options ?? {})
          : {},
      fn: runnable,
    };
  }
  override async run(
    event: Readonly<WorkflowEvent<WorkflowRunnerProps>>,
    cfStep: CloudflareWorkflowStep,
  ) {
    const appContext: AppContext = {
      ...(await this.principalContextFromRunnerProps(event.payload)),
      ...this.bindingsCtx,
    };
    const { input, steps: stepDefinitions, state } = event.payload;
    const runtimeId = appContext.locator?.value ?? "default";
    // Convert step definitions to actual runnable steps
    const steps = stepDefinitions.map((stepDef) =>
      this.convertStepDefinitionToStep(stepDef, appContext, runtimeId),
    );
    const workflowState = {
      input,
      steps: state ?? {},
    };
    let prev = input;
    for (const step of steps) {
      prev =
        state?.[step.name] ??
        (await cfStep.do(step.name, step.config ?? {}, async () => {
          const runResult = await step.fn(prev, {
            ...workflowState,
            sleep: (name, duration) =>
              cfStep.sleep(`${step.name}-${name}`, duration),
          });
          return runResult as Rpc.Serializable<unknown>;
        }));
      workflowState.steps[step.name] = prev;
    }
    return prev;
  }
}
‎packages/sdk/src/index.ts
+6
Lines changed: 6 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -17,6 +17,7 @@ export * from "./crud/wallet.ts";
export * from "./crud/workflows.ts";
export * from "./crud/workflows.ts";
export * from "./crud/roles.ts";
export * from "./crud/roles.ts";
export * from "./crud/registry.ts";
export * from "./crud/registry.ts";
export * from "./crud/sandbox-workflows.ts";


export * from "./hooks/agent.ts";
export * from "./hooks/agent.ts";
export * from "./hooks/audit.ts";
export * from "./hooks/audit.ts";
@@ -33,8 +34,13 @@ export * from "./hooks/tools.ts";
export * from "./hooks/trigger.ts";
export * from "./hooks/trigger.ts";
export * from "./hooks/wallet.ts";
export * from "./hooks/wallet.ts";
export * from "./hooks/workflows.ts";
export * from "./hooks/workflows.ts";
export * from "./hooks/workflow-builder.ts";
export * from "./hooks/roles.ts";
export * from "./hooks/roles.ts";
export * from "./hooks/registry.ts";
export * from "./hooks/registry.ts";
export * from "./hooks/sandbox-workflows.ts";
// Schemas for sandbox workflows (exported for consumers like the web app)
export * from "./mcp/sandbox/workflow-schemas.ts";


export * from "./models/agent.ts";
export * from "./models/agent.ts";
export * from "./models/mcp.ts";
export * from "./models/mcp.ts";
‎packages/sdk/src/lazy.ts
+9
Lines changed: 9 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,9 @@
export const lazy = <T>(fn: () => Promise<T>) => {
  let value: Promise<T> | undefined;
  return async () => {
    if (!value) {
      value = fn();
    }
    return await value;
  };
};
‎supabase/migrations/20250915134951_workflow.sql
+4
Lines changed: 4 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,4 @@
-- Add SANDBOX_UPSERT_WORKFLOW to the manage_sandbox policy
UPDATE "public"."policies" 
SET "statements" = array_append("statements", '{"effect":"allow","resource":"SANDBOX_UPSERT_WORKFLOW"}'::jsonb)
WHERE "id" = '73' AND "name" = 'manage_sandbox';
‎supabase/migrations/20250915151844_workflow-crud.sql
+26
Lines changed: 26 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,26 @@
-- SANDBOX WORKFLOW policies for viewing and managing workflow tools
INSERT INTO "public"."policies" ("id", "created_at", "name", "statements", "description", "team_id") VALUES 
('74', '2025-09-15 15:18:44.000000+00', 'view_sandbox_workflows', ARRAY[
    '{"effect":"allow","resource":"SANDBOX_GET_WORKFLOW"}'::jsonb,
    '{"effect":"allow","resource":"SANDBOX_LIST_WORKFLOWS"}'::jsonb,
    '{"effect":"allow","resource":"SANDBOX_RUN_WORKFLOW"}'::jsonb
], 'Allow users to view, list, and run sandbox workflows', null),
('75', '2025-09-15 15:18:44.000000+00', 'manage_sandbox_workflows', ARRAY[
    '{"effect":"allow","resource":"SANDBOX_UPSERT_WORKFLOW"}'::jsonb,
    '{"effect":"allow","resource":"SANDBOX_DELETE_WORKFLOW"}'::jsonb
], 'Allow users to create, update, and delete sandbox workflows', null)
ON CONFLICT (id) DO NOTHING;
-- Associate SANDBOX WORKFLOW view policy with all roles (1=owner, 3=member, 4=admin)
INSERT INTO "public"."role_policies" ("id", "created_at", "role_id", "policy_id") VALUES 
('391', '2025-09-15 15:18:44.000000+00', '1', '74'),
('392', '2025-09-15 15:18:44.000000+00', '3', '74'),
('393', '2025-09-15 15:18:44.000000+00', '4', '74')
ON CONFLICT (id) DO NOTHING;
-- Associate SANDBOX WORKFLOW management policy with owner (1) and admin (4)
-- SANDBOX WORKFLOW operations can execute arbitrary code and affect system behavior, requiring elevated permissions
INSERT INTO "public"."role_policies" ("id", "created_at", "role_id", "policy_id") VALUES 
('394', '2025-09-15 15:18:44.000000+00', '1', '75'),
('395', '2025-09-15 15:18:44.000000+00', '4', '75')
ON CONFLICT (id) DO NOTHING;
‎supabase/migrations/20250915155631_workflow-async.sql
+13
Lines changed: 13 additions & 0 deletions
Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,13 @@
-- SANDBOX WORKFLOW async execution policies - add missing async workflow tools to existing policies
-- Add async workflow execution tools to the existing view_sandbox_workflows policy
UPDATE "public"."policies" 
SET "statements" = array_append("statements", '{"effect":"allow","resource":"SANDBOX_START_WORKFLOW"}'::jsonb)
WHERE "id" = '74' AND "name" = 'view_sandbox_workflows';
UPDATE "public"."policies" 
SET "statements" = array_append("statements", '{"effect":"allow","resource":"SANDBOX_GET_WORKFLOW_STATUS"}'::jsonb)
WHERE "id" = '74' AND "name" = 'view_sandbox_workflows';
UPDATE "public"."policies" 
SET "statements" = array_append("statements", '{"effect":"allow","resource":"SANDBOX_REPLAY_WORKFLOW_FROM_STEP"}'::jsonb)
WHERE "id" = '74' AND "name" = 'view_sandbox_workflows';
‎workflow.md
+907
Lines changed: 907 additions & 0 deletions


Original file line number	Original file line	Diff line number	Diff line change
@@ -0,0 +1,907 @@
# Workflow Builder UI Feature
## Overview
This document outlines the implementation of a visual workflow builder UI that allows users to create, edit, and execute workflows using a drag-and-drop interface powered by React Flow. The UI will provide an intuitive way to build complex workflows by connecting tools and mappers in a visual canvas.
## Feature Description
The Workflow Builder is a visual interface accessible via the URL pattern `/:org/:project/workflows/:workflow-name` that enables users to:
1. **Edit Existing Workflows**: Load and modify existing workflow definitions
2. **Create Workflows Visually**: Drag and drop tools and mappers onto a canvas
3. **Connect Components**: Link tools and mappers to create execution flows
4. **Auto-Generate Mappers**: Automatically insert mapper nodes when connecting tools
5. **Generate Workflow Definitions**: Convert visual workflows into executable workflow definitions
6. **Execute Workflows**: Run workflows with proper input validation and execution tracking
7. **Replay Steps**: Rerun individual nodes or steps during workflow execution
**Note**: This is an early-stage feature accessible only by typing the URL directly in the browser address bar.
## Technical Architecture
### Routing Structure
The workflow builder will be accessible via the following URL pattern:
```
/:org/:project/workflows/:workflow-name
```
**Example URLs:**
- `/acme-corp/my-project/workflows/process-user-data`
- `/my-org/ecommerce/workflows/order-fulfillment`
- `/company/analytics/workflows/data-pipeline`
**Route Parameters:**
- `org`: Organization identifier
- `project`: Project identifier  
- `workflow-name`: Name of the workflow to edit
### Core Technologies
- **React Flow**: For the visual workflow canvas and node management
- **React JSON Schema Form (RJSF) with Shadcn**: For dynamic form generation based on JSON schemas
- **Zod**: For schema validation
- **TypeScript**: For type safety throughout the implementation
### Key Components
#### 1. WorkflowBuilderPage
The main page component that handles routing and workflow loading.
```typescript
interface WorkflowBuilderPageProps {
  org: string;
  project: string;
  workflowName: string;
}
// Route component
function WorkflowBuilderPage({ org, project, workflowName }: WorkflowBuilderPageProps) {
  const { workflow, isLoading, error } = useWorkflow(org, project, workflowName);
  
  if (isLoading) return <WorkflowLoadingSkeleton />;
  if (error) return <WorkflowErrorState error={error} />;
  if (!workflow) return <WorkflowNotFoundState workflowName={workflowName} />;
  
  return <WorkflowCanvas workflow={workflow} />;
}
```
#### 2. WorkflowCanvas
The main canvas component that renders the React Flow interface.
```typescript
interface WorkflowCanvasProps {
  workflow: WorkflowDefinition;
  onWorkflowChange: (workflow: WorkflowDefinition) => void;
  isDirty: boolean;
  onDirtyChange: (dirty: boolean) => void;
}
```
#### 3. Node Types
Two primary node types for the workflow:
**Tool Node**
```typescript
interface ToolNodeData {
  type: 'tool_call';
  name: string;
  description: string;
  tool_name: string;
  integration: string;
  options?: Record<string, any>;
}
```
**Mapper Node**
```typescript
interface MapperNodeData {
  type: 'mapping';
  name: string;
  description: string;
  execute: string; // Generated or user-defined code
  outputSchema: Record<string, any>;
}
```
#### 4. Workflow State Management
```typescript
interface WorkflowBuilderState {
  nodes: Node[];
  edges: Edge[];
  isDirty: boolean;
  currentWorkflow?: WorkflowDefinition;
  executionState?: {
    runId: string;
    status: 'pending' | 'running' | 'completed' | 'failed';
    stepResults: Record<string, any>;
  };
}
```
#### 5. Form Integration with RJSF
The workflow builder will use React JSON Schema Form (RJSF) with Shadcn components for dynamic form generation:
```typescript
interface WorkflowFormProps {
  schema: Record<string, any>; // JSON Schema for form generation
  onSubmit: (data: Record<string, any>) => void;
  initialData?: Record<string, any>;
  uiSchema?: Record<string, any>; // Custom UI configuration
}
```
**Benefits of RJSF with Shadcn:**
- **Dynamic Form Generation**: Automatically generates forms from JSON schemas
- **Consistent UI**: Uses Shadcn components for consistent design system
- **Validation**: Built-in validation based on JSON Schema
- **Customization**: Flexible UI schema for custom form layouts
- **Type Safety**: Full TypeScript support with proper typing
## Implementation Details
### 1. Workflow Loading and Initialization
#### Route Handler
```typescript
// In the main router configuration
{
  path: '/:org/:project/workflows/:workflowName',
  element: <WorkflowBuilderPage />,
  loader: async ({ params }) => {
    const { org, project, workflowName } = params;
    return { org, project, workflowName };
  }
}
```
#### Workflow Loading Hook
```typescript
function useWorkflow(org: string, project: string, workflowName: string) {
  const [workflow, setWorkflow] = useState<WorkflowDefinition | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  useEffect(() => {
    async function loadWorkflow() {
      try {
        setIsLoading(true);
        setError(null);
        
        // Call SANDBOX_GET_WORKFLOW to load existing workflow
        const result = await client.SANDBOX_GET_WORKFLOW({ name: workflowName });
        
        if (result.workflow) {
          setWorkflow(result.workflow);
        } else {
          // Workflow doesn't exist - create a new one
          setWorkflow(createEmptyWorkflow(workflowName));
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load workflow');
      } finally {
        setIsLoading(false);
      }
    }
    loadWorkflow();
  }, [org, project, workflowName]);
  return { workflow, isLoading, error };
}
function createEmptyWorkflow(name: string): WorkflowDefinition {
  return {
    name,
    description: `Workflow: ${name}`,
    inputSchema: {
      type: 'object',
      properties: {},
      required: []
    },
    outputSchema: {
      type: 'object',
      properties: {},
      required: []
    },
    steps: []
  };
}
```
#### Canvas Initialization
```typescript
function WorkflowCanvas({ workflow }: WorkflowCanvasProps) {
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const [isDirty, setIsDirty] = useState(false);
  // Convert workflow definition to React Flow nodes and edges
  useEffect(() => {
    const { nodes: flowNodes, edges: flowEdges } = convertWorkflowToFlow(workflow);
    setNodes(flowNodes);
    setEdges(flowEdges);
    setIsDirty(false);
  }, [workflow]);
  // Convert React Flow nodes and edges back to workflow definition
  const convertFlowToWorkflow = useCallback(() => {
    return convertFlowToWorkflowDefinition(nodes, edges, workflow);
  }, [nodes, edges, workflow]);
  return (
    <div className="h-screen w-full">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={handleNodesChange}
        onEdgesChange={handleEdgesChange}
        onConnect={handleConnect}
        nodeTypes={nodeTypes}
      >
        <WorkflowToolbar 
          isDirty={isDirty}
          onGenerate={handleGenerate}
          onRun={handleRun}
        />
        <WorkflowPalette />
      </ReactFlow>
    </div>
  );
}
```
### 2. Canvas Actions
#### Add Tool Action
- **Trigger**: Tool palette or context menu
- **Behavior**: 
  - Opens existing "Add Integration" dialog (reused from agent creation)
  - User selects integration and tool from the familiar interface
  - Creates new tool node on canvas with selected tool configuration
  - Sets node position based on mouse coordinates
  - Marks canvas as dirty
#### Add Mapper Action
- **Trigger**: Tool palette or context menu
- **Behavior**:
  - Creates new mapper node on canvas
  - Opens mapper configuration dialog
  - Sets node position based on mouse coordinates
  - Marks canvas as dirty
### 2. Auto-Mapper Generation
**Always insert a mapper between tools** - this ensures data transformation is explicit and configurable.
When a user connects two tools directly:
```typescript
function handleEdgeConnect(connection: Connection) {
  const sourceNode = nodes.find(n => n.id === connection.source);
  const targetNode = nodes.find(n => n.id === connection.target);
  
  if (sourceNode?.type === 'tool' && targetNode?.type === 'tool') {
    // Remove direct connection
    const newEdges = edges.filter(e => 
      !(e.source === connection.source && e.target === connection.target)
    );
    
    // Create mapper node
    const mapperNode = createMapperNode({
      name: `map-${sourceNode.data.name}-to-${targetNode.data.name}`,
      description: "This mapper transforms the output from the previous step to match the input requirements of the next step",
      execute: generateDefaultMapperCode(sourceNode, targetNode)
    });
    
    // Create new edges: source -> mapper -> target
    const newMapperEdges = [
      { source: connection.source, target: mapperNode.id },
      { source: mapperNode.id, target: connection.target }
    ];
    
    setNodes([...nodes, mapperNode]);
    setEdges([...newEdges, ...newMapperEdges]);
  }
}
function generateDefaultMapperCode(sourceNode: Node, targetNode: Node): string {
  // If data types match, generate identity function: x => x
  // If data types don't match, generate transformation logic
  const sourceOutput = getToolOutputSchema(sourceNode.data.tool_name);
  const targetInput = getToolInputSchema(targetNode.data.tool_name);
  
  if (schemasMatch(sourceOutput, targetInput)) {
    return `export default async function(ctx) {
  const input = await ctx.readStepResult('${sourceNode.data.name}');
  return input; // Identity transformation
}`;
  } else {
    return `export default async function(ctx) {
  const input = await ctx.readStepResult('${sourceNode.data.name}');
  // TODO: Transform input to match target requirements
  // Source schema: ${JSON.stringify(sourceOutput)}
  // Target schema: ${JSON.stringify(targetInput)}
  return input;
}`;
  }
}
```
### 3. Generate Button Behavior
#### When Canvas is Dirty
- **Button Text**: "Generate Workflow"
- **Action**: Calls AI GenerateObject function with workflow schema
- **Process**:
  1. Validates canvas structure (no orphaned nodes, proper flow)
  2. Converts nodes/edges to workflow definition
  3. Calls `MCPClient['AI_GATEWAY'].AI_GENERATE_OBJECT` with workflow schema and prompt
  4. Uses AI to enhance/complete the workflow definition
  5. Calls `SANDBOX_UPSERT_WORKFLOW` with the AI-generated workflow
  6. Marks canvas as clean
  7. Updates button to "Run Workflow"
#### When Canvas is Clean
- **Button Text**: "Run Workflow"
- **Action**: Opens input form and executes workflow
- **Process**:
  1. Shows RJSF-generated input form based on workflow's input schema
  2. Validates input against workflow's input schema using RJSF validation
  3. Calls `SANDBOX_START_WORKFLOW`
  4. Shows execution progress and results
### 4. Workflow Execution UI
#### Execution States
```typescript
interface ExecutionState {
  runId: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  currentStep?: string;
  stepResults: Record<string, any>;
  logs: Array<{ type: 'log' | 'warn' | 'error'; content: string }>;
}
```
#### Visual Feedback
- **Node States**: Different colors/styles for pending, running, completed, failed
- **Progress Indicator**: Shows current execution step
- **Logs Panel**: Displays execution logs in real-time
- **Results Panel**: Shows step results and final output
#### Replay Functionality
- **Individual Node Replay**: Right-click on completed nodes to rerun
- **Step Replay**: Use `SANDBOX_REPLAY_WORKFLOW_FROM_STEP` for partial execution
- **Visual Indicators**: Show which nodes can be replayed
## Required Code Changes
### 1. New Components to Create
#### `/apps/web/src/pages/workflow-builder/`
```
workflow-builder/
├── WorkflowBuilderPage.tsx     # Main page component with routing
├── WorkflowLoadingSkeleton.tsx # Loading state component
├── WorkflowErrorState.tsx      # Error state component
└── WorkflowNotFoundState.tsx   # Not found state component
```
#### `/apps/web/src/components/workflow-builder/`
```
workflow-builder/
├── WorkflowCanvas.tsx          # Main canvas component
├── WorkflowToolbar.tsx         # Toolbar with actions
├── WorkflowPalette.tsx         # Tool/mapper selection palette
├── WorkflowExecutionPanel.tsx  # Execution status and logs
├── WorkflowInputForm.tsx       # RJSF-based input schema form
├── nodes/
│   ├── ToolNode.tsx           # Tool node component
│   ├── MapperNode.tsx         # Mapper node component
│   └── InputNode.tsx          # Input node component
├── dialogs/
│   ├── ToolConfigDialog.tsx   # Tool configuration (RJSF-based)
│   ├── MapperConfigDialog.tsx # Mapper configuration (RJSF-based)
│   └── WorkflowSettingsDialog.tsx # Workflow metadata (RJSF-based)
└── hooks/
    ├── useWorkflow.ts         # Workflow loading and management
    ├── useWorkflowBuilder.ts  # Main workflow state management
    ├── useWorkflowExecution.ts # Execution state management
    └── useWorkflowValidation.ts # Canvas validation
```
#### Reused Components
- **Integration Selection Dialog**: Reuse existing "Add Integration" dialog from agent creation
- **Tool Selection Interface**: Leverage existing tool discovery and selection UI
### 2. Schema Integration
#### Workflow Definition Conversion
```typescript
function convertCanvasToWorkflow(
  nodes: Node[],
  edges: Edge[],
  inputSchema: Record<string, any>,
  outputSchema: Record<string, any>
): WorkflowDefinition {
  // Convert nodes to workflow steps
  const steps = nodes
    .filter(node => node.type !== 'input')
    .map(node => {
      if (node.data.type === 'tool_call') {
        return {
          type: 'tool_call' as const,
          def: {
            name: node.data.name,
            description: node.data.description,
            options: node.data.options,
            tool_name: node.data.tool_name,
            integration: node.data.integration
          }
        };
      } else if (node.data.type === 'mapping') {
        return {
          type: 'mapping' as const,
          def: {
            name: node.data.name,
            description: node.data.description,
            execute: node.data.execute
          }
        };
      }
    });
  return {
    name: workflowName,
    description: workflowDescription,
    inputSchema,
    outputSchema,
    steps
  };
}
```
### 3. AI Integration
#### Generate Workflow Function
```typescript
async function generateWorkflow(
  canvasData: { nodes: Node[]; edges: Edge[] },
  userPrompt?: string
) {
  const workflowDefinition = convertCanvasToWorkflow(canvasData);
  
  // Use AI to enhance or generate the workflow
  const enhancedWorkflow = await MCPClient['AI_GATEWAY'].AI_GENERATE_OBJECT({
    schema: WorkflowDefinitionSchema,
    prompt: userPrompt || `Generate a complete workflow definition from this canvas structure. 
    
    Current workflow structure:
    - Name: ${workflowDefinition.name}
    - Description: ${workflowDefinition.description}
    - Steps: ${workflowDefinition.steps.length} steps
    - Input Schema: ${JSON.stringify(workflowDefinition.inputSchema)}
    - Output Schema: ${JSON.stringify(workflowDefinition.outputSchema)}
    
    Please enhance this workflow definition to be complete and executable, following the same patterns as the sandbox workflow creation tool.`,
    data: workflowDefinition
  });
  
  return enhancedWorkflow;
}
```
### 4. State Management Updates
#### Workflow Builder Context
```typescript
interface WorkflowBuilderContextType {
  // Canvas state
  nodes: Node[];
  edges: Edge[];
  isDirty: boolean;
  
  // Workflow state
  currentWorkflow?: WorkflowDefinition;
  executionState?: ExecutionState;
  
  // Actions
  addNode: (node: Node) => void;
  updateNode: (nodeId: string, updates: Partial<Node>) => void;
  deleteNode: (nodeId: string) => void;
  addEdge: (edge: Edge) => void;
  deleteEdge: (edgeId: string) => void;
  
  // Workflow actions
  generateWorkflow: () => Promise<void>;
  runWorkflow: (input: Record<string, any>) => Promise<void>;
  replayStep: (stepName: string) => Promise<void>;
  
  // UI state
  selectedNode?: string;
  showInputForm: boolean;
  setShowInputForm: (show: boolean) => void;
}
```
## User Experience Flow
### 1. Accessing and Editing a Workflow
1. User types URL `/:org/:project/workflows/:workflow-name` in browser address bar
2. System loads existing workflow or creates empty workflow if not found
3. User sees visual representation of workflow on canvas
4. User clicks "Add Tool" to open familiar "Add Integration" dialog
5. User selects integration and tool from existing interface
6. User connects tools (always auto-generates mappers between tools)
7. User configures mapper functions if needed (identity function `x => x` for matching types)
8. User clicks "Generate Workflow" to save changes
9. AI generates complete workflow definition using MCPClient['AI_GATEWAY'].AI_GENERATE_OBJECT
10. Canvas becomes "clean" state
### 2. Running a Workflow
1. User clicks "Run Workflow" (when canvas is clean)
2. RJSF-generated input form appears based on workflow's input schema
3. User fills required input fields with automatic validation
4. Workflow execution starts
5. Visual feedback shows progress through nodes
6. Results displayed in execution panel
### 3. Debugging/Replaying
1. User can right-click on any completed node
2. "Replay from here" option appears
3. Workflow re-executes from that step
4. Visual indicators show replay progress
## RJSF Integration Details
### 1. Package Installation
```bash
cd apps/web
bun add @rjsf/shadcn
```
### 2. RJSF Configuration
The workflow builder will use RJSF with Shadcn components for all form interactions:
```typescript
import { Form } from '@rjsf/shadcn';
import { RJSFSchema, UiSchema } from '@rjsf/utils';
// Workflow input form
function WorkflowInputForm({ 
  schema, 
  onSubmit, 
  initialData 
}: WorkflowFormProps) {
  const uiSchema: UiSchema = {
    'ui:submitButtonOptions': {
      submitText: 'Run Workflow',
      norender: false,
      props: {
        className: 'w-full'
      }
    }
  };
  return (
    <Form
      schema={schema}
      uiSchema={uiSchema}
      formData={initialData}
      onSubmit={onSubmit}
      validator={validator}
    />
  );
}
// Tool configuration form
function ToolConfigDialog({ tool, onSave }: ToolConfigProps) {
  const schema = generateToolConfigSchema(tool);
  
  return (
    <Dialog>
      <DialogContent>
        <Form
          schema={schema}
          formData={tool.options}
          onSubmit={({ formData }) => onSave(formData)}
        />
      </DialogContent>
    </Dialog>
  );
}
```
### 3. Schema Generation
Dynamic schema generation for different form types:
```typescript
// Generate input schema form from workflow definition
function generateInputFormSchema(workflow: WorkflowDefinition): RJSFSchema {
  return {
    type: 'object',
    title: `Input for ${workflow.name}`,
    description: workflow.description,
    properties: workflow.inputSchema.properties,
    required: workflow.inputSchema.required || []
  };
}
// Generate tool configuration schema
function generateToolConfigSchema(tool: ToolDefinition): RJSFSchema {
  return {
    type: 'object',
    title: `Configure ${tool.name}`,
    properties: {
      retry: {
        type: 'number',
        title: 'Retry Attempts',
        minimum: 0,
        default: 0
      },
      timeout: {
        type: 'number',
        title: 'Timeout (ms)',
        minimum: 1000,
        default: 30000
      },
      ...tool.customOptions // Dynamic options based on tool type
    }
  };
}
```
### 4. Form Validation Integration
RJSF provides built-in validation that integrates seamlessly with the workflow API:
```typescript
// Custom validator for workflow-specific validation
const workflowValidator = (formData: any, errors: any) => {
  // Custom validation logic
  if (formData.email && !formData.email.includes('@')) {
    errors.email.addError('Invalid email format');
  }
  return errors;
};
```
## Integration Points
### 1. Existing API Integration
- `SANDBOX_UPSERT_WORKFLOW`: For saving workflow definitions
- `SANDBOX_START_WORKFLOW`: For executing workflows
- `SANDBOX_GET_WORKFLOW_STATUS`: For monitoring execution
- `SANDBOX_REPLAY_WORKFLOW_FROM_STEP`: For partial execution
- `SANDBOX_LIST_WORKFLOWS`: For loading existing workflows
### 2. Integration with Existing Systems
- **Integrations API**: For tool selection and configuration
- **MCP Tools**: For tool discovery and metadata
- **AI Generation**: For workflow enhancement and code generation
## Future Enhancements
### 1. Advanced Features
- **Conditional Flows**: Support for branching logic
- **Parallel Execution**: Multiple paths running simultaneously
- **Error Handling**: Retry logic and error recovery flows
- **Sub-workflows**: Nested workflow execution
- **Templates**: Pre-built workflow templates
### 2. Collaboration Features
- **Version Control**: Workflow versioning and history
- **Sharing**: Share workflows between users
- **Comments**: Annotations on workflow steps
- **Real-time Collaboration**: Multiple users editing simultaneously
### 3. Performance Optimizations
- **Lazy Loading**: Load workflow components on demand
- **Caching**: Cache workflow definitions and execution results
- **Optimistic Updates**: Immediate UI feedback for better UX
## Implementation Priority
### Phase 1: Core Functionality
1. URL routing setup for `/:org/:project/workflows/:workflow-name`
2. Workflow loading and initialization
3. Basic React Flow canvas setup
4. Tool and mapper node creation
5. Auto-mapper generation on connection
6. Basic workflow generation and saving
### Phase 2: Execution Features
1. Workflow execution UI
2. Real-time progress tracking
3. Step replay functionality
4. Results display
### Phase 3: Polish and Enhancement
1. Advanced node configuration
2. Workflow templates
3. Error handling and validation
4. Performance optimizations
This implementation will create a powerful, user-friendly workflow builder that rivals other well-known web-based workflow systems while integrating seamlessly with the existing deco.chat architecture.
## Documentation and Resources
### React Flow Documentation
#### Core Documentation
- **Official React Flow Documentation**: https://reactflow.dev/docs
- **Getting Started Guide**: https://reactflow.dev/learn/getting-started
- **API Reference**: https://reactflow.dev/api-reference
- **GitHub Repository**: https://github.com/xyflow/xyflow
#### Key Concepts and Tutorials
- **Node Types**: https://reactflow.dev/learn/customization/node-types
- **Edge Types**: https://reactflow.dev/learn/customization/edge-types
- **Controls and Background**: https://reactflow.dev/learn/customization/controls
- **Minimap**: https://reactflow.dev/learn/customization/minimap
- **Background Patterns**: https://reactflow.dev/learn/customization/background
- **Custom Handles**: https://reactflow.dev/learn/customization/handles
- **Node Positioning**: https://reactflow.dev/learn/customization/node-positioning
#### Advanced Features
- **Subflows**: https://reactflow.dev/learn/advanced/subflows
- **Node Resizing**: https://reactflow.dev/learn/customization/node-resizing
- **Node Selection**: https://reactflow.dev/learn/customization/node-selection
- **Edge Selection**: https://reactflow.dev/learn/customization/edge-selection
- **Keyboard Shortcuts**: https://reactflow.dev/learn/advanced/keyboard-shortcuts
- **Touch Device Support**: https://reactflow.dev/learn/advanced/touch-devices
#### Examples and Use Cases
- **Workflow Builder Example**: https://reactflow.dev/examples/workflow-builder
- **Node Editor Example**: https://reactflow.dev/examples/node-editor
- **Custom Node Example**: https://reactflow.dev/examples/custom-node
- **Drag and Drop**: https://reactflow.dev/examples/drag-and-drop
- **Node Resizer**: https://reactflow.dev/examples/node-resizer
- **All Examples**: https://reactflow.dev/examples
### React JSON Schema Form (RJSF) Documentation
#### Core Documentation
- **Official RJSF Documentation**: https://rjsf-team.github.io/react-jsonschema-form/docs/
- **Quickstart Guide**: https://rjsf-team.github.io/react-jsonschema-form/docs/quickstart/
- **GitHub Repository**: https://github.com/rjsf-team/react-jsonschema-form
#### Shadcn Integration
- **RJSF Shadcn Package**: https://www.npmjs.com/package/@rjsf/shadcn
- **RJSF 6.x Upgrade Guide**: https://rjsf-team.github.io/react-jsonschema-form/docs/migration-guides/v6.x%20upgrade%20guide/
- **Shadcn Integration Discussion**: https://github.com/rjsf-team/react-jsonschema-form/issues/4213
#### Advanced Customization
- **Custom Widgets**: https://rjsf-team.github.io/react-jsonschema-form/docs/advanced-customization/custom-widgets
- **Custom Fields**: https://rjsf-team.github.io/react-jsonschema-form/docs/advanced-customization/custom-fields
- **Custom Templates**: https://rjsf-team.github.io/react-jsonschema-form/docs/advanced-customization/custom-templates
- **Custom Validators**: https://rjsf-team.github.io/react-jsonschema-form/docs/advanced-customization/custom-validators
- **UI Schema**: https://rjsf-team.github.io/react-jsonschema-form/docs/advanced-customization/ui-schema
#### Form Builder Tools
- **React JSON Schema Form Builder**: https://react-json-schema-form-builder.readthedocs.io/
- **Shadcn Form Builder**: https://www.shadcn-form.com/
### Additional Resources
#### React Hook Form (Backup Form Handling)
- **Official Documentation**: https://react-hook-form.com/
- **Advanced React Forms Tutorial**: https://wasp.sh/blog/2025/01/22/advanced-react-hook-form-zod-shadcn
#### Zod Validation
- **Official Documentation**: https://zod.dev/
- **Schema Validation Guide**: https://zod.dev/?id=basic-usage
#### Shadcn UI Components
- **Official Documentation**: https://ui.shadcn.com/
- **Components Reference**: https://ui.shadcn.com/docs/components
### Implementation Examples
#### React Flow Workflow Builders
- **Flow Builder Example**: https://github.com/xyflow/xyflow/tree/main/example/src/WorkflowBuilder
- **Node Editor Example**: https://github.com/xyflow/xyflow/tree/main/example/src/NodeEditor
- **Custom Node Example**: https://github.com/xyflow/xyflow/tree/main/example/src/CustomNode
#### RJSF with Shadcn Examples
- **Basic Form Example**: https://rjsf-team.github.io/react-jsonschema-form/docs/quickstart/
- **Custom Widget Example**: https://rjsf-team.github.io/react-jsonschema-form/docs/advanced-customization/custom-widgets
### Best Practices and Patterns
#### React Flow Best Practices
1. **Node Types**: Create reusable node types for different workflow elements
2. **Edge Types**: Use different edge types for different connection types
3. **State Management**: Keep React Flow state separate from business logic
4. **Performance**: Use React.memo for custom nodes to prevent unnecessary re-renders
5. **Accessibility**: Ensure keyboard navigation and screen reader support
#### RJSF Best Practices
1. **Schema Design**: Keep schemas simple and well-structured
2. **Validation**: Use both JSON Schema validation and custom validators
3. **UI Schema**: Leverage UI schema for better form layout and UX
4. **Custom Components**: Create custom widgets for complex form elements
5. **Error Handling**: Provide clear error messages and validation feedback
#### Integration Patterns
1. **Form Integration**: Use RJSF for configuration dialogs and input forms
2. **State Synchronization**: Keep React Flow state in sync with workflow definitions
3. **API Integration**: Use existing SDK hooks for workflow operations
4. **Error Boundaries**: Implement proper error handling for both React Flow and RJSF
5. **Loading States**: Provide loading indicators for async operations
### Troubleshooting Resources
#### Common React Flow Issues
- **Node Positioning**: https://reactflow.dev/learn/customization/node-positioning
- **Edge Routing**: https://reactflow.dev/learn/customization/edge-types
- **Performance Issues**: https://reactflow.dev/learn/advanced/performance
#### Common RJSF Issues
- **Schema Validation**: https://rjsf-team.github.io/react-jsonschema-form/docs/advanced-customization/custom-validators
- **Custom Widgets**: https://rjsf-team.github.io/react-jsonschema-form/docs/advanced-customization/custom-widgets
- **Theme Integration**: https://rjsf-team.github.io/react-jsonschema-form/docs/migration-guides/v6.x%20upgrade%20guide/
### Community and Support
#### React Flow
- **GitHub Issues**: https://github.com/xyflow/xyflow/issues
- **Discord Community**: https://discord.gg/Bqt6xrs
- **Stack Overflow**: Tag: `react-flow`
#### RJSF
- **GitHub Issues**: https://github.com/rjsf-team/react-jsonschema-form/issues
- **Stack Overflow**: Tag: `react-jsonschema-form`
This comprehensive documentation provides all the necessary resources for implementing the Workflow Builder UI feature, from basic setup to advanced customization and troubleshooting.
## Implementation Clarifications
### Tool Discovery and Selection
- **Reuse Existing UI**: The workflow builder will reuse the existing "Add Integration" dialog from agent creation
- **Familiar Interface**: Users will see the same tool selection interface they're already familiar with
- **No New Discovery Logic**: Leverage existing integration and tool discovery mechanisms
### Auto-Mapper Generation Strategy
- **Always Insert Mappers**: Every connection between tools will automatically insert a mapper node
- **Identity Functions**: When data types match, generate simple identity functions (`x => x`)
- **Transformation Functions**: When data types don't match, generate transformation logic with TODO comments
- **Explicit Data Flow**: This ensures all data transformations are visible and configurable
### AI Integration Details
- **Service**: Use existing `MCPClient['AI_GATEWAY'].AI_GENERATE_OBJECT`
- **Prompt Strategy**: Send detailed prompts similar to sandbox workflow creation tool
- **Enhancement Focus**: AI will enhance and complete workflow definitions, not create from scratch
- **Schema Compliance**: AI output will be validated against WorkflowDefinitionSchema
### RJSF Shadcn Integration
- **Beta Package**: Use `@rjsf/shadcn@^6.0.0-beta.10` as specified
- **Stable Integration**: The beta package is stable enough for production use
- **No Fallback Needed**: RJSF Shadcn integration will work as expected
### URL Routing
- **Single Pattern**: Use `/:org/:project/workflows/:workflow-name` for direct editing
- **No Edit Route**: No need for separate `/edit` route - the main route handles editing
- **Early Stage Access**: Feature accessible only by typing URL directly in browser
### State Management Strategy
- **React Flow State**: Handle visual canvas state (nodes, edges, positions)
- **Workflow State**: Manage workflow definition and execution state
- **Form State**: Use RJSF for all form interactions
- **Synchronization**: Keep states synchronized through well-defined interfaces
### Error Handling Approach
- **Graceful Degradation**: Handle missing workflows by creating empty ones
- **Validation Errors**: Show clear error messages for invalid configurations
- **AI Generation Failures**: Fallback to basic workflow definition if AI generation fails
- **Execution Errors**: Display execution errors in the execution panel
### Performance Considerations
- **Canvas Optimization**: Use React.memo for custom nodes to prevent unnecessary re-renders
- **Large Workflows**: Implement node virtualization for workflows with many nodes
- **Memory Management**: Clean up old workflow runs to prevent memory leaks
- **Lazy Loading**: Load workflow components on demand
These clarifications ensure a clear and consistent implementation approach that leverages existing infrastructure while providing a powerful new workflow building capability.
GIF of two octocats high fiving each otherTwo octocats
You made it to the end!
Copied!

Quero fazer um documento plans/workflow_ui.md com base no seguinte documento:

{"type":"excalidraw/clipboard","elements":[{"id":"23Q9dYPIUZMHRRPvC5Xnb","type":"rectangle","x":2588.0613116805766,"y":834.3843764826629,"width":297.3076174078192,"height":240.7163953350144,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aB","roundness":null,"seed":1318381101,"version":162,"versionNonce":264206179,"isDeleted":false,"boundElements":null,"updated":1758043407706,"link":null,"locked":false},{"id":"wEPe79stt3rQj-OhNK0eQ","type":"rectangle","x":3692.301956197123,"y":834.5900556999039,"width":283.6189152519446,"height":256.86901625407563,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aC","roundness":null,"seed":684521827,"version":173,"versionNonce":1073081155,"isDeleted":false,"boundElements":[],"updated":1758043648960,"link":null,"locked":false},{"id":"e6ilc4nRBlD-yUSJXrrYw","type":"rectangle","x":4096.105916718815,"y":829.9275916573147,"width":283.6189152519446,"height":256.86901625407563,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aCG","roundness":null,"seed":942276899,"version":209,"versionNonce":571533741,"isDeleted":false,"boundElements":[],"updated":1758043649440,"link":null,"locked":false},{"id":"q-eAWtL9snWTvfqLJpzga","type":"rectangle","x":3184.4973366133077,"y":836.9663857553705,"width":283.6189152519446,"height":256.86901625407563,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"#b2f2bb","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aD","roundness":null,"seed":1093336621,"version":228,"versionNonce":183468867,"isDeleted":false,"boundElements":null,"updated":1758043645339,"link":null,"locked":false},{"id":"4XKi_zIUe82x9Z4rXJ5nk","type":"text","x":2726.1019575994223,"y":747.4300582048432,"width":11.487292333716042,"height":33.62793139535905,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aE","roundness":null,"seed":810715437,"version":83,"versionNonce":721840685,"isDeleted":false,"boundElements":null,"updated":1758043397395,"link":null,"locked":false,"text":"1","fontSize":26.902345116287233,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"1","autoResize":true,"lineHeight":1.25},{"id":"EmYqcIoBxauklSnms5d1s","type":"text","x":3826.154471127507,"y":755.9579184191207,"width":16.355194091796875,"height":33.62793139535904,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aF","roundness":null,"seed":556516227,"version":185,"versionNonce":466082253,"isDeleted":false,"boundElements":null,"updated":1758043661415,"link":null,"locked":false,"text":"3","fontSize":26.902345116287233,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"3","autoResize":true,"lineHeight":1.25},{"id":"Nq93c4zO5YpJlK3mQWI6o","type":"text","x":3312.8700760977667,"y":775.6962379101435,"width":18.829986572265625,"height":33.62793139535904,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aG","roundness":null,"seed":697408205,"version":247,"versionNonce":1065773037,"isDeleted":false,"boundElements":null,"updated":1758043646474,"link":null,"locked":false,"text":"2","fontSize":26.902345116287233,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"2","autoResize":true,"lineHeight":1.25},{"id":"I2PJgO1W10t-5gE_07viG","type":"rectangle","x":2652.4582732739827,"y":878.2853653120955,"width":144.72212287600678,"height":125.8444458012655,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aH","roundness":null,"seed":604525229,"version":177,"versionNonce":1050683085,"isDeleted":false,"boundElements":[],"updated":1758043702303,"link":null,"locked":false},{"id":"c5pjdrqIEZPkY4ve7nIGm","type":"rectangle","x":2481.423166947127,"y":879.7954472268348,"width":144.641343464546,"height":125.8444458012655,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aHV","roundness":null,"seed":878654925,"version":205,"versionNonce":1592263139,"isDeleted":false,"boundElements":[],"updated":1758043527602,"link":null,"locked":false},{"id":"1wFxuWdD4d4C7aPIC2pss","type":"rectangle","x":2420.1536851533956,"y":679.4827322315584,"width":658.1291167654704,"height":472.68813745791704,"angle":0,"strokeColor":"#1971c2","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"dashed","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aJ","roundness":null,"seed":2144125517,"version":59,"versionNonce":1078875117,"isDeleted":false,"boundElements":null,"updated":1758043422229,"link":null,"locked":false},{"id":"mvSNentq_omvs9Y6ggeKi","type":"rectangle","x":2621.6541186916484,"y":1105.2838127527707,"width":235.37474332110514,"height":37.06145663568668,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aK","roundness":null,"seed":906316035,"version":96,"versionNonce":55019853,"isDeleted":false,"boundElements":null,"updated":1758043430340,"link":null,"locked":false},{"id":"x1FjWjjk5DgsL8UCU9zOa","type":"rectangle","x":2741.685586108373,"y":1112.6856166888983,"width":31.68175277863429,"height":21.713815354798953,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aL","roundness":null,"seed":108627363,"version":59,"versionNonce":1262575917,"isDeleted":false,"boundElements":null,"updated":1758043436636,"link":null,"locked":false},{"id":"yaUXp_X6eQ2pG0paR52YV","type":"rectangle","x":2779.466412221138,"y":1112.4824234880837,"width":31.68175277863429,"height":21.713815354798953,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aM","roundness":null,"seed":1312628909,"version":92,"versionNonce":1748415373,"isDeleted":false,"boundElements":null,"updated":1758043436636,"link":null,"locked":false},{"id":"ncApSDYBREJN1oj4EX63S","type":"rectangle","x":2817.1833307949364,"y":1112.0825917058355,"width":31.68175277863429,"height":21.713815354798953,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aN","roundness":null,"seed":1503395715,"version":136,"versionNonce":865253869,"isDeleted":false,"boundElements":null,"updated":1758043436636,"link":null,"locked":false},{"id":"xRLH6aMMHeylzFKajkYGh","type":"ellipse","x":2633.015994267662,"y":1113.4330823715934,"width":19.183732273687383,"height":18.556127467945316,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aO","roundness":null,"seed":980615939,"version":86,"versionNonce":613980803,"isDeleted":false,"boundElements":null,"updated":1758043474691,"link":null,"locked":false},{"id":"XmStJVkgpLrQQD02FCto4","type":"ellipse","x":2659.978747809709,"y":1113.3525195846266,"width":19.183732273687383,"height":18.556127467945316,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aOV","roundness":null,"seed":1751819469,"version":117,"versionNonce":1437369965,"isDeleted":false,"boundElements":null,"updated":1758043475410,"link":null,"locked":false},{"id":"hqfxufbd_W_DMa6tJECrE","type":"ellipse","x":2685.3808426505916,"y":1113.787204226851,"width":19.183732273687383,"height":18.556127467945316,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aP","roundness":null,"seed":1401335853,"version":93,"versionNonce":1909455021,"isDeleted":false,"boundElements":null,"updated":1758043472076,"link":null,"locked":false},{"id":"ot0F6YFsuBxWvPqZthxs2","type":"text","x":2691.4853277380485,"y":1113.51636693628,"width":16.439987182617188,"height":20.129899217823795,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aQ","roundness":null,"seed":74725539,"version":103,"versionNonce":416525,"isDeleted":false,"boundElements":null,"updated":1758043472076,"link":null,"locked":false,"text":">","fontSize":16.103919374259036,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":">","autoResize":false,"lineHeight":1.25},{"id":"9HAOXAuGiC1jKrZFpXrl8","type":"text","x":2629.8828622343904,"y":1112.782172535906,"width":16.439987182617188,"height":20.129899217823795,"angle":3.1524742755089665,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aR","roundness":null,"seed":1269290029,"version":234,"versionNonce":1028513965,"isDeleted":false,"boundElements":null,"updated":1758043469195,"link":null,"locked":false,"text":">","fontSize":16.103919374259036,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":">","autoResize":false,"lineHeight":1.25},{"id":"PDsbjHuNhB7rMy6HsEO4V","type":"rectangle","x":2665.131065098078,"y":1118.3828568438578,"width":8.257549501138328,"height":8.039152454745818,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aT","roundness":null,"seed":2069890595,"version":59,"versionNonce":1756044461,"isDeleted":false,"boundElements":null,"updated":1758043489122,"link":null,"locked":false},{"id":"zjou4mmhGjUN-FsbGfhtS","type":"rectangle","x":2653.5911317589807,"y":1004.9705530345361,"width":143.80762283538297,"height":58.62442279435546,"angle":0,"strokeColor":"#f08c00","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aU","roundness":null,"seed":1347221165,"version":77,"versionNonce":62921507,"isDeleted":false,"boundElements":null,"updated":1758043535232,"link":null,"locked":false},{"id":"yTWMqGK0K6irKBAluUAbq","type":"text","x":2662.240225020026,"y":1013.0771369910525,"width":127.54663435891503,"height":15.849824376202129,"angle":0,"strokeColor":"#f08c00","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aV","roundness":null,"seed":325877219,"version":113,"versionNonce":941376515,"isDeleted":false,"boundElements":null,"updated":1758043536486,"link":null,"locked":false,"text":"Estado de Execução","fontSize":12.679859500961701,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"Estado de Execução","autoResize":true,"lineHeight":1.25},{"id":"PxXBjYWsqzoNQXmS5WjCI","type":"text","x":2490.1151575763433,"y":889.3661065767327,"width":98.16100931236394,"height":12.198163957926209,"angle":0,"strokeColor":"#f08c00","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aVV","roundness":null,"seed":354062147,"version":183,"versionNonce":1337025997,"isDeleted":false,"boundElements":null,"updated":1758043531298,"link":null,"locked":false,"text":"Estado de Execução","fontSize":9.758531166340969,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"Estado de Execução","autoResize":true,"lineHeight":1.25},{"id":"EgI8p0qvumLWbH7ztycME","type":"arrow","x":2781.3452255352954,"y":888.3823898443678,"width":12.205877822562424,"height":0.7965292079442179,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aW","roundness":{"type":2},"seed":1195228451,"version":49,"versionNonce":747101603,"isDeleted":false,"boundElements":null,"updated":1758043589000,"link":null,"locked":false,"points":[[0,0],[12.205877822562424,0.7965292079442179]],"lastCommittedPoint":null,"startBinding":null,"endBinding":null,"startArrowhead":null,"endArrowhead":"arrow","elbowed":false},{"id":"Ajqr7aEiL4Z20CStLAE_R","type":"rectangle","x":2665.7819730145366,"y":1033.690594341624,"width":77.43720045792134,"height":25.939146764406814,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aX","roundness":null,"seed":805532685,"version":51,"versionNonce":454114733,"isDeleted":false,"boundElements":null,"updated":1758043538593,"link":null,"locked":false},{"id":"y6YQi3ZigWgOJdiDRwpeI","type":"rectangle","x":4163.631437209029,"y":910.7856870513832,"width":153.46335273953537,"height":37.25991782721394,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aYV","roundness":null,"seed":944526989,"version":190,"versionNonce":1023486989,"isDeleted":false,"boundElements":null,"updated":1758043649440,"link":null,"locked":false},{"id":"tCa6zhAQ0dahi50ZtHIBP","type":"text","x":4163.627230602686,"y":892.668830837313,"width":137.7756810423228,"height":13.051891236381376,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aZV","roundness":null,"seed":36955331,"version":195,"versionNonce":1769611885,"isDeleted":false,"boundElements":null,"updated":1758043649440,"link":null,"locked":false,"text":"O que vc quer fazer agora?","fontSize":10.441512989105096,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"O que vc quer fazer agora?","autoResize":true,"lineHeight":1.25},{"id":"AL6J4sze8WuHhoJ4DP5h8","type":"text","x":4166.205782017549,"y":961.4696904561984,"width":50.007537841796875,"height":13.051891236381369,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aaG","roundness":null,"seed":1459354861,"version":247,"versionNonce":1548045517,"isDeleted":false,"boundElements":null,"updated":1758043649440,"link":null,"locked":false,"text":"Tool Calls","fontSize":10.441512989105096,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"Tool Calls","autoResize":true,"lineHeight":1.25},{"id":"pq7M9GaPdMT4pPg_3zNFh","type":"text","x":4219.158396932078,"y":1051.6697574911502,"width":23.938873291015625,"height":13.051891236381369,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aal","roundness":null,"seed":612389987,"version":289,"versionNonce":1962683181,"isDeleted":false,"boundElements":null,"updated":1758043649440,"link":null,"locked":false,"text":"Criar","fontSize":10.441512989105096,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"Criar","autoResize":true,"lineHeight":1.25},{"id":"oTSFcOwp6Bi2Rc5EeRBNH","type":"rectangle","x":4166.408866019197,"y":975.5255649944961,"width":161.1533093682724,"height":53.069542066992426,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"abV","roundness":null,"seed":564647757,"version":128,"versionNonce":1678261645,"isDeleted":false,"boundElements":null,"updated":1758043649440,"link":null,"locked":false},{"id":"f4aQTwQHI2t2ISQVRVOP7","type":"rectangle","x":4171.035181117342,"y":980.418043216014,"width":71.72865397597616,"height":19.602221704515273,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"acV","roundness":null,"seed":249417731,"version":121,"versionNonce":279118829,"isDeleted":false,"boundElements":null,"updated":1758043649440,"link":null,"locked":false},{"id":"gapH-MF_wmf4ljEllKs8e","type":"rectangle","x":4247.622465981229,"y":980.7457469459459,"width":71.72865397597616,"height":19.602221704515273,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"adV","roundness":null,"seed":849962413,"version":174,"versionNonce":1054211661,"isDeleted":false,"boundElements":null,"updated":1758043649440,"link":null,"locked":false},{"id":"jPG9x3LUQ3oCF284XK0dv","type":"text","x":4176.176898795429,"y":1001.9649480878246,"width":12.898591083333974,"height":19.44903728829047,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"afV","roundness":null,"seed":860542883,"version":153,"versionNonce":1306460205,"isDeleted":false,"boundElements":null,"updated":1758043654215,"link":null,"locked":false,"text":"@","fontSize":15.559229830632368,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"@","autoResize":true,"lineHeight":1.25},{"id":"BFbtqg35CNaTv4TnqiTwV","type":"text","x":3774.969126348716,"y":927.2480245483795,"width":42.529205322265625,"height":19.449037288290462,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"afl","roundness":null,"seed":562089347,"version":208,"versionNonce":728113187,"isDeleted":false,"boundElements":null,"updated":1758043658114,"link":null,"locked":false,"text":"Tools","fontSize":15.559229830632368,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"Tools","autoResize":true,"lineHeight":1.25},{"id":"tsuG6CTCS8bj42qGmPWQ5","type":"rectangle","x":4197.9884282754465,"y":1043.697171911306,"width":85.87222387862175,"height":29.194863752051106,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"ah","roundness":null,"seed":489302029,"version":120,"versionNonce":607817485,"isDeleted":false,"boundElements":null,"updated":1758043649440,"link":null,"locked":false},{"id":"d3zYQjg0EpjxYidZ-DJVX","type":"rectangle","x":3761.9539433107984,"y":918.3310376107809,"width":146.83201317904604,"height":112.85670241615844,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"ai","roundness":null,"seed":1708509581,"version":37,"versionNonce":116516611,"isDeleted":false,"boundElements":null,"updated":1758043652786,"link":null,"locked":false},{"id":"2UoT83igmfsPFd_2DkkjZ","type":"rectangle","x":2914.9505101889913,"y":737.6052184806072,"width":137.6235938221043,"height":208.78534196716535,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aj","roundness":null,"seed":604736141,"version":113,"versionNonce":458069603,"isDeleted":false,"boundElements":null,"updated":1758043698870,"link":null,"locked":false},{"id":"CoXYl2bqpIEcf6ueAFBBI","type":"text","x":2916.095609878762,"y":714.5481961001111,"width":129.7648424570034,"height":16.3761885942414,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"ak","roundness":null,"seed":473455469,"version":119,"versionNonce":1244541475,"isDeleted":false,"boundElements":null,"updated":1758043687213,"link":null,"locked":false,"text":"Estado do Workflow","fontSize":13.100950875393124,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"Estado do Workflow","autoResize":true,"lineHeight":1.25},{"id":"pqrEMNfgLFy3Y71dKpWI2","type":"rectangle","x":2921.5410652729856,"y":754.0387973154225,"width":66.50611673542289,"height":22.40638568553038,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"al","roundness":null,"seed":2005629933,"version":70,"versionNonce":688783171,"isDeleted":false,"boundElements":null,"updated":1758043693298,"link":null,"locked":false},{"id":"TAnaS5ATeqf8ZF6PbTonO","type":"rectangle","x":2921.5458994446544,"y":783.1646816207775,"width":66.50611673542289,"height":22.40638568553038,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"alV","roundness":null,"seed":1121282979,"version":117,"versionNonce":172923085,"isDeleted":false,"boundElements":null,"updated":1758043694349,"link":null,"locked":false},{"id":"kca2hfoIR4F8V_UxedZsY","type":"rectangle","x":2922.435387031739,"y":813.477355070857,"width":66.50611673542289,"height":22.40638568553038,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"all","roundness":null,"seed":297594477,"version":143,"versionNonce":1992881635,"isDeleted":false,"boundElements":null,"updated":1758043695322,"link":null,"locked":false},{"id":"bplwdKPx4Vzoa3iROOHgm","type":"rectangle","x":2923.3176233613203,"y":842.2430935868762,"width":66.50611673542289,"height":22.40638568553038,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"alt","roundness":null,"seed":760395331,"version":182,"versionNonce":1619814957,"isDeleted":false,"boundElements":null,"updated":1758043696536,"link":null,"locked":false},{"id":"KfRUsMWvgo-tjYoIOLg-w","type":"rectangle","x":2923.4143067946993,"y":872.381736856874,"width":66.50611673542289,"height":22.40638568553038,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"alx","roundness":null,"seed":1286695885,"version":207,"versionNonce":671607075,"isDeleted":false,"boundElements":null,"updated":1758043697030,"link":null,"locked":false},{"id":"I1_LIJrP9c2d8hxMHTuyA","type":"rectangle","x":2992.7895044156376,"y":754.1330636629667,"width":49.907988310122164,"height":22.40638568553038,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"am","roundness":null,"seed":1085535181,"version":132,"versionNonce":910609005,"isDeleted":false,"boundElements":null,"updated":1758043693298,"link":null,"locked":false},{"id":"5PsgZQ9sHfzfMvRZt3Spc","type":"rectangle","x":2992.7943385873064,"y":783.2589479683218,"width":49.907988310122164,"height":22.40638568553038,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"an","roundness":null,"seed":272815117,"version":179,"versionNonce":2048779907,"isDeleted":false,"boundElements":null,"updated":1758043694349,"link":null,"locked":false},{"id":"R0mGhg6zYupMY6k54jyL1","type":"rectangle","x":2993.683826174391,"y":813.5716214184013,"width":49.907988310122164,"height":22.40638568553038,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"ao","roundness":null,"seed":664877795,"version":205,"versionNonce":1859390925,"isDeleted":false,"boundElements":null,"updated":1758043695322,"link":null,"locked":false},{"id":"633-Vr7yVSpXpTQNVZEYL","type":"rectangle","x":2994.5660625039723,"y":842.3373599344204,"width":49.907988310122164,"height":22.40638568553038,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"ap","roundness":null,"seed":252511085,"version":244,"versionNonce":208165667,"isDeleted":false,"boundElements":null,"updated":1758043696536,"link":null,"locked":false},{"id":"Usj9Io8moKAEaSTaxa7Os","type":"rectangle","x":2994.6627459373512,"y":872.4760032044182,"width":49.907988310122164,"height":22.40638568553038,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"aq","roundness":null,"seed":574997379,"version":269,"versionNonce":236244163,"isDeleted":false,"boundElements":null,"updated":1758043697030,"link":null,"locked":false},{"id":"nEbLGgjhRdla5SI0xvxEz","type":"text","x":2961.4404704613817,"y":913.6330500192262,"width":43.34477825625408,"height":18.644535459793946,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"ar","roundness":null,"seed":988529965,"version":144,"versionNonce":1611821581,"isDeleted":false,"boundElements":null,"updated":1758043717784,"link":null,"locked":false,"text":"Reset","fontSize":14.91562836783516,"fontFamily":5,"textAlign":"left","verticalAlign":"top","containerId":null,"originalText":"Reset","autoResize":true,"lineHeight":1.25},{"id":"F7iiFPcNie07qJMUye_fx","type":"rectangle","x":2951.7836432338654,"y":907.3448834524721,"width":65.2771576929712,"height":30.47220111515435,"angle":0,"strokeColor":"#1e1e1e","backgroundColor":"transparent","fillStyle":"solid","strokeWidth":1,"strokeStyle":"solid","roughness":1,"opacity":100,"groupIds":[],"frameId":null,"index":"as","roundness":null,"seed":460747683,"version":127,"versionNonce":1718790253,"isDeleted":false,"boundElements":null,"updated":1758043717784,"link":null,"locked":false}],"files":{}}

Em suma: quero fazer uma estrutura de "array" visual como se fosse um apresentador de slides powerpoint para cada step do workflow. Adicionar um novo passo significar selecionar tools das disponiveis e fazer um prompt do que você pede

isso vai gerar um novo step no workflow que vai ser um código custom que, dentro dele vai ter:
- input schema 
- tools calls (chamadas pra .env para as tool que o usuario escolheu)
- data mapping 

---

_**Assistant**_

<details>
                <summary>Searched codebase "Where are workflow definitions and schemas defined?" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `packages/sdk/src/mcp/sandbox/workflow-schemas.ts` | L59-92 |
| `packages/sdk/src/crud/sandbox-workflows.ts` | Lundefined-23 |
| `packages/sdk/src/mcp/sandbox/workflows.ts` | L126-332 |
| `packages/sdk/src/mcp/sandbox/workflows.ts` | L130-332 |
| `packages/sdk/src/mcp/sandbox/workflow-schemas.ts` | L66-92 |
| `docs/view/src/content/en/project-structure.mdx` | L142-228 |
| `workflow.md` | L45-128 |
| `workflow.md` | Lundefined-49 |
| `packages/sdk/src/mcp/sandbox/workflow-schemas.ts` | Lundefined-56 |
| `workflow.md` | L159-216 |
| `packages/sdk/src/mcp/sandbox/workflow-schemas.ts` | L21-90 |
| `packages/sdk/src/mcp/sandbox/workflows.ts` | L708-787 |
| `docs/view/src/content/en/project-structure.mdx` | L81-145 |
| `packages/sdk/src/hooks/workflows.ts` | L122-151 |

</details>

---

<details>
                <summary>Searched codebase "How are tools and integrations discovered and listed for selection?" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `packages/sdk/src/mcp/integrations/api.ts` | L303-408 |
| `packages/cli/src/lib/prompt-integrations.ts` | L37-120 |
| `apps/web/src/components/workflow-builder/select-tool-dialog.tsx` | L27-242 |
| `packages/ai/src/mcp.ts` | L243-320 |
| `packages/sdk/src/mcp/integrations/api.ts` | L666-807 |
| `apps/web/src/hooks/use-options-loader.ts` | Lundefined-43 |
| `packages/sdk/src/mcp/index.ts` | L68-212 |
| `packages/sdk/src/mcp/integrations/api.ts` | L114-275 |
| `packages/sdk/src/mcp/integrations/api.ts` | L290-399 |
| `apps/web/src/hooks/use-agent-settings-tools-set.ts` | Lundefined-79 |
| `apps/web/src/components/toolsets/selector.tsx` | L21-243 |
| `apps/web/src/components/chat/context-resources.tsx` | L119-511 |
| `apps/web/src/components/chat/rich-text.tsx` | L42-183 |
| `packages/sdk/src/mcp/integrations/api.ts` | Lundefined-82 |
| `apps/web/src/components/toolsets/single-selector.tsx` | L82-153 |

</details>

---

<details>
                <summary>Searched codebase "How are RJSF forms used in the existing codebase for tool configuration?" • **13** results</summary>
            
| File | Lines |
|------|-------|
| `workflow.md` | L553-634 |
| `apps/web/src/components/workflow-builder/dialogs/tool-config-dialog.tsx` | L9-61 |
| `apps/web/src/components/workflow-builder/dialogs/tool-config-dialog.tsx` | Lundefined-61 |
| `apps/web/src/components/integrations/tool-call-form.tsx` | L42-204 |
| `workflow.md` | L632-699 |
| `apps/web/src/components/integrations/tool-call-form.tsx` | Lundefined-40 |
| `apps/web/src/components/integrations/tool-call-form.tsx` | L61-204 |
| `workflow.md` | L45-128 |
| `apps/web/src/components/integrations/connection-detail.tsx` | L757-1044 |
| `workflow.md` | L858-893 |
| `apps/web/src/components/triggers/trigger-dialog.tsx` | L451-1398 |
| `workflow.md` | L125-162 |
| `apps/web/src/components/integrations/connection-detail.tsx` | L132-695 |

</details>

---

## Todo List

- [-] Create comprehensive plans/workflow_ui.md document based on visual slide deck concept
- [ ] Structure document with overview, visual slide deck approach, and technical implementation
- [ ] Detail AI-powered step generation from user prompts and tool selection
- [ ] Define component architecture and integration with existing workflow APIs

---



---

## Todo List

- [x] Create comprehensive plans/workflow_ui.md document based on visual slide deck concept
- [x] Structure document with overview, visual slide deck approach, and technical implementation
- [x] Detail AI-powered step generation from user prompts and tool selection
- [x] Define component architecture and integration with existing workflow APIs

---

Criei o documento `plans/workflow_ui.md` com base no conceito visual que você descreveu. O documento detalha uma abordagem inovadora para construção de workflows usando uma interface de "slides" ao invés do tradicional drag-and-drop.

## Principais características do documento:

### 🎯 **Conceito Visual - Slide Deck**
- Workflow apresentado como sequência de slides (similar ao PowerPoint)
- Navegação intuitiva com indicadores visuais de progresso
- Cada slide representa um step do workflow

### 🔧 **Criação de Steps Simplificada**
- **Seleção de Tools**: Interface familiar reutilizando componentes existentes
- **Prompt Natural**: Usuário descreve em linguagem natural o que quer fazer
- **AI Generation**: Gera código personalizado automaticamente

### 🤖 **Integração AI Inteligente**
- Usa `MCPClient['AI_GATEWAY'].AI_GENERATE_OBJECT`
- Gera código que inclui:
  - Input schema específico
  - Chamadas para tools via `ctx.env`
  - Data mapping entre tools
  - Output schema

### 🏗️ **Arquitetura Técnica**
- **WorkflowSlideBuilder**: Componente principal
- **StepSlide**: Cada step individual
- **Reutilização**: Aproveita SelectToolDialog existente
- **Estado Estendido**: Mantém dados de UI (tools selecionadas, prompts, etc.)

### ⚡ **Execução Visual**
- Execução individual de steps
- Progresso visual em tempo real
- Debug e replay simples
- Estados persistentes por slide

### 🎨 **Vantagens da Abordagem**
1. **Simplicidade**: Interface familiar de slides
2. **Linearidade**: Fluxo sequencial claro
3. **Foco**: Um step por vez
4. **AI-Friendly**: Contexto claro para geração

O documento está estruturado com implementação faseada, considerações técnicas detalhadas e exemplos de código completos. A abordagem oferece uma alternativa inovadora que democratiza a criação de workflows complexos através de uma interface simples e conversacional.

---

_**User (2025-09-16 15:51Z)**_

Não terminei de escrever tudo, mas vou adicionando

Os steps vão ter:
- Title: Gerado por AI, condensando o que aquele step de workflow faz
- Description: Mais detalhes sobre o que o código que geramos faz
- Input Schema: configuracao de um step (ex: prompt para uma chamada de AI) ou entao, no caso do step inicial, alguma entrada que vai mudar em cada execucao
- Dentro do execute deles (funcionam como custom tools), eles fazem whatever it takes para comply com aquele pedido, orquestrando tool call e fazendo data mapping
- Output Schema com o que eles querem retornar pra move on
- Description: Gerada
O executor (nosso software) "roda" cada step e esse rodar faz o step ter um estado de execução (um JSON).

Esse json é importante ser guardando junto com o step (pelo menos por agora, depois limpamos), para ser possível a AI entender e saber o necessário para gerar os proximos steps ou como deveria ser o codigo para usar o valor de um outro step que talvez veio de uma etapa ha 2 steps atras (qualquer step pode usar um dado de um step 2 3 ou n numeros atras no workflow

complemente com o necessario para atingir isso, no final do documento detalhando como o sistema atual precisa ser modifciado pontualmente para adequar os conceitos e refazer o canvas, dessa vez mais rigido e um com frame que controla a execucao e coordena a chamada de ai 

---

_**Assistant**_

Read file: undefined

---

Read file: undefined

---

## Todo List

- [-] Add detailed step structure with AI-generated titles, descriptions, and schemas
- [ ] Detail execution state JSON storage and AI context for next steps
- [ ] Document specific system modifications needed for the new workflow canvas
- [ ] Define execution controller framework that coordinates AI calls

---

<details><summary>Edit file: plans/workflow_ui.md</summary>

undefined

**Chunk 1**
Lines added: 844, lines removed: 2

```diff
@@ -653,9 +653,851 @@
  - Debounced updates para AI generation
  - Otimização de re-renders com React.memo
+ 
+ ## Estrutura Detalhada dos Steps
+ 
+ ### Anatomia de um Step
+ 
+ Cada step do workflow é uma entidade completa e auto-contida com os seguintes elementos:
+ 
+ #### 1. Metadados Gerados por AI
+ ```typescript
+ interface StepMetadata {
+   title: string;        // "Validar Email e Enriquecer Dados"
+   description: string;  // "Valida o email usando Gmail API e enriquece..."
+   generatedAt: Date;
+   version: number;
+ }
+ ```
+ 
+ #### 2. Schemas de Input/Output
+ ```typescript
+ interface StepSchemas {
+   inputSchema: JSONSchema7;   // O que o step espera receber
+   outputSchema: JSONSchema7;  // O que o step vai retornar
+   configSchema?: JSONSchema7; // Configurações específicas (ex: prompt AI)
+ }
+ 
+ // Exemplo de Input Schema para step inicial
+ const initialStepInputSchema = {
+   type: "object",
+   properties: {
+     userEmail: { type: "string", format: "email" },
+     userName: { type: "string" },
+     priority: { type: "string", enum: ["low", "medium", "high"] }
+   },
+   required: ["userEmail", "userName"]
+ };
+ 
+ // Exemplo de Output Schema
+ const stepOutputSchema = {
+   type: "object", 
+   properties: {
+     isValidEmail: { type: "boolean" },
+     enrichedData: {
+       type: "object",
+       properties: {
+         company: { type: "string" },
+         jobTitle: { type: "string" }
+       }
+     },
+     confidence: { type: "number", minimum: 0, maximum: 1 }
+   }
+ };
+ ```
+ 
+ #### 3. Código de Execução (Custom Tool)
+ ```typescript
+ interface StepExecution {
+   execute: string; // Código ES Module como custom tool
+   toolCalls: string[]; // Lista de tools que o step usa
+   dataMappings: DataMapping[]; // Como mapear dados entre calls
+ }
+ 
+ // Exemplo de código gerado
+ const generatedStepCode = `
+ export default async function(ctx) {
+   // Lê dados de entrada (workflow input ou step anterior)
+   const input = await ctx.readWorkflowInput();
+   const previousStepData = await ctx.readStepResult('step-1');
+   
+   // Validação de email usando Gmail API
+   const emailValidation = await ctx.env.gmail_integration.validate_email({
+     email: input.userEmail,
+     checkMxRecord: true
+   });
+   
+   if (!emailValidation.isValid) {
+     return {
+       isValidEmail: false,
+       enrichedData: null,
+       confidence: 0,
+       error: "Invalid email format"
+     };
+   }
+   
+   // Enriquecimento via CRM se email válido
+   const enrichmentResult = await ctx.env.crm_integration.enrich_contact({
+     email: input.userEmail,
+     name: input.userName,
+     source: "workflow-validation"
+   });
+   
+   // Data mapping e retorno estruturado
+   return {
+     isValidEmail: true,
+     enrichedData: {
+       company: enrichmentResult.company || "Unknown",
+       jobTitle: enrichmentResult.jobTitle || "Unknown"
+     },
+     confidence: enrichmentResult.confidence || 0.8
+   };
+ }`;
+ ```
+ 
+ ### Estado de Execução Persistente
+ 
+ #### ExecutionState JSON
+ ```typescript
+ interface StepExecutionState {
+   stepId: string;
+   executionId: string;
+   status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';
+   
+   // Dados de entrada utilizados
+   input: {
+     workflowInput?: unknown;
+     previousStepResults?: Record<string, unknown>;
+     stepConfig?: unknown;
+   };
+   
+   // Resultado da execução
+   output?: unknown;
+   
+   // Metadados de execução
+   execution: {
+     startedAt: Date;
+     completedAt?: Date;
+     duration?: number;
+     retryCount: number;
+     error?: {
+       message: string;
+       code: string;
+       stack?: string;
+     };
+   };
+   
+   // Logs detalhados para debug
+   logs: Array<{
+     timestamp: Date;
+     level: 'info' | 'warn' | 'error' | 'debug';
+     message: string;
+     context?: Record<string, unknown>;
+   }>;
+   
+   // Tool calls realizadas
+   toolCalls: Array<{
+     toolName: string;
+     integration: string;
+     input: unknown;
+     output: unknown;
+     duration: number;
+     success: boolean;
+     error?: string;
+   }>;
+   
+   // Contexto para AI (crítico para próximos steps)
+   aiContext: {
+     summary: string;           // Resumo do que foi feito
+     dataShape: unknown;        // Formato dos dados retornados
+     businessContext: string;   // Contexto de negócio
+     suggestedNextActions: string[]; // Sugestões para próximos steps
+   };
+ }
+ ```
+ 
+ #### Exemplo de ExecutionState Real
+ ```json
+ {
+   "stepId": "step-email-validation",
+   "executionId": "exec-12345",
+   "status": "completed",
+   "input": {
+     "workflowInput": {
+       "userEmail": "john@company.com",
+       "userName": "John Doe"
+     }
+   },
+   "output": {
+     "isValidEmail": true,
+     "enrichedData": {
+       "company": "TechCorp Inc",
+       "jobTitle": "Senior Developer"
+     },
+     "confidence": 0.95
+   },
+   "execution": {
+     "startedAt": "2024-01-15T10:30:00Z",
+     "completedAt": "2024-01-15T10:30:02Z",
+     "duration": 2000,
+     "retryCount": 0
+   },
+   "toolCalls": [
+     {
+       "toolName": "validate_email",
+       "integration": "gmail_integration", 
+       "input": { "email": "john@company.com" },
+       "output": { "isValid": true, "mxRecord": true },
+       "duration": 800,
+       "success": true
+     },
+     {
+       "toolName": "enrich_contact",
+       "integration": "crm_integration",
+       "input": { "email": "john@company.com", "name": "John Doe" },
+       "output": { "company": "TechCorp Inc", "jobTitle": "Senior Developer" },
+       "duration": 1200,
+       "success": true
+     }
+   ],
+   "aiContext": {
+     "summary": "Successfully validated email and enriched with company data",
+     "dataShape": {
+       "isValidEmail": "boolean",
+       "enrichedData": { "company": "string", "jobTitle": "string" },
+       "confidence": "number"
+     },
+     "businessContext": "User validation and enrichment for onboarding process",
+     "suggestedNextActions": [
+       "Send welcome email with personalized content",
+       "Create user account with enriched data",
+       "Trigger company-specific onboarding flow"
+     ]
+   }
+ }
+ ```
+ 
+ ### AI Context Awareness
+ 
+ #### Geração de Próximos Steps
+ ```typescript
+ interface AIStepGenerationContext {
+   currentStep: number;
+   previousSteps: StepExecutionState[];
+   availableData: Record<string, unknown>; // Todos os outputs anteriores
+   userPrompt: string;
+   selectedTools: Tool[];
+ }
+ 
+ // Exemplo de prompt para AI com contexto
+ const generateNextStepPrompt = `
+ Contexto do Workflow:
+ - Step 1: ${previousSteps[0].aiContext.summary}
+   Dados disponíveis: ${JSON.stringify(previousSteps[0].output)}
+ - Step 2: ${previousSteps[1].aiContext.summary}  
+   Dados disponíveis: ${JSON.stringify(previousSteps[1].output)}
+ 
+ Dados disponíveis para usar:
+ - step-1: ${JSON.stringify(availableData['step-1'])}
+ - step-2: ${JSON.stringify(availableData['step-2'])}
+ 
+ Usuário quer: "${userPrompt}"
+ 
+ Tools selecionadas: ${selectedTools.map(t => t.name).join(', ')}
+ 
+ Gere um step que:
+ 1. Use os dados disponíveis dos steps anteriores conforme necessário
+ 2. Execute a ação solicitada usando as tools selecionadas  
+ 3. Retorne dados estruturados para próximos steps
+ 4. Inclua tratamento de erros apropriado
+ 
+ O código deve usar:
+ - ctx.readStepResult('step-name') para acessar dados de steps específicos
+ - ctx.readWorkflowInput() apenas se precisar dos dados iniciais
+ - ctx.env.{integration}.{tool} para chamadas de tools
+ `;
+ ```
+ 
+ ### Sistema de Coordenação e Execução
+ 
+ #### Workflow Execution Controller
+ ```typescript
+ class WorkflowExecutionController {
+   private workflow: ExtendedWorkflowDefinition;
+   private executionStates: Map<string, StepExecutionState>;
+   private aiClient: AIClient;
+   
+   constructor(workflow: ExtendedWorkflowDefinition) {
+     this.workflow = workflow;
+     this.executionStates = new Map();
+     this.aiClient = new AIClient();
+   }
+   
+   // Executa um step específico
+   async executeStep(stepIndex: number, config?: unknown): Promise<StepExecutionState> {
+     const step = this.workflow.steps[stepIndex];
+     const stepId = `step-${stepIndex}`;
+     
+     // Cria estado inicial
+     const executionState: StepExecutionState = {
+       stepId,
+       executionId: `exec-${Date.now()}`,
+       status: 'running',
+       input: await this.prepareStepInput(stepIndex, config),
+       execution: {
+         startedAt: new Date(),
+         retryCount: 0
+       },
+       logs: [],
+       toolCalls: [],
+       aiContext: {
+         summary: '',
+         dataShape: {},
+         businessContext: '',
+         suggestedNextActions: []
+       }
+     };
+     
+     this.executionStates.set(stepId, executionState);
+     
+     try {
+       // Executa o step usando sandbox
+       const result = await this.runStepInSandbox(step, executionState.input);
+       
+       // Atualiza estado com resultado
+       executionState.status = 'completed';
+       executionState.output = result.output;
+       executionState.execution.completedAt = new Date();
+       executionState.execution.duration = 
+         executionState.execution.completedAt.getTime() - 
+         executionState.execution.startedAt.getTime();
+       executionState.logs = result.logs;
+       executionState.toolCalls = result.toolCalls;
+       
+       // Gera contexto AI para próximos steps
+       executionState.aiContext = await this.generateAIContext(step, result);
+       
+     } catch (error) {
+       executionState.status = 'failed';
+       executionState.execution.error = {
+         message: error.message,
+         code: error.code || 'EXECUTION_ERROR',
+         stack: error.stack
+       };
+     }
+     
+     return executionState;
+   }
+   
+   // Prepara input para um step baseado em steps anteriores
+   private async prepareStepInput(stepIndex: number, config?: unknown) {
+     const input: any = {
+       stepConfig: config
+     };
+     
+     // Adiciona workflow input se for o primeiro step
+     if (stepIndex === 0) {
+       input.workflowInput = this.workflow.input;
+     }
+     
+     // Adiciona resultados de steps anteriores
+     input.previousStepResults = {};
+     for (let i = 0; i < stepIndex; i++) {
+       const prevStepId = `step-${i}`;
+       const prevState = this.executionStates.get(prevStepId);
+       if (prevState?.output) {
+         input.previousStepResults[prevStepId] = prevState.output;
+       }
+     }
+     
+     return input;
+   }
+   
+   // Gera contexto AI baseado na execução
+   private async generateAIContext(
+     step: ExtendedWorkflowStep, 
+     result: any
+   ): Promise<AIContext> {
+     const prompt = `
+     Analise a execução do step "${step.def.name}":
+     
+     Entrada: ${JSON.stringify(result.input)}
+     Saída: ${JSON.stringify(result.output)}
+     Tools usadas: ${result.toolCalls.map(t => t.toolName).join(', ')}
+     
+     Gere:
+     1. Resumo do que foi executado (1 linha)
+     2. Formato dos dados retornados
+     3. Contexto de negócio
+     4. 3 sugestões de próximas ações
+     `;
+     
+     const aiResponse = await this.aiClient.generateObject({
+       schema: AIContextSchema,
+       prompt
+     });
+     
+     return aiResponse;
+   }
+   
+   // Gera próximo step baseado no contexto atual
+   async generateNextStep(
+     userPrompt: string, 
+     selectedTools: Tool[]
+   ): Promise<ExtendedWorkflowStep> {
+     const context = this.buildGenerationContext(userPrompt, selectedTools);
+     
+     const generatedStep = await this.aiClient.generateObject({
+       schema: WorkflowStepSchema,
+       prompt: this.buildStepGenerationPrompt(context)
+     });
+     
+     return generatedStep;
+   }
+   
+   // Constrói contexto para geração de step
+   private buildGenerationContext(
+     userPrompt: string, 
+     selectedTools: Tool[]
+   ): AIStepGenerationContext {
+     return {
+       currentStep: this.workflow.steps.length,
+       previousSteps: Array.from(this.executionStates.values()),
+       availableData: this.getAllAvailableData(),
+       userPrompt,
+       selectedTools
+     };
+   }
+   
+   // Obtém todos os dados disponíveis de steps anteriores
+   private getAllAvailableData(): Record<string, unknown> {
+     const data: Record<string, unknown> = {};
+     
+     this.executionStates.forEach((state, stepId) => {
+       if (state.output) {
+         data[stepId] = state.output;
+       }
+     });
+     
+     return data;
+   }
+ }
+ ```
+ 
+ ## Modificações Necessárias no Sistema Atual
+ 
+ ### 1. Extensão do Schema de Workflow
+ 
+ #### Arquivo: `packages/sdk/src/mcp/sandbox/workflow-schemas.ts`
+ ```typescript
+ // Adicionar campos para UI de slides
+ export const ExtendedWorkflowStepDefinitionSchema = WorkflowStepDefinitionSchema.extend({
+   // Metadados gerados por AI
+   metadata: z.object({
+     title: z.string(),
+     description: z.string(),
+     generatedAt: z.date(),
+     version: z.number().default(1)
+   }).optional(),
+   
+   // Tools selecionadas pelo usuário
+   selectedTools: z.array(z.object({
+     name: z.string(),
+     integration: z.string(),
+     inputSchema: z.record(z.unknown()).optional()
+   })).optional(),
+   
+   // Prompt original do usuário
+   userPrompt: z.string().optional(),
+   
+   // Estado de execução persistente
+   executionState: z.object({
+     stepId: z.string(),
+     status: z.enum(['pending', 'running', 'completed', 'failed', 'skipped']),
+     input: z.record(z.unknown()).optional(),
+     output: z.record(z.unknown()).optional(),
+     execution: z.object({
+       startedAt: z.date(),
+       completedAt: z.date().optional(),
+       duration: z.number().optional(),
+       retryCount: z.number().default(0),
+       error: z.object({
+         message: z.string(),
+         code: z.string(),
+         stack: z.string().optional()
+       }).optional()
+     }),
+     logs: z.array(z.object({
+       timestamp: z.date(),
+       level: z.enum(['info', 'warn', 'error', 'debug']),
+       message: z.string(),
+       context: z.record(z.unknown()).optional()
+     })),
+     toolCalls: z.array(z.object({
+       toolName: z.string(),
+       integration: z.string(),
+       input: z.unknown(),
+       output: z.unknown(),
+       duration: z.number(),
+       success: z.boolean(),
+       error: z.string().optional()
+     })),
+     aiContext: z.object({
+       summary: z.string(),
+       dataShape: z.record(z.unknown()),
+       businessContext: z.string(),
+       suggestedNextActions: z.array(z.string())
+     })
+   }).optional()
+ });
+ 
+ export const ExtendedWorkflowDefinitionSchema = WorkflowDefinitionSchema.extend({
+   steps: z.array(ExtendedWorkflowStepDefinitionSchema),
+   
+   // Estado global do workflow
+   executionMetadata: z.object({
+     currentStep: z.number().default(0),
+     totalExecutions: z.number().default(0),
+     lastExecutedAt: z.date().optional(),
+     averageExecutionTime: z.number().optional()
+   }).optional()
+ });
+ ```
+ 
+ ### 2. Novos Endpoints para Execução Granular
+ 
+ #### Arquivo: `packages/sdk/src/mcp/sandbox/workflows.ts`
+ ```typescript
+ // Novo endpoint para executar step individual
+ const executeStepOnly = createTool({
+   name: "SANDBOX_EXECUTE_STEP",
+   description: "Execute apenas um step específico do workflow",
+   inputSchema: z.object({
+     workflowName: z.string(),
+     stepIndex: z.number(),
+     input: z.record(z.unknown()).optional(),
+     config: z.record(z.unknown()).optional()
+   }),
+   outputSchema: z.object({
+     stepId: z.string(),
+     executionState: ExtendedWorkflowStepDefinitionSchema.shape.executionState,
+     success: z.boolean(),
+     error: z.string().optional()
+   }),
+   handler: async ({ workflowName, stepIndex, input, config }, c) => {
+     // Implementação da execução individual de step
+     const controller = new WorkflowExecutionController(workflow);
+     const result = await controller.executeStep(stepIndex, config);
+     return result;
+   }
+ });
+ 
+ // Endpoint para gerar próximo step com AI
+ const generateNextStep = createTool({
+   name: "SANDBOX_GENERATE_NEXT_STEP", 
+   description: "Gera próximo step do workflow usando AI",
+   inputSchema: z.object({
+     workflowName: z.string(),
+     userPrompt: z.string(),
+     selectedTools: z.array(z.object({
+       name: z.string(),
+       integration: z.string()
+     }))
+   }),
+   outputSchema: z.object({
+     step: ExtendedWorkflowStepDefinitionSchema,
+     success: z.boolean(),
+     error: z.string().optional()
+   }),
+   handler: async ({ workflowName, userPrompt, selectedTools }, c) => {
+     // Carrega workflow atual
+     const workflow = await getWorkflow(workflowName);
+     const controller = new WorkflowExecutionController(workflow);
+     
+     // Gera próximo step com contexto
+     const nextStep = await controller.generateNextStep(userPrompt, selectedTools);
+     return { step: nextStep, success: true };
+   }
+ });
+ 
+ // Endpoint para obter contexto AI de steps anteriores
+ const getStepContext = createTool({
+   name: "SANDBOX_GET_STEP_CONTEXT",
+   description: "Obtém contexto AI de steps executados para geração de próximos steps",
+   inputSchema: z.object({
+     workflowName: z.string()
+   }),
+   outputSchema: z.object({
+     availableData: z.record(z.unknown()),
+     stepSummaries: z.array(z.string()),
+     suggestedActions: z.array(z.string())
+   }),
+   handler: async ({ workflowName }, c) => {
+     const workflow = await getWorkflow(workflowName);
+     const controller = new WorkflowExecutionController(workflow);
+     
+     return {
+       availableData: controller.getAllAvailableData(),
+       stepSummaries: workflow.steps.map(s => s.executionState?.aiContext?.summary || ''),
+       suggestedActions: workflow.steps.flatMap(s => 
+         s.executionState?.aiContext?.suggestedNextActions || []
+       )
+     };
+   }
+ });
+ ```
+ 
+ ### 3. Hooks para UI de Slides
+ 
+ #### Arquivo: `packages/sdk/src/hooks/workflow-slides.ts`
+ ```typescript
+ export function useWorkflowSlides(workflowName: string) {
+   const { data: workflow, mutate } = useWorkflow(workflowName);
+   const [currentSlide, setCurrentSlide] = useState(0);
+   
+   const slides = useMemo(() => {
+     if (!workflow) return [];
+     
+     return [
+       { type: 'input', data: workflow.inputSchema },
+       ...workflow.steps.map((step, index) => ({ 
+         type: 'step', 
+         data: step, 
+         index,
+         executionState: step.executionState
+       })),
+       { type: 'output', data: workflow.outputSchema }
+     ];
+   }, [workflow]);
+   
+   const executeStep = useCallback(async (stepIndex: number, config?: unknown) => {
+     const result = await MCPClient.SANDBOX_EXECUTE_STEP({
+       workflowName,
+       stepIndex,
+       config
+     });
+     
+     // Atualiza o workflow local com o novo estado de execução
+     mutate();
+     
+     return result;
+   }, [workflowName, mutate]);
+   
+   const generateNextStep = useCallback(async (
+     userPrompt: string, 
+     selectedTools: Tool[]
+   ) => {
+     const result = await MCPClient.SANDBOX_GENERATE_NEXT_STEP({
+       workflowName,
+       userPrompt,
+       selectedTools
+     });
+     
+     if (result.success) {
+       // Adiciona o novo step ao workflow
+       const updatedWorkflow = {
+         ...workflow,
+         steps: [...workflow.steps, result.step]
+       };
+       
+       await MCPClient.SANDBOX_UPSERT_WORKFLOW(updatedWorkflow);
+       mutate();
+     }
+     
+     return result;
+   }, [workflowName, workflow, mutate]);
+   
+   return {
+     slides,
+     currentSlide,
+     setCurrentSlide,
+     executeStep,
+     generateNextStep,
+     workflow
+   };
+ }
+ ```
+ 
+ ### 4. Componente de Canvas Rígido
+ 
+ #### Arquivo: `apps/web/src/components/workflow-builder/rigid-workflow-canvas.tsx`
+ ```typescript
+ interface RigidWorkflowCanvasProps {
+   workflowName: string;
+ }
+ 
+ export function RigidWorkflowCanvas({ workflowName }: RigidWorkflowCanvasProps) {
+   const { 
+     slides, 
+     currentSlide, 
+     setCurrentSlide, 
+     executeStep, 
+     generateNextStep 
+   } = useWorkflowSlides(workflowName);
+   
+   const [isExecuting, setIsExecuting] = useState(false);
+   const [executionController] = useState(() => new WorkflowExecutionController());
+   
+   // Frame que controla execução e coordena AI
+   const handleStepExecution = useCallback(async (stepIndex: number) => {
+     setIsExecuting(true);
+     
+     try {
+       // Executa step com controle rígido de estado
+       const result = await executeStep(stepIndex);
+       
+       // Atualiza indicadores visuais
+       toast.success(`Step ${stepIndex + 1} executado com sucesso`);
+       
+       // Se bem-sucedido, sugere próximas ações
+       if (result.executionState?.aiContext?.suggestedNextActions) {
+         // Mostra sugestões para o usuário
+         showSuggestedActions(result.executionState.aiContext.suggestedNextActions);
+       }
+       
+     } catch (error) {
+       toast.error(`Erro no step ${stepIndex + 1}: ${error.message}`);
+     } finally {
+       setIsExecuting(false);
+     }
+   }, [executeStep]);
+   
+   const handleAddStep = useCallback(async (
+     userPrompt: string, 
+     selectedTools: Tool[]
+   ) => {
+     setIsExecuting(true);
+     
+     try {
+       const result = await generateNextStep(userPrompt, selectedTools);
+       
+       if (result.success) {
+         // Navega automaticamente para o novo step
+         setCurrentSlide(slides.length);
+         toast.success('Novo step gerado com sucesso');
+       }
+       
+     } catch (error) {
+       toast.error(`Erro ao gerar step: ${error.message}`);
+     } finally {
+       setIsExecuting(false);
+     }
+   }, [generateNextStep, slides.length, setCurrentSlide]);
+   
+   return (
+     <div className="rigid-workflow-canvas h-screen flex flex-col">
+       {/* Header com controles globais */}
+       <WorkflowHeader 
+         workflowName={workflowName}
+         isExecuting={isExecuting}
+         onExecuteAll={handleExecuteAllSteps}
+       />
+       
+       {/* Navegação de slides com estado visual */}
+       <SlideNavigation
+         slides={slides}
+         currentSlide={currentSlide}
+         onSlideChange={setCurrentSlide}
+         executionStates={slides.map(s => s.executionState)}
+       />
+       
+       {/* Conteúdo do slide atual */}
+       <div className="flex-1 p-6">
+         <SlideContent
+           slide={slides[currentSlide]}
+           onExecuteStep={handleStepExecution}
+           onAddStep={handleAddStep}
+           isExecuting={isExecuting}
+         />
+       </div>
+       
+       {/* Footer com informações de contexto */}
+       <WorkflowFooter 
+         availableData={getAllAvailableStepData(slides)}
+         suggestions={getCurrentSuggestions(slides)}
+       />
+     </div>
+   );
+ }
+ ```
+ 
+ ### 5. Persistência de Estado Estendida
+ 
+ #### Modificação no Backend Storage
+ ```typescript
+ // Extensão da tabela de workflows para incluir execution states
+ interface WorkflowRecord {
+   id: string;
+   name: string;
+   definition: ExtendedWorkflowDefinition;
+   execution_states: Record<string, StepExecutionState>; // Novo campo
+   created_at: Date;
+   updated_at: Date;
+ }
+ 
+ // Novo serviço para gerenciar estados de execução
+ class WorkflowExecutionStateManager {
+   async saveStepState(
+     workflowName: string, 
+     stepId: string, 
+     state: StepExecutionState
+   ) {
+     // Salva estado individual do step
+     await db.workflows.update({
+       where: { name: workflowName },
+       data: {
+         execution_states: {
+           ...existingStates,
+           [stepId]: state
+         },
+         updated_at: new Date()
+       }
+     });
+   }
+   
+   async getStepStates(workflowName: string): Promise<Record<string, StepExecutionState>> {
+     const workflow = await db.workflows.findUnique({
+       where: { name: workflowName }
+     });
+     
+     return workflow?.execution_states || {};
+   }
+   
+   async clearStepStates(workflowName: string) {
+     await db.workflows.update({
+       where: { name: workflowName },
+       data: {
+         execution_states: {},
+         updated_at: new Date()
+       }
+     });
+   }
+ }
+ ```
+ 
+ ## Resumo das Modificações
+ 
+ ### Backend (Críticas)
+ 1. **Schema Extension**: Adicionar campos de execução ao workflow schema
+ 2. **New Endpoints**: SANDBOX_EXECUTE_STEP, SANDBOX_GENERATE_NEXT_STEP, SANDBOX_GET_STEP_CONTEXT
+ 3. **Execution Controller**: Classe para coordenar execução e AI
+ 4. **State Persistence**: Salvar estados de execução no banco
+ 
+ ### Frontend (UI)
+ 1. **Rigid Canvas**: Substituir canvas atual por versão controlada
+ 2. **Slide Navigation**: Indicadores visuais com estados de execução
+ 3. **Step Execution**: Controles para execução individual
+ 4. **AI Integration**: Interface para geração de próximos steps
+ 
+ ### Hooks e Estado
+ 1. **useWorkflowSlides**: Hook principal para slides
+ 2. **Execution State Management**: Gerenciamento local de estados
+ 3. **AI Context Awareness**: Contexto disponível para geração
+ 
+ Esta arquitetura cria um sistema rígido e controlado onde cada step mantém seu estado de execução completo, permitindo que a AI tenha contexto total para gerar próximos steps e que o usuário tenha visibilidade completa do que aconteceu em cada etapa do workflow.
  
  ## Conclusão
  
- A abordagem de slides oferece uma alternativa inovadora ao tradicional workflow builder baseado em nós e conexões. É especialmente adequada para workflows sequenciais onde a AI pode gerar código personalizado para cada step baseado em prompts do usuário e tools selecionadas.
+ A abordagem de slides com estado de execução persistente oferece uma alternativa inovadora ao tradicional workflow builder. O sistema mantém contexto completo de execução, permitindo que a AI gere steps mais inteligentes e que o usuário tenha controle granular sobre cada etapa.
  
- A interface familiar de slides, combinada com a potência da geração AI, cria uma experiência de usuário única que democratiza a criação de workflows complexos através de uma interface simples e intuitiva.
+ A interface familiar de slides, combinada com execução controlada e contexto AI, cria uma experiência única que democratiza a criação de workflows complexos através de uma interface simples, porém poderosa.
  
```

</details>

---

## Todo List

- [x] Add detailed step structure with AI-generated titles, descriptions, and schemas
- [x] Detail execution state JSON storage and AI context for next steps
- [x] Document specific system modifications needed for the new workflow canvas
- [x] Define execution controller framework that coordinates AI calls

---



---

Perfeito! Complementei o documento `plans/workflow_ui.md` com todos os detalhes que você mencionou. As principais adições incluem:

## 🎯 **Estrutura Detalhada dos Steps**

### **Anatomia Completa de um Step:**
- **Metadados Gerados por AI**: Title e Description condensados
- **Schemas Estruturados**: Input, Output e Config schemas
- **Código de Execução**: Custom tools que orquestram tool calls e data mapping
- **Estado de Execução Persistente**: JSON completo com contexto AI

### **ExecutionState JSON Crítico:**
```typescript
interface StepExecutionState {
  // ... dados de execução completos
  aiContext: {
    summary: string;           // Resumo condensado
    dataShape: unknown;        // Formato dos dados
    businessContext: string;   // Contexto de negócio
    suggestedNextActions: string[]; // Próximas ações sugeridas
  };
}
```

## 🤖 **AI Context Awareness**

### **Geração Inteligente de Próximos Steps:**
- A AI recebe contexto completo de todos os steps anteriores
- Dados disponíveis de qualquer step anterior (step-1, step-2, etc.)
- Prompts contextualizados com histórico de execução
- Sugestões automáticas de próximas ações

## ⚙️ **Sistema de Coordenação e Execução**

### **WorkflowExecutionController:**
- Execução individual de steps
- Preparação automática de inputs baseada em steps anteriores
- Geração de contexto AI após cada execução
- Coordenação de chamadas AI para próximos steps

## 🔧 **Modificações Pontuais no Sistema Atual**

### **Backend (Críticas):**
1. **Schema Extension**: `ExtendedWorkflowStepDefinitionSchema` com metadados AI
2. **Novos Endpoints**: 
   - `SANDBOX_EXECUTE_STEP`: Execução individual
   - `SANDBOX_GENERATE_NEXT_STEP`: Geração AI de próximos steps
   - `SANDBOX_GET_STEP_CONTEXT`: Contexto para AI
3. **Execution Controller**: Classe para coordenar execução e AI
4. **State Persistence**: Estados de execução salvos no banco

### **Frontend (UI):**
1. **Rigid Canvas**: Canvas controlado que substitui o atual
2. **Slide Navigation**: Indicadores visuais com estados de execução
3. **Step Execution**: Controles granulares por step
4. **AI Integration**: Interface para geração contextual

### **Hooks Especializados:**
- `useWorkflowSlides`: Gerenciamento de slides e execução
- Estados de execução sincronizados
- Contexto AI disponível para geração

## 🎨 **Canvas Rígido com Frame Controlador**

O novo sistema substitui o canvas atual por uma versão **rígida e controlada** que:

- **Controla execução**: Frame que coordena todas as execuções
- **Coordena AI**: Chama AI com contexto completo para gerar próximos steps
- **Mantém estado**: Cada step preserva seu estado de execução
- **Sugere ações**: AI sugere próximas ações baseadas no contexto

Esta arquitetura cria um sistema onde **cada step é uma entidade completa** que mantém seu estado de execução e contexto AI, permitindo que a AI gere próximos steps de forma inteligente com base no histórico completo do workflow.

O documento agora está completo com todos os detalhes técnicos necessários para implementar a nova interface de slides com execução controlada e geração AI contextual! 🚀

---

